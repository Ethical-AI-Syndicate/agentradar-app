
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model UserAlert
 * 
 */
export type UserAlert = $Result.DefaultSelection<Prisma.$UserAlertPayload>
/**
 * Model AlertPreference
 * 
 */
export type AlertPreference = $Result.DefaultSelection<Prisma.$AlertPreferencePayload>
/**
 * Model SavedProperty
 * 
 */
export type SavedProperty = $Result.DefaultSelection<Prisma.$SavedPropertyPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model EarlyAdopterToken
 * 
 */
export type EarlyAdopterToken = $Result.DefaultSelection<Prisma.$EarlyAdopterTokenPayload>
/**
 * Model CourtCase
 * 
 */
export type CourtCase = $Result.DefaultSelection<Prisma.$CourtCasePayload>
/**
 * Model CaseProcessingQueue
 * 
 */
export type CaseProcessingQueue = $Result.DefaultSelection<Prisma.$CaseProcessingQueuePayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model SupportTicketMessage
 * 
 */
export type SupportTicketMessage = $Result.DefaultSelection<Prisma.$SupportTicketMessagePayload>
/**
 * Model AdminAction
 * 
 */
export type AdminAction = $Result.DefaultSelection<Prisma.$AdminActionPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SubscriptionTier: {
  FREE: 'FREE',
  SOLO_AGENT: 'SOLO_AGENT',
  PROFESSIONAL: 'PROFESSIONAL',
  TEAM_ENTERPRISE: 'TEAM_ENTERPRISE',
  WHITE_LABEL: 'WHITE_LABEL'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]


export const AlertType: {
  POWER_OF_SALE: 'POWER_OF_SALE',
  ESTATE_SALE: 'ESTATE_SALE',
  DEVELOPMENT_APPLICATION: 'DEVELOPMENT_APPLICATION',
  MUNICIPAL_PERMIT: 'MUNICIPAL_PERMIT',
  PROBATE_FILING: 'PROBATE_FILING',
  TAX_SALE: 'TAX_SALE'
};

export type AlertType = (typeof AlertType)[keyof typeof AlertType]


export const DataSource: {
  ONTARIO_COURT_BULLETINS: 'ONTARIO_COURT_BULLETINS',
  ESTATE_FILINGS: 'ESTATE_FILINGS',
  MUNICIPAL_APPLICATIONS: 'MUNICIPAL_APPLICATIONS',
  DEVELOPMENT_PERMITS: 'DEVELOPMENT_PERMITS',
  TAX_OFFICE: 'TAX_OFFICE',
  MANUAL_ENTRY: 'MANUAL_ENTRY'
};

export type DataSource = (typeof DataSource)[keyof typeof DataSource]


export const AlertStatus: {
  ACTIVE: 'ACTIVE',
  RESOLVED: 'RESOLVED',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type AlertStatus = (typeof AlertStatus)[keyof typeof AlertStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const ActivityType: {
  USER_LOGIN: 'USER_LOGIN',
  USER_LOGOUT: 'USER_LOGOUT',
  ALERT_VIEWED: 'ALERT_VIEWED',
  ALERT_BOOKMARKED: 'ALERT_BOOKMARKED',
  PROPERTY_SAVED: 'PROPERTY_SAVED',
  SEARCH_PERFORMED: 'SEARCH_PERFORMED',
  PREFERENCES_UPDATED: 'PREFERENCES_UPDATED',
  SUBSCRIPTION_CHANGED: 'SUBSCRIPTION_CHANGED'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const CourtType: {
  ONSC: 'ONSC',
  ONCA: 'ONCA',
  ONCJ: 'ONCJ',
  ONSCDC: 'ONSCDC',
  OLT: 'OLT'
};

export type CourtType = (typeof CourtType)[keyof typeof CourtType]


export const RealEstateCaseType: {
  FORECLOSURE: 'FORECLOSURE',
  POWER_OF_SALE: 'POWER_OF_SALE',
  LIEN: 'LIEN',
  CONDO: 'CONDO',
  RECEIVERSHIP: 'RECEIVERSHIP',
  PLANNING: 'PLANNING',
  OLT_APPEAL: 'OLT_APPEAL',
  ENVIRONMENTAL: 'ENVIRONMENTAL',
  LABOUR_CONVICTION: 'LABOUR_CONVICTION',
  CONSTRUCTION_LIEN: 'CONSTRUCTION_LIEN',
  PLANNING_ACT: 'PLANNING_ACT',
  BIA_PROCEEDING: 'BIA_PROCEEDING'
};

export type RealEstateCaseType = (typeof RealEstateCaseType)[keyof typeof RealEstateCaseType]


export const RiskLevel: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type RiskLevel = (typeof RiskLevel)[keyof typeof RiskLevel]


export const ProcessingType: {
  NER_EXTRACTION: 'NER_EXTRACTION',
  CASE_CLASSIFICATION: 'CASE_CLASSIFICATION',
  RISK_ASSESSMENT: 'RISK_ASSESSMENT',
  ALERT_GENERATION: 'ALERT_GENERATION'
};

export type ProcessingType = (typeof ProcessingType)[keyof typeof ProcessingType]


export const ProcessingStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type ProcessingStatus = (typeof ProcessingStatus)[keyof typeof ProcessingStatus]


export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const SupportTicketStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  PENDING_USER: 'PENDING_USER',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type SupportTicketStatus = (typeof SupportTicketStatus)[keyof typeof SupportTicketStatus]


export const SupportTicketPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type SupportTicketPriority = (typeof SupportTicketPriority)[keyof typeof SupportTicketPriority]

}

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

export type AlertType = $Enums.AlertType

export const AlertType: typeof $Enums.AlertType

export type DataSource = $Enums.DataSource

export const DataSource: typeof $Enums.DataSource

export type AlertStatus = $Enums.AlertStatus

export const AlertStatus: typeof $Enums.AlertStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type CourtType = $Enums.CourtType

export const CourtType: typeof $Enums.CourtType

export type RealEstateCaseType = $Enums.RealEstateCaseType

export const RealEstateCaseType: typeof $Enums.RealEstateCaseType

export type RiskLevel = $Enums.RiskLevel

export const RiskLevel: typeof $Enums.RiskLevel

export type ProcessingType = $Enums.ProcessingType

export const ProcessingType: typeof $Enums.ProcessingType

export type ProcessingStatus = $Enums.ProcessingStatus

export const ProcessingStatus: typeof $Enums.ProcessingStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type SupportTicketStatus = $Enums.SupportTicketStatus

export const SupportTicketStatus: typeof $Enums.SupportTicketStatus

export type SupportTicketPriority = $Enums.SupportTicketPriority

export const SupportTicketPriority: typeof $Enums.SupportTicketPriority

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAlert`: Exposes CRUD operations for the **UserAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAlerts
    * const userAlerts = await prisma.userAlert.findMany()
    * ```
    */
  get userAlert(): Prisma.UserAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alertPreference`: Exposes CRUD operations for the **AlertPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertPreferences
    * const alertPreferences = await prisma.alertPreference.findMany()
    * ```
    */
  get alertPreference(): Prisma.AlertPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.savedProperty`: Exposes CRUD operations for the **SavedProperty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedProperties
    * const savedProperties = await prisma.savedProperty.findMany()
    * ```
    */
  get savedProperty(): Prisma.SavedPropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.earlyAdopterToken`: Exposes CRUD operations for the **EarlyAdopterToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EarlyAdopterTokens
    * const earlyAdopterTokens = await prisma.earlyAdopterToken.findMany()
    * ```
    */
  get earlyAdopterToken(): Prisma.EarlyAdopterTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courtCase`: Exposes CRUD operations for the **CourtCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourtCases
    * const courtCases = await prisma.courtCase.findMany()
    * ```
    */
  get courtCase(): Prisma.CourtCaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseProcessingQueue`: Exposes CRUD operations for the **CaseProcessingQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseProcessingQueues
    * const caseProcessingQueues = await prisma.caseProcessingQueue.findMany()
    * ```
    */
  get caseProcessingQueue(): Prisma.CaseProcessingQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportTicketMessage`: Exposes CRUD operations for the **SupportTicketMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTicketMessages
    * const supportTicketMessages = await prisma.supportTicketMessage.findMany()
    * ```
    */
  get supportTicketMessage(): Prisma.SupportTicketMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminAction`: Exposes CRUD operations for the **AdminAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminActions
    * const adminActions = await prisma.adminAction.findMany()
    * ```
    */
  get adminAction(): Prisma.AdminActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Alert: 'Alert',
    UserAlert: 'UserAlert',
    AlertPreference: 'AlertPreference',
    SavedProperty: 'SavedProperty',
    ActivityLog: 'ActivityLog',
    EarlyAdopterToken: 'EarlyAdopterToken',
    CourtCase: 'CourtCase',
    CaseProcessingQueue: 'CaseProcessingQueue',
    SupportTicket: 'SupportTicket',
    SupportTicketMessage: 'SupportTicketMessage',
    AdminAction: 'AdminAction',
    SystemSetting: 'SystemSetting'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "alert" | "userAlert" | "alertPreference" | "savedProperty" | "activityLog" | "earlyAdopterToken" | "courtCase" | "caseProcessingQueue" | "supportTicket" | "supportTicketMessage" | "adminAction" | "systemSetting"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      UserAlert: {
        payload: Prisma.$UserAlertPayload<ExtArgs>
        fields: Prisma.UserAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>
          }
          findFirst: {
            args: Prisma.UserAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>
          }
          findMany: {
            args: Prisma.UserAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>[]
          }
          create: {
            args: Prisma.UserAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>
          }
          createMany: {
            args: Prisma.UserAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>[]
          }
          delete: {
            args: Prisma.UserAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>
          }
          update: {
            args: Prisma.UserAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>
          }
          deleteMany: {
            args: Prisma.UserAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>[]
          }
          upsert: {
            args: Prisma.UserAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAlertPayload>
          }
          aggregate: {
            args: Prisma.UserAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAlert>
          }
          groupBy: {
            args: Prisma.UserAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAlertCountArgs<ExtArgs>
            result: $Utils.Optional<UserAlertCountAggregateOutputType> | number
          }
        }
      }
      AlertPreference: {
        payload: Prisma.$AlertPreferencePayload<ExtArgs>
        fields: Prisma.AlertPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPreferencePayload>
          }
          findFirst: {
            args: Prisma.AlertPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPreferencePayload>
          }
          findMany: {
            args: Prisma.AlertPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPreferencePayload>[]
          }
          create: {
            args: Prisma.AlertPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPreferencePayload>
          }
          createMany: {
            args: Prisma.AlertPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPreferencePayload>[]
          }
          delete: {
            args: Prisma.AlertPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPreferencePayload>
          }
          update: {
            args: Prisma.AlertPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPreferencePayload>
          }
          deleteMany: {
            args: Prisma.AlertPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlertPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPreferencePayload>[]
          }
          upsert: {
            args: Prisma.AlertPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPreferencePayload>
          }
          aggregate: {
            args: Prisma.AlertPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertPreference>
          }
          groupBy: {
            args: Prisma.AlertPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<AlertPreferenceCountAggregateOutputType> | number
          }
        }
      }
      SavedProperty: {
        payload: Prisma.$SavedPropertyPayload<ExtArgs>
        fields: Prisma.SavedPropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedPropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedPropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPropertyPayload>
          }
          findFirst: {
            args: Prisma.SavedPropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedPropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPropertyPayload>
          }
          findMany: {
            args: Prisma.SavedPropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPropertyPayload>[]
          }
          create: {
            args: Prisma.SavedPropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPropertyPayload>
          }
          createMany: {
            args: Prisma.SavedPropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedPropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPropertyPayload>[]
          }
          delete: {
            args: Prisma.SavedPropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPropertyPayload>
          }
          update: {
            args: Prisma.SavedPropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPropertyPayload>
          }
          deleteMany: {
            args: Prisma.SavedPropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedPropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SavedPropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPropertyPayload>[]
          }
          upsert: {
            args: Prisma.SavedPropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedPropertyPayload>
          }
          aggregate: {
            args: Prisma.SavedPropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedProperty>
          }
          groupBy: {
            args: Prisma.SavedPropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedPropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedPropertyCountArgs<ExtArgs>
            result: $Utils.Optional<SavedPropertyCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      EarlyAdopterToken: {
        payload: Prisma.$EarlyAdopterTokenPayload<ExtArgs>
        fields: Prisma.EarlyAdopterTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EarlyAdopterTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EarlyAdopterTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EarlyAdopterTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EarlyAdopterTokenPayload>
          }
          findFirst: {
            args: Prisma.EarlyAdopterTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EarlyAdopterTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EarlyAdopterTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EarlyAdopterTokenPayload>
          }
          findMany: {
            args: Prisma.EarlyAdopterTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EarlyAdopterTokenPayload>[]
          }
          create: {
            args: Prisma.EarlyAdopterTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EarlyAdopterTokenPayload>
          }
          createMany: {
            args: Prisma.EarlyAdopterTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EarlyAdopterTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EarlyAdopterTokenPayload>[]
          }
          delete: {
            args: Prisma.EarlyAdopterTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EarlyAdopterTokenPayload>
          }
          update: {
            args: Prisma.EarlyAdopterTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EarlyAdopterTokenPayload>
          }
          deleteMany: {
            args: Prisma.EarlyAdopterTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EarlyAdopterTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EarlyAdopterTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EarlyAdopterTokenPayload>[]
          }
          upsert: {
            args: Prisma.EarlyAdopterTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EarlyAdopterTokenPayload>
          }
          aggregate: {
            args: Prisma.EarlyAdopterTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEarlyAdopterToken>
          }
          groupBy: {
            args: Prisma.EarlyAdopterTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<EarlyAdopterTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.EarlyAdopterTokenCountArgs<ExtArgs>
            result: $Utils.Optional<EarlyAdopterTokenCountAggregateOutputType> | number
          }
        }
      }
      CourtCase: {
        payload: Prisma.$CourtCasePayload<ExtArgs>
        fields: Prisma.CourtCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourtCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourtCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCasePayload>
          }
          findFirst: {
            args: Prisma.CourtCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourtCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCasePayload>
          }
          findMany: {
            args: Prisma.CourtCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCasePayload>[]
          }
          create: {
            args: Prisma.CourtCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCasePayload>
          }
          createMany: {
            args: Prisma.CourtCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourtCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCasePayload>[]
          }
          delete: {
            args: Prisma.CourtCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCasePayload>
          }
          update: {
            args: Prisma.CourtCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCasePayload>
          }
          deleteMany: {
            args: Prisma.CourtCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourtCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourtCaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCasePayload>[]
          }
          upsert: {
            args: Prisma.CourtCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtCasePayload>
          }
          aggregate: {
            args: Prisma.CourtCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourtCase>
          }
          groupBy: {
            args: Prisma.CourtCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourtCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourtCaseCountArgs<ExtArgs>
            result: $Utils.Optional<CourtCaseCountAggregateOutputType> | number
          }
        }
      }
      CaseProcessingQueue: {
        payload: Prisma.$CaseProcessingQueuePayload<ExtArgs>
        fields: Prisma.CaseProcessingQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseProcessingQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseProcessingQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseProcessingQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseProcessingQueuePayload>
          }
          findFirst: {
            args: Prisma.CaseProcessingQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseProcessingQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseProcessingQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseProcessingQueuePayload>
          }
          findMany: {
            args: Prisma.CaseProcessingQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseProcessingQueuePayload>[]
          }
          create: {
            args: Prisma.CaseProcessingQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseProcessingQueuePayload>
          }
          createMany: {
            args: Prisma.CaseProcessingQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseProcessingQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseProcessingQueuePayload>[]
          }
          delete: {
            args: Prisma.CaseProcessingQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseProcessingQueuePayload>
          }
          update: {
            args: Prisma.CaseProcessingQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseProcessingQueuePayload>
          }
          deleteMany: {
            args: Prisma.CaseProcessingQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseProcessingQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaseProcessingQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseProcessingQueuePayload>[]
          }
          upsert: {
            args: Prisma.CaseProcessingQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseProcessingQueuePayload>
          }
          aggregate: {
            args: Prisma.CaseProcessingQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseProcessingQueue>
          }
          groupBy: {
            args: Prisma.CaseProcessingQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseProcessingQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseProcessingQueueCountArgs<ExtArgs>
            result: $Utils.Optional<CaseProcessingQueueCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportTicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      SupportTicketMessage: {
        payload: Prisma.$SupportTicketMessagePayload<ExtArgs>
        fields: Prisma.SupportTicketMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>
          }
          findFirst: {
            args: Prisma.SupportTicketMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>
          }
          findMany: {
            args: Prisma.SupportTicketMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>[]
          }
          create: {
            args: Prisma.SupportTicketMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>
          }
          createMany: {
            args: Prisma.SupportTicketMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>[]
          }
          delete: {
            args: Prisma.SupportTicketMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>
          }
          update: {
            args: Prisma.SupportTicketMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportTicketMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>[]
          }
          upsert: {
            args: Prisma.SupportTicketMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketMessagePayload>
          }
          aggregate: {
            args: Prisma.SupportTicketMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicketMessage>
          }
          groupBy: {
            args: Prisma.SupportTicketMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketMessageCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketMessageCountAggregateOutputType> | number
          }
        }
      }
      AdminAction: {
        payload: Prisma.$AdminActionPayload<ExtArgs>
        fields: Prisma.AdminActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>
          }
          findFirst: {
            args: Prisma.AdminActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>
          }
          findMany: {
            args: Prisma.AdminActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>[]
          }
          create: {
            args: Prisma.AdminActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>
          }
          createMany: {
            args: Prisma.AdminActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>[]
          }
          delete: {
            args: Prisma.AdminActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>
          }
          update: {
            args: Prisma.AdminActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>
          }
          deleteMany: {
            args: Prisma.AdminActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>[]
          }
          upsert: {
            args: Prisma.AdminActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActionPayload>
          }
          aggregate: {
            args: Prisma.AdminActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAction>
          }
          groupBy: {
            args: Prisma.AdminActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminActionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminActionCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    alert?: AlertOmit
    userAlert?: UserAlertOmit
    alertPreference?: AlertPreferenceOmit
    savedProperty?: SavedPropertyOmit
    activityLog?: ActivityLogOmit
    earlyAdopterToken?: EarlyAdopterTokenOmit
    courtCase?: CourtCaseOmit
    caseProcessingQueue?: CaseProcessingQueueOmit
    supportTicket?: SupportTicketOmit
    supportTicketMessage?: SupportTicketMessageOmit
    adminAction?: AdminActionOmit
    systemSetting?: SystemSettingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    alertPreferences: number
    userAlerts: number
    savedProperties: number
    activityLogs: number
    supportTickets: number
    assignedTickets: number
    ticketMessages: number
    adminActions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alertPreferences?: boolean | UserCountOutputTypeCountAlertPreferencesArgs
    userAlerts?: boolean | UserCountOutputTypeCountUserAlertsArgs
    savedProperties?: boolean | UserCountOutputTypeCountSavedPropertiesArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    supportTickets?: boolean | UserCountOutputTypeCountSupportTicketsArgs
    assignedTickets?: boolean | UserCountOutputTypeCountAssignedTicketsArgs
    ticketMessages?: boolean | UserCountOutputTypeCountTicketMessagesArgs
    adminActions?: boolean | UserCountOutputTypeCountAdminActionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlertPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertPreferenceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedPropertyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActionWhereInput
  }


  /**
   * Count Type AlertCountOutputType
   */

  export type AlertCountOutputType = {
    userAlerts: number
  }

  export type AlertCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAlerts?: boolean | AlertCountOutputTypeCountUserAlertsArgs
  }

  // Custom InputTypes
  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCountOutputType
     */
    select?: AlertCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeCountUserAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAlertWhereInput
  }


  /**
   * Count Type CourtCaseCountOutputType
   */

  export type CourtCaseCountOutputType = {
    alerts: number
    processingQueue: number
  }

  export type CourtCaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alerts?: boolean | CourtCaseCountOutputTypeCountAlertsArgs
    processingQueue?: boolean | CourtCaseCountOutputTypeCountProcessingQueueArgs
  }

  // Custom InputTypes
  /**
   * CourtCaseCountOutputType without action
   */
  export type CourtCaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCaseCountOutputType
     */
    select?: CourtCaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourtCaseCountOutputType without action
   */
  export type CourtCaseCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * CourtCaseCountOutputType without action
   */
  export type CourtCaseCountOutputTypeCountProcessingQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseProcessingQueueWhereInput
  }


  /**
   * Count Type SupportTicketCountOutputType
   */

  export type SupportTicketCountOutputType = {
    messages: number
  }

  export type SupportTicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | SupportTicketCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketCountOutputType
     */
    select?: SupportTicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    phone: string | null
    isActive: boolean | null
    role: $Enums.UserRole | null
    subscriptionTier: $Enums.SubscriptionTier | null
    stripeCustomerId: string | null
    subscriptionId: string | null
    subscriptionStatus: string | null
    company: string | null
    location: string | null
    teamSize: string | null
    monthlyDeals: string | null
    primaryFocus: string | null
    techComfort: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    phone: string | null
    isActive: boolean | null
    role: $Enums.UserRole | null
    subscriptionTier: $Enums.SubscriptionTier | null
    stripeCustomerId: string | null
    subscriptionId: string | null
    subscriptionStatus: string | null
    company: string | null
    location: string | null
    teamSize: string | null
    monthlyDeals: string | null
    primaryFocus: string | null
    techComfort: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    password: number
    phone: number
    isActive: number
    role: number
    subscriptionTier: number
    stripeCustomerId: number
    subscriptionId: number
    subscriptionStatus: number
    company: number
    location: number
    teamSize: number
    monthlyDeals: number
    primaryFocus: number
    techComfort: number
    currentChallenges: number
    createdAt: number
    updatedAt: number
    lastLogin: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    phone?: true
    isActive?: true
    role?: true
    subscriptionTier?: true
    stripeCustomerId?: true
    subscriptionId?: true
    subscriptionStatus?: true
    company?: true
    location?: true
    teamSize?: true
    monthlyDeals?: true
    primaryFocus?: true
    techComfort?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    phone?: true
    isActive?: true
    role?: true
    subscriptionTier?: true
    stripeCustomerId?: true
    subscriptionId?: true
    subscriptionStatus?: true
    company?: true
    location?: true
    teamSize?: true
    monthlyDeals?: true
    primaryFocus?: true
    techComfort?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    phone?: true
    isActive?: true
    role?: true
    subscriptionTier?: true
    stripeCustomerId?: true
    subscriptionId?: true
    subscriptionStatus?: true
    company?: true
    location?: true
    teamSize?: true
    monthlyDeals?: true
    primaryFocus?: true
    techComfort?: true
    currentChallenges?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone: string | null
    isActive: boolean
    role: $Enums.UserRole
    subscriptionTier: $Enums.SubscriptionTier
    stripeCustomerId: string | null
    subscriptionId: string | null
    subscriptionStatus: string | null
    company: string | null
    location: string | null
    teamSize: string | null
    monthlyDeals: string | null
    primaryFocus: string | null
    techComfort: string | null
    currentChallenges: string[]
    createdAt: Date
    updatedAt: Date
    lastLogin: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    phone?: boolean
    isActive?: boolean
    role?: boolean
    subscriptionTier?: boolean
    stripeCustomerId?: boolean
    subscriptionId?: boolean
    subscriptionStatus?: boolean
    company?: boolean
    location?: boolean
    teamSize?: boolean
    monthlyDeals?: boolean
    primaryFocus?: boolean
    techComfort?: boolean
    currentChallenges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    alertPreferences?: boolean | User$alertPreferencesArgs<ExtArgs>
    userAlerts?: boolean | User$userAlertsArgs<ExtArgs>
    savedProperties?: boolean | User$savedPropertiesArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    ticketMessages?: boolean | User$ticketMessagesArgs<ExtArgs>
    adminActions?: boolean | User$adminActionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    phone?: boolean
    isActive?: boolean
    role?: boolean
    subscriptionTier?: boolean
    stripeCustomerId?: boolean
    subscriptionId?: boolean
    subscriptionStatus?: boolean
    company?: boolean
    location?: boolean
    teamSize?: boolean
    monthlyDeals?: boolean
    primaryFocus?: boolean
    techComfort?: boolean
    currentChallenges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    phone?: boolean
    isActive?: boolean
    role?: boolean
    subscriptionTier?: boolean
    stripeCustomerId?: boolean
    subscriptionId?: boolean
    subscriptionStatus?: boolean
    company?: boolean
    location?: boolean
    teamSize?: boolean
    monthlyDeals?: boolean
    primaryFocus?: boolean
    techComfort?: boolean
    currentChallenges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    phone?: boolean
    isActive?: boolean
    role?: boolean
    subscriptionTier?: boolean
    stripeCustomerId?: boolean
    subscriptionId?: boolean
    subscriptionStatus?: boolean
    company?: boolean
    location?: boolean
    teamSize?: boolean
    monthlyDeals?: boolean
    primaryFocus?: boolean
    techComfort?: boolean
    currentChallenges?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "firstName" | "lastName" | "password" | "phone" | "isActive" | "role" | "subscriptionTier" | "stripeCustomerId" | "subscriptionId" | "subscriptionStatus" | "company" | "location" | "teamSize" | "monthlyDeals" | "primaryFocus" | "techComfort" | "currentChallenges" | "createdAt" | "updatedAt" | "lastLogin", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alertPreferences?: boolean | User$alertPreferencesArgs<ExtArgs>
    userAlerts?: boolean | User$userAlertsArgs<ExtArgs>
    savedProperties?: boolean | User$savedPropertiesArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    ticketMessages?: boolean | User$ticketMessagesArgs<ExtArgs>
    adminActions?: boolean | User$adminActionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      alertPreferences: Prisma.$AlertPreferencePayload<ExtArgs>[]
      userAlerts: Prisma.$UserAlertPayload<ExtArgs>[]
      savedProperties: Prisma.$SavedPropertyPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      supportTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      assignedTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      ticketMessages: Prisma.$SupportTicketMessagePayload<ExtArgs>[]
      adminActions: Prisma.$AdminActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      firstName: string
      lastName: string
      password: string
      phone: string | null
      isActive: boolean
      role: $Enums.UserRole
      subscriptionTier: $Enums.SubscriptionTier
      stripeCustomerId: string | null
      subscriptionId: string | null
      subscriptionStatus: string | null
      company: string | null
      location: string | null
      teamSize: string | null
      monthlyDeals: string | null
      primaryFocus: string | null
      techComfort: string | null
      currentChallenges: string[]
      createdAt: Date
      updatedAt: Date
      lastLogin: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alertPreferences<T extends User$alertPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$alertPreferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userAlerts<T extends User$userAlertsArgs<ExtArgs> = {}>(args?: Subset<T, User$userAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedProperties<T extends User$savedPropertiesArgs<ExtArgs> = {}>(args?: Subset<T, User$savedPropertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedPropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supportTickets<T extends User$supportTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$supportTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedTickets<T extends User$assignedTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketMessages<T extends User$ticketMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminActions<T extends User$adminActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$adminActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly subscriptionTier: FieldRef<"User", 'SubscriptionTier'>
    readonly stripeCustomerId: FieldRef<"User", 'String'>
    readonly subscriptionId: FieldRef<"User", 'String'>
    readonly subscriptionStatus: FieldRef<"User", 'String'>
    readonly company: FieldRef<"User", 'String'>
    readonly location: FieldRef<"User", 'String'>
    readonly teamSize: FieldRef<"User", 'String'>
    readonly monthlyDeals: FieldRef<"User", 'String'>
    readonly primaryFocus: FieldRef<"User", 'String'>
    readonly techComfort: FieldRef<"User", 'String'>
    readonly currentChallenges: FieldRef<"User", 'String[]'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.alertPreferences
   */
  export type User$alertPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceInclude<ExtArgs> | null
    where?: AlertPreferenceWhereInput
    orderBy?: AlertPreferenceOrderByWithRelationInput | AlertPreferenceOrderByWithRelationInput[]
    cursor?: AlertPreferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertPreferenceScalarFieldEnum | AlertPreferenceScalarFieldEnum[]
  }

  /**
   * User.userAlerts
   */
  export type User$userAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    where?: UserAlertWhereInput
    orderBy?: UserAlertOrderByWithRelationInput | UserAlertOrderByWithRelationInput[]
    cursor?: UserAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAlertScalarFieldEnum | UserAlertScalarFieldEnum[]
  }

  /**
   * User.savedProperties
   */
  export type User$savedPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyInclude<ExtArgs> | null
    where?: SavedPropertyWhereInput
    orderBy?: SavedPropertyOrderByWithRelationInput | SavedPropertyOrderByWithRelationInput[]
    cursor?: SavedPropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedPropertyScalarFieldEnum | SavedPropertyScalarFieldEnum[]
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.supportTickets
   */
  export type User$supportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.assignedTickets
   */
  export type User$assignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.ticketMessages
   */
  export type User$ticketMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageInclude<ExtArgs> | null
    where?: SupportTicketMessageWhereInput
    orderBy?: SupportTicketMessageOrderByWithRelationInput | SupportTicketMessageOrderByWithRelationInput[]
    cursor?: SupportTicketMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketMessageScalarFieldEnum | SupportTicketMessageScalarFieldEnum[]
  }

  /**
   * User.adminActions
   */
  export type User$adminActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    where?: AdminActionWhereInput
    orderBy?: AdminActionOrderByWithRelationInput | AdminActionOrderByWithRelationInput[]
    cursor?: AdminActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminActionScalarFieldEnum | AdminActionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertAvgAggregateOutputType = {
    opportunityScore: number | null
    timelineMonths: number | null
    estimatedValue: number | null
    bedrooms: number | null
    bathrooms: number | null
    latitude: number | null
    longitude: number | null
  }

  export type AlertSumAggregateOutputType = {
    opportunityScore: number | null
    timelineMonths: number | null
    estimatedValue: number | null
    bedrooms: number | null
    bathrooms: number | null
    latitude: number | null
    longitude: number | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    address: string | null
    city: string | null
    province: string | null
    postalCode: string | null
    alertType: $Enums.AlertType | null
    source: $Enums.DataSource | null
    status: $Enums.AlertStatus | null
    priority: $Enums.Priority | null
    opportunityScore: number | null
    timelineMonths: number | null
    propertyType: string | null
    estimatedValue: number | null
    lotSize: string | null
    bedrooms: number | null
    bathrooms: number | null
    courtFileNumber: string | null
    courtDate: Date | null
    courtCaseId: string | null
    probateNumber: string | null
    executorName: string | null
    executorContact: string | null
    applicationNumber: string | null
    municipalOffice: string | null
    applicationDate: Date | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    updatedAt: Date | null
    discoveredAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    address: string | null
    city: string | null
    province: string | null
    postalCode: string | null
    alertType: $Enums.AlertType | null
    source: $Enums.DataSource | null
    status: $Enums.AlertStatus | null
    priority: $Enums.Priority | null
    opportunityScore: number | null
    timelineMonths: number | null
    propertyType: string | null
    estimatedValue: number | null
    lotSize: string | null
    bedrooms: number | null
    bathrooms: number | null
    courtFileNumber: string | null
    courtDate: Date | null
    courtCaseId: string | null
    probateNumber: string | null
    executorName: string | null
    executorContact: string | null
    applicationNumber: string | null
    municipalOffice: string | null
    applicationDate: Date | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    updatedAt: Date | null
    discoveredAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    title: number
    description: number
    address: number
    city: number
    province: number
    postalCode: number
    alertType: number
    source: number
    status: number
    priority: number
    opportunityScore: number
    timelineMonths: number
    propertyType: number
    estimatedValue: number
    lotSize: number
    bedrooms: number
    bathrooms: number
    courtFileNumber: number
    courtDate: number
    courtCaseId: number
    probateNumber: number
    executorName: number
    executorContact: number
    applicationNumber: number
    municipalOffice: number
    applicationDate: number
    latitude: number
    longitude: number
    createdAt: number
    updatedAt: number
    discoveredAt: number
    _all: number
  }


  export type AlertAvgAggregateInputType = {
    opportunityScore?: true
    timelineMonths?: true
    estimatedValue?: true
    bedrooms?: true
    bathrooms?: true
    latitude?: true
    longitude?: true
  }

  export type AlertSumAggregateInputType = {
    opportunityScore?: true
    timelineMonths?: true
    estimatedValue?: true
    bedrooms?: true
    bathrooms?: true
    latitude?: true
    longitude?: true
  }

  export type AlertMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    address?: true
    city?: true
    province?: true
    postalCode?: true
    alertType?: true
    source?: true
    status?: true
    priority?: true
    opportunityScore?: true
    timelineMonths?: true
    propertyType?: true
    estimatedValue?: true
    lotSize?: true
    bedrooms?: true
    bathrooms?: true
    courtFileNumber?: true
    courtDate?: true
    courtCaseId?: true
    probateNumber?: true
    executorName?: true
    executorContact?: true
    applicationNumber?: true
    municipalOffice?: true
    applicationDate?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
    discoveredAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    address?: true
    city?: true
    province?: true
    postalCode?: true
    alertType?: true
    source?: true
    status?: true
    priority?: true
    opportunityScore?: true
    timelineMonths?: true
    propertyType?: true
    estimatedValue?: true
    lotSize?: true
    bedrooms?: true
    bathrooms?: true
    courtFileNumber?: true
    courtDate?: true
    courtCaseId?: true
    probateNumber?: true
    executorName?: true
    executorContact?: true
    applicationNumber?: true
    municipalOffice?: true
    applicationDate?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
    discoveredAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    address?: true
    city?: true
    province?: true
    postalCode?: true
    alertType?: true
    source?: true
    status?: true
    priority?: true
    opportunityScore?: true
    timelineMonths?: true
    propertyType?: true
    estimatedValue?: true
    lotSize?: true
    bedrooms?: true
    bathrooms?: true
    courtFileNumber?: true
    courtDate?: true
    courtCaseId?: true
    probateNumber?: true
    executorName?: true
    executorContact?: true
    applicationNumber?: true
    municipalOffice?: true
    applicationDate?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
    discoveredAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _avg?: AlertAvgAggregateInputType
    _sum?: AlertSumAggregateInputType
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    title: string
    description: string
    address: string
    city: string
    province: string
    postalCode: string | null
    alertType: $Enums.AlertType
    source: $Enums.DataSource
    status: $Enums.AlertStatus
    priority: $Enums.Priority
    opportunityScore: number
    timelineMonths: number | null
    propertyType: string | null
    estimatedValue: number | null
    lotSize: string | null
    bedrooms: number | null
    bathrooms: number | null
    courtFileNumber: string | null
    courtDate: Date | null
    courtCaseId: string | null
    probateNumber: string | null
    executorName: string | null
    executorContact: string | null
    applicationNumber: string | null
    municipalOffice: string | null
    applicationDate: Date | null
    latitude: number | null
    longitude: number | null
    createdAt: Date
    updatedAt: Date
    discoveredAt: Date
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    postalCode?: boolean
    alertType?: boolean
    source?: boolean
    status?: boolean
    priority?: boolean
    opportunityScore?: boolean
    timelineMonths?: boolean
    propertyType?: boolean
    estimatedValue?: boolean
    lotSize?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    courtFileNumber?: boolean
    courtDate?: boolean
    courtCaseId?: boolean
    probateNumber?: boolean
    executorName?: boolean
    executorContact?: boolean
    applicationNumber?: boolean
    municipalOffice?: boolean
    applicationDate?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discoveredAt?: boolean
    userAlerts?: boolean | Alert$userAlertsArgs<ExtArgs>
    courtCase?: boolean | Alert$courtCaseArgs<ExtArgs>
    _count?: boolean | AlertCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    postalCode?: boolean
    alertType?: boolean
    source?: boolean
    status?: boolean
    priority?: boolean
    opportunityScore?: boolean
    timelineMonths?: boolean
    propertyType?: boolean
    estimatedValue?: boolean
    lotSize?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    courtFileNumber?: boolean
    courtDate?: boolean
    courtCaseId?: boolean
    probateNumber?: boolean
    executorName?: boolean
    executorContact?: boolean
    applicationNumber?: boolean
    municipalOffice?: boolean
    applicationDate?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discoveredAt?: boolean
    courtCase?: boolean | Alert$courtCaseArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    postalCode?: boolean
    alertType?: boolean
    source?: boolean
    status?: boolean
    priority?: boolean
    opportunityScore?: boolean
    timelineMonths?: boolean
    propertyType?: boolean
    estimatedValue?: boolean
    lotSize?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    courtFileNumber?: boolean
    courtDate?: boolean
    courtCaseId?: boolean
    probateNumber?: boolean
    executorName?: boolean
    executorContact?: boolean
    applicationNumber?: boolean
    municipalOffice?: boolean
    applicationDate?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discoveredAt?: boolean
    courtCase?: boolean | Alert$courtCaseArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    postalCode?: boolean
    alertType?: boolean
    source?: boolean
    status?: boolean
    priority?: boolean
    opportunityScore?: boolean
    timelineMonths?: boolean
    propertyType?: boolean
    estimatedValue?: boolean
    lotSize?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    courtFileNumber?: boolean
    courtDate?: boolean
    courtCaseId?: boolean
    probateNumber?: boolean
    executorName?: boolean
    executorContact?: boolean
    applicationNumber?: boolean
    municipalOffice?: boolean
    applicationDate?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discoveredAt?: boolean
  }

  export type AlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "address" | "city" | "province" | "postalCode" | "alertType" | "source" | "status" | "priority" | "opportunityScore" | "timelineMonths" | "propertyType" | "estimatedValue" | "lotSize" | "bedrooms" | "bathrooms" | "courtFileNumber" | "courtDate" | "courtCaseId" | "probateNumber" | "executorName" | "executorContact" | "applicationNumber" | "municipalOffice" | "applicationDate" | "latitude" | "longitude" | "createdAt" | "updatedAt" | "discoveredAt", ExtArgs["result"]["alert"]>
  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAlerts?: boolean | Alert$userAlertsArgs<ExtArgs>
    courtCase?: boolean | Alert$courtCaseArgs<ExtArgs>
    _count?: boolean | AlertCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courtCase?: boolean | Alert$courtCaseArgs<ExtArgs>
  }
  export type AlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courtCase?: boolean | Alert$courtCaseArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      userAlerts: Prisma.$UserAlertPayload<ExtArgs>[]
      courtCase: Prisma.$CourtCasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      address: string
      city: string
      province: string
      postalCode: string | null
      alertType: $Enums.AlertType
      source: $Enums.DataSource
      status: $Enums.AlertStatus
      priority: $Enums.Priority
      opportunityScore: number
      timelineMonths: number | null
      propertyType: string | null
      estimatedValue: number | null
      lotSize: string | null
      bedrooms: number | null
      bathrooms: number | null
      courtFileNumber: string | null
      courtDate: Date | null
      courtCaseId: string | null
      probateNumber: string | null
      executorName: string | null
      executorContact: string | null
      applicationNumber: string | null
      municipalOffice: string | null
      applicationDate: Date | null
      latitude: number | null
      longitude: number | null
      createdAt: Date
      updatedAt: Date
      discoveredAt: Date
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts and returns the data updated in the database.
     * @param {AlertUpdateManyAndReturnArgs} args - Arguments to update many Alerts.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlertUpdateManyAndReturnArgs>(args: SelectSubset<T, AlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userAlerts<T extends Alert$userAlertsArgs<ExtArgs> = {}>(args?: Subset<T, Alert$userAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courtCase<T extends Alert$courtCaseArgs<ExtArgs> = {}>(args?: Subset<T, Alert$courtCaseArgs<ExtArgs>>): Prisma__CourtCaseClient<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly title: FieldRef<"Alert", 'String'>
    readonly description: FieldRef<"Alert", 'String'>
    readonly address: FieldRef<"Alert", 'String'>
    readonly city: FieldRef<"Alert", 'String'>
    readonly province: FieldRef<"Alert", 'String'>
    readonly postalCode: FieldRef<"Alert", 'String'>
    readonly alertType: FieldRef<"Alert", 'AlertType'>
    readonly source: FieldRef<"Alert", 'DataSource'>
    readonly status: FieldRef<"Alert", 'AlertStatus'>
    readonly priority: FieldRef<"Alert", 'Priority'>
    readonly opportunityScore: FieldRef<"Alert", 'Int'>
    readonly timelineMonths: FieldRef<"Alert", 'Int'>
    readonly propertyType: FieldRef<"Alert", 'String'>
    readonly estimatedValue: FieldRef<"Alert", 'Int'>
    readonly lotSize: FieldRef<"Alert", 'String'>
    readonly bedrooms: FieldRef<"Alert", 'Int'>
    readonly bathrooms: FieldRef<"Alert", 'Float'>
    readonly courtFileNumber: FieldRef<"Alert", 'String'>
    readonly courtDate: FieldRef<"Alert", 'DateTime'>
    readonly courtCaseId: FieldRef<"Alert", 'String'>
    readonly probateNumber: FieldRef<"Alert", 'String'>
    readonly executorName: FieldRef<"Alert", 'String'>
    readonly executorContact: FieldRef<"Alert", 'String'>
    readonly applicationNumber: FieldRef<"Alert", 'String'>
    readonly municipalOffice: FieldRef<"Alert", 'String'>
    readonly applicationDate: FieldRef<"Alert", 'DateTime'>
    readonly latitude: FieldRef<"Alert", 'Float'>
    readonly longitude: FieldRef<"Alert", 'Float'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
    readonly updatedAt: FieldRef<"Alert", 'DateTime'>
    readonly discoveredAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
  }

  /**
   * Alert updateManyAndReturn
   */
  export type AlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to delete.
     */
    limit?: number
  }

  /**
   * Alert.userAlerts
   */
  export type Alert$userAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    where?: UserAlertWhereInput
    orderBy?: UserAlertOrderByWithRelationInput | UserAlertOrderByWithRelationInput[]
    cursor?: UserAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAlertScalarFieldEnum | UserAlertScalarFieldEnum[]
  }

  /**
   * Alert.courtCase
   */
  export type Alert$courtCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCaseInclude<ExtArgs> | null
    where?: CourtCaseWhereInput
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model UserAlert
   */

  export type AggregateUserAlert = {
    _count: UserAlertCountAggregateOutputType | null
    _min: UserAlertMinAggregateOutputType | null
    _max: UserAlertMaxAggregateOutputType | null
  }

  export type UserAlertMinAggregateOutputType = {
    id: string | null
    userId: string | null
    alertId: string | null
    isNotified: boolean | null
    notifiedAt: Date | null
    isViewed: boolean | null
    viewedAt: Date | null
    isBookmarked: boolean | null
    createdAt: Date | null
  }

  export type UserAlertMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    alertId: string | null
    isNotified: boolean | null
    notifiedAt: Date | null
    isViewed: boolean | null
    viewedAt: Date | null
    isBookmarked: boolean | null
    createdAt: Date | null
  }

  export type UserAlertCountAggregateOutputType = {
    id: number
    userId: number
    alertId: number
    isNotified: number
    notifiedAt: number
    isViewed: number
    viewedAt: number
    isBookmarked: number
    createdAt: number
    _all: number
  }


  export type UserAlertMinAggregateInputType = {
    id?: true
    userId?: true
    alertId?: true
    isNotified?: true
    notifiedAt?: true
    isViewed?: true
    viewedAt?: true
    isBookmarked?: true
    createdAt?: true
  }

  export type UserAlertMaxAggregateInputType = {
    id?: true
    userId?: true
    alertId?: true
    isNotified?: true
    notifiedAt?: true
    isViewed?: true
    viewedAt?: true
    isBookmarked?: true
    createdAt?: true
  }

  export type UserAlertCountAggregateInputType = {
    id?: true
    userId?: true
    alertId?: true
    isNotified?: true
    notifiedAt?: true
    isViewed?: true
    viewedAt?: true
    isBookmarked?: true
    createdAt?: true
    _all?: true
  }

  export type UserAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAlert to aggregate.
     */
    where?: UserAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlerts to fetch.
     */
    orderBy?: UserAlertOrderByWithRelationInput | UserAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAlerts
    **/
    _count?: true | UserAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAlertMaxAggregateInputType
  }

  export type GetUserAlertAggregateType<T extends UserAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAlert[P]>
      : GetScalarType<T[P], AggregateUserAlert[P]>
  }




  export type UserAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAlertWhereInput
    orderBy?: UserAlertOrderByWithAggregationInput | UserAlertOrderByWithAggregationInput[]
    by: UserAlertScalarFieldEnum[] | UserAlertScalarFieldEnum
    having?: UserAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAlertCountAggregateInputType | true
    _min?: UserAlertMinAggregateInputType
    _max?: UserAlertMaxAggregateInputType
  }

  export type UserAlertGroupByOutputType = {
    id: string
    userId: string
    alertId: string
    isNotified: boolean
    notifiedAt: Date | null
    isViewed: boolean
    viewedAt: Date | null
    isBookmarked: boolean
    createdAt: Date
    _count: UserAlertCountAggregateOutputType | null
    _min: UserAlertMinAggregateOutputType | null
    _max: UserAlertMaxAggregateOutputType | null
  }

  type GetUserAlertGroupByPayload<T extends UserAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAlertGroupByOutputType[P]>
            : GetScalarType<T[P], UserAlertGroupByOutputType[P]>
        }
      >
    >


  export type UserAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    alertId?: boolean
    isNotified?: boolean
    notifiedAt?: boolean
    isViewed?: boolean
    viewedAt?: boolean
    isBookmarked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAlert"]>

  export type UserAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    alertId?: boolean
    isNotified?: boolean
    notifiedAt?: boolean
    isViewed?: boolean
    viewedAt?: boolean
    isBookmarked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAlert"]>

  export type UserAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    alertId?: boolean
    isNotified?: boolean
    notifiedAt?: boolean
    isViewed?: boolean
    viewedAt?: boolean
    isBookmarked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAlert"]>

  export type UserAlertSelectScalar = {
    id?: boolean
    userId?: boolean
    alertId?: boolean
    isNotified?: boolean
    notifiedAt?: boolean
    isViewed?: boolean
    viewedAt?: boolean
    isBookmarked?: boolean
    createdAt?: boolean
  }

  export type UserAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "alertId" | "isNotified" | "notifiedAt" | "isViewed" | "viewedAt" | "isBookmarked" | "createdAt", ExtArgs["result"]["userAlert"]>
  export type UserAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }
  export type UserAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }
  export type UserAlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    alert?: boolean | AlertDefaultArgs<ExtArgs>
  }

  export type $UserAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAlert"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      alert: Prisma.$AlertPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      alertId: string
      isNotified: boolean
      notifiedAt: Date | null
      isViewed: boolean
      viewedAt: Date | null
      isBookmarked: boolean
      createdAt: Date
    }, ExtArgs["result"]["userAlert"]>
    composites: {}
  }

  type UserAlertGetPayload<S extends boolean | null | undefined | UserAlertDefaultArgs> = $Result.GetResult<Prisma.$UserAlertPayload, S>

  type UserAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAlertCountAggregateInputType | true
    }

  export interface UserAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAlert'], meta: { name: 'UserAlert' } }
    /**
     * Find zero or one UserAlert that matches the filter.
     * @param {UserAlertFindUniqueArgs} args - Arguments to find a UserAlert
     * @example
     * // Get one UserAlert
     * const userAlert = await prisma.userAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAlertFindUniqueArgs>(args: SelectSubset<T, UserAlertFindUniqueArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAlertFindUniqueOrThrowArgs} args - Arguments to find a UserAlert
     * @example
     * // Get one UserAlert
     * const userAlert = await prisma.userAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertFindFirstArgs} args - Arguments to find a UserAlert
     * @example
     * // Get one UserAlert
     * const userAlert = await prisma.userAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAlertFindFirstArgs>(args?: SelectSubset<T, UserAlertFindFirstArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertFindFirstOrThrowArgs} args - Arguments to find a UserAlert
     * @example
     * // Get one UserAlert
     * const userAlert = await prisma.userAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAlerts
     * const userAlerts = await prisma.userAlert.findMany()
     * 
     * // Get first 10 UserAlerts
     * const userAlerts = await prisma.userAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAlertWithIdOnly = await prisma.userAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAlertFindManyArgs>(args?: SelectSubset<T, UserAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAlert.
     * @param {UserAlertCreateArgs} args - Arguments to create a UserAlert.
     * @example
     * // Create one UserAlert
     * const UserAlert = await prisma.userAlert.create({
     *   data: {
     *     // ... data to create a UserAlert
     *   }
     * })
     * 
     */
    create<T extends UserAlertCreateArgs>(args: SelectSubset<T, UserAlertCreateArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAlerts.
     * @param {UserAlertCreateManyArgs} args - Arguments to create many UserAlerts.
     * @example
     * // Create many UserAlerts
     * const userAlert = await prisma.userAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAlertCreateManyArgs>(args?: SelectSubset<T, UserAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAlerts and returns the data saved in the database.
     * @param {UserAlertCreateManyAndReturnArgs} args - Arguments to create many UserAlerts.
     * @example
     * // Create many UserAlerts
     * const userAlert = await prisma.userAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAlerts and only return the `id`
     * const userAlertWithIdOnly = await prisma.userAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAlert.
     * @param {UserAlertDeleteArgs} args - Arguments to delete one UserAlert.
     * @example
     * // Delete one UserAlert
     * const UserAlert = await prisma.userAlert.delete({
     *   where: {
     *     // ... filter to delete one UserAlert
     *   }
     * })
     * 
     */
    delete<T extends UserAlertDeleteArgs>(args: SelectSubset<T, UserAlertDeleteArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAlert.
     * @param {UserAlertUpdateArgs} args - Arguments to update one UserAlert.
     * @example
     * // Update one UserAlert
     * const userAlert = await prisma.userAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAlertUpdateArgs>(args: SelectSubset<T, UserAlertUpdateArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAlerts.
     * @param {UserAlertDeleteManyArgs} args - Arguments to filter UserAlerts to delete.
     * @example
     * // Delete a few UserAlerts
     * const { count } = await prisma.userAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAlertDeleteManyArgs>(args?: SelectSubset<T, UserAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAlerts
     * const userAlert = await prisma.userAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAlertUpdateManyArgs>(args: SelectSubset<T, UserAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAlerts and returns the data updated in the database.
     * @param {UserAlertUpdateManyAndReturnArgs} args - Arguments to update many UserAlerts.
     * @example
     * // Update many UserAlerts
     * const userAlert = await prisma.userAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAlerts and only return the `id`
     * const userAlertWithIdOnly = await prisma.userAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAlert.
     * @param {UserAlertUpsertArgs} args - Arguments to update or create a UserAlert.
     * @example
     * // Update or create a UserAlert
     * const userAlert = await prisma.userAlert.upsert({
     *   create: {
     *     // ... data to create a UserAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAlert we want to update
     *   }
     * })
     */
    upsert<T extends UserAlertUpsertArgs>(args: SelectSubset<T, UserAlertUpsertArgs<ExtArgs>>): Prisma__UserAlertClient<$Result.GetResult<Prisma.$UserAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertCountArgs} args - Arguments to filter UserAlerts to count.
     * @example
     * // Count the number of UserAlerts
     * const count = await prisma.userAlert.count({
     *   where: {
     *     // ... the filter for the UserAlerts we want to count
     *   }
     * })
    **/
    count<T extends UserAlertCountArgs>(
      args?: Subset<T, UserAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAlertAggregateArgs>(args: Subset<T, UserAlertAggregateArgs>): Prisma.PrismaPromise<GetUserAlertAggregateType<T>>

    /**
     * Group by UserAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAlertGroupByArgs['orderBy'] }
        : { orderBy?: UserAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAlert model
   */
  readonly fields: UserAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    alert<T extends AlertDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlertDefaultArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAlert model
   */
  interface UserAlertFieldRefs {
    readonly id: FieldRef<"UserAlert", 'String'>
    readonly userId: FieldRef<"UserAlert", 'String'>
    readonly alertId: FieldRef<"UserAlert", 'String'>
    readonly isNotified: FieldRef<"UserAlert", 'Boolean'>
    readonly notifiedAt: FieldRef<"UserAlert", 'DateTime'>
    readonly isViewed: FieldRef<"UserAlert", 'Boolean'>
    readonly viewedAt: FieldRef<"UserAlert", 'DateTime'>
    readonly isBookmarked: FieldRef<"UserAlert", 'Boolean'>
    readonly createdAt: FieldRef<"UserAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAlert findUnique
   */
  export type UserAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * Filter, which UserAlert to fetch.
     */
    where: UserAlertWhereUniqueInput
  }

  /**
   * UserAlert findUniqueOrThrow
   */
  export type UserAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * Filter, which UserAlert to fetch.
     */
    where: UserAlertWhereUniqueInput
  }

  /**
   * UserAlert findFirst
   */
  export type UserAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * Filter, which UserAlert to fetch.
     */
    where?: UserAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlerts to fetch.
     */
    orderBy?: UserAlertOrderByWithRelationInput | UserAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAlerts.
     */
    cursor?: UserAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAlerts.
     */
    distinct?: UserAlertScalarFieldEnum | UserAlertScalarFieldEnum[]
  }

  /**
   * UserAlert findFirstOrThrow
   */
  export type UserAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * Filter, which UserAlert to fetch.
     */
    where?: UserAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlerts to fetch.
     */
    orderBy?: UserAlertOrderByWithRelationInput | UserAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAlerts.
     */
    cursor?: UserAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAlerts.
     */
    distinct?: UserAlertScalarFieldEnum | UserAlertScalarFieldEnum[]
  }

  /**
   * UserAlert findMany
   */
  export type UserAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * Filter, which UserAlerts to fetch.
     */
    where?: UserAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAlerts to fetch.
     */
    orderBy?: UserAlertOrderByWithRelationInput | UserAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAlerts.
     */
    cursor?: UserAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAlerts.
     */
    skip?: number
    distinct?: UserAlertScalarFieldEnum | UserAlertScalarFieldEnum[]
  }

  /**
   * UserAlert create
   */
  export type UserAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAlert.
     */
    data: XOR<UserAlertCreateInput, UserAlertUncheckedCreateInput>
  }

  /**
   * UserAlert createMany
   */
  export type UserAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAlerts.
     */
    data: UserAlertCreateManyInput | UserAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAlert createManyAndReturn
   */
  export type UserAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * The data used to create many UserAlerts.
     */
    data: UserAlertCreateManyInput | UserAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAlert update
   */
  export type UserAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAlert.
     */
    data: XOR<UserAlertUpdateInput, UserAlertUncheckedUpdateInput>
    /**
     * Choose, which UserAlert to update.
     */
    where: UserAlertWhereUniqueInput
  }

  /**
   * UserAlert updateMany
   */
  export type UserAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAlerts.
     */
    data: XOR<UserAlertUpdateManyMutationInput, UserAlertUncheckedUpdateManyInput>
    /**
     * Filter which UserAlerts to update
     */
    where?: UserAlertWhereInput
    /**
     * Limit how many UserAlerts to update.
     */
    limit?: number
  }

  /**
   * UserAlert updateManyAndReturn
   */
  export type UserAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * The data used to update UserAlerts.
     */
    data: XOR<UserAlertUpdateManyMutationInput, UserAlertUncheckedUpdateManyInput>
    /**
     * Filter which UserAlerts to update
     */
    where?: UserAlertWhereInput
    /**
     * Limit how many UserAlerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAlert upsert
   */
  export type UserAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAlert to update in case it exists.
     */
    where: UserAlertWhereUniqueInput
    /**
     * In case the UserAlert found by the `where` argument doesn't exist, create a new UserAlert with this data.
     */
    create: XOR<UserAlertCreateInput, UserAlertUncheckedCreateInput>
    /**
     * In case the UserAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAlertUpdateInput, UserAlertUncheckedUpdateInput>
  }

  /**
   * UserAlert delete
   */
  export type UserAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
    /**
     * Filter which UserAlert to delete.
     */
    where: UserAlertWhereUniqueInput
  }

  /**
   * UserAlert deleteMany
   */
  export type UserAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAlerts to delete
     */
    where?: UserAlertWhereInput
    /**
     * Limit how many UserAlerts to delete.
     */
    limit?: number
  }

  /**
   * UserAlert without action
   */
  export type UserAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAlert
     */
    select?: UserAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAlert
     */
    omit?: UserAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAlertInclude<ExtArgs> | null
  }


  /**
   * Model AlertPreference
   */

  export type AggregateAlertPreference = {
    _count: AlertPreferenceCountAggregateOutputType | null
    _avg: AlertPreferenceAvgAggregateOutputType | null
    _sum: AlertPreferenceSumAggregateOutputType | null
    _min: AlertPreferenceMinAggregateOutputType | null
    _max: AlertPreferenceMaxAggregateOutputType | null
  }

  export type AlertPreferenceAvgAggregateOutputType = {
    maxDistanceKm: number | null
    minValue: number | null
    maxValue: number | null
    minBedrooms: number | null
    maxBedrooms: number | null
    minOpportunityScore: number | null
    maxAlertsPerDay: number | null
  }

  export type AlertPreferenceSumAggregateOutputType = {
    maxDistanceKm: number | null
    minValue: number | null
    maxValue: number | null
    minBedrooms: number | null
    maxBedrooms: number | null
    minOpportunityScore: number | null
    maxAlertsPerDay: number | null
  }

  export type AlertPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    maxDistanceKm: number | null
    minValue: number | null
    maxValue: number | null
    minBedrooms: number | null
    maxBedrooms: number | null
    minPriority: $Enums.Priority | null
    minOpportunityScore: number | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    pushNotifications: boolean | null
    maxAlertsPerDay: number | null
    quietHoursStart: string | null
    quietHoursEnd: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    maxDistanceKm: number | null
    minValue: number | null
    maxValue: number | null
    minBedrooms: number | null
    maxBedrooms: number | null
    minPriority: $Enums.Priority | null
    minOpportunityScore: number | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    pushNotifications: boolean | null
    maxAlertsPerDay: number | null
    quietHoursStart: string | null
    quietHoursEnd: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    cities: number
    maxDistanceKm: number
    propertyTypes: number
    minValue: number
    maxValue: number
    minBedrooms: number
    maxBedrooms: number
    alertTypes: number
    minPriority: number
    minOpportunityScore: number
    emailNotifications: number
    smsNotifications: number
    pushNotifications: number
    maxAlertsPerDay: number
    quietHoursStart: number
    quietHoursEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlertPreferenceAvgAggregateInputType = {
    maxDistanceKm?: true
    minValue?: true
    maxValue?: true
    minBedrooms?: true
    maxBedrooms?: true
    minOpportunityScore?: true
    maxAlertsPerDay?: true
  }

  export type AlertPreferenceSumAggregateInputType = {
    maxDistanceKm?: true
    minValue?: true
    maxValue?: true
    minBedrooms?: true
    maxBedrooms?: true
    minOpportunityScore?: true
    maxAlertsPerDay?: true
  }

  export type AlertPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    maxDistanceKm?: true
    minValue?: true
    maxValue?: true
    minBedrooms?: true
    maxBedrooms?: true
    minPriority?: true
    minOpportunityScore?: true
    emailNotifications?: true
    smsNotifications?: true
    pushNotifications?: true
    maxAlertsPerDay?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    maxDistanceKm?: true
    minValue?: true
    maxValue?: true
    minBedrooms?: true
    maxBedrooms?: true
    minPriority?: true
    minOpportunityScore?: true
    emailNotifications?: true
    smsNotifications?: true
    pushNotifications?: true
    maxAlertsPerDay?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    cities?: true
    maxDistanceKm?: true
    propertyTypes?: true
    minValue?: true
    maxValue?: true
    minBedrooms?: true
    maxBedrooms?: true
    alertTypes?: true
    minPriority?: true
    minOpportunityScore?: true
    emailNotifications?: true
    smsNotifications?: true
    pushNotifications?: true
    maxAlertsPerDay?: true
    quietHoursStart?: true
    quietHoursEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlertPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertPreference to aggregate.
     */
    where?: AlertPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertPreferences to fetch.
     */
    orderBy?: AlertPreferenceOrderByWithRelationInput | AlertPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlertPreferences
    **/
    _count?: true | AlertPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertPreferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertPreferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertPreferenceMaxAggregateInputType
  }

  export type GetAlertPreferenceAggregateType<T extends AlertPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertPreference[P]>
      : GetScalarType<T[P], AggregateAlertPreference[P]>
  }




  export type AlertPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertPreferenceWhereInput
    orderBy?: AlertPreferenceOrderByWithAggregationInput | AlertPreferenceOrderByWithAggregationInput[]
    by: AlertPreferenceScalarFieldEnum[] | AlertPreferenceScalarFieldEnum
    having?: AlertPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertPreferenceCountAggregateInputType | true
    _avg?: AlertPreferenceAvgAggregateInputType
    _sum?: AlertPreferenceSumAggregateInputType
    _min?: AlertPreferenceMinAggregateInputType
    _max?: AlertPreferenceMaxAggregateInputType
  }

  export type AlertPreferenceGroupByOutputType = {
    id: string
    userId: string
    cities: string[]
    maxDistanceKm: number
    propertyTypes: string[]
    minValue: number | null
    maxValue: number | null
    minBedrooms: number | null
    maxBedrooms: number | null
    alertTypes: $Enums.AlertType[]
    minPriority: $Enums.Priority
    minOpportunityScore: number
    emailNotifications: boolean
    smsNotifications: boolean
    pushNotifications: boolean
    maxAlertsPerDay: number
    quietHoursStart: string | null
    quietHoursEnd: string | null
    createdAt: Date
    updatedAt: Date
    _count: AlertPreferenceCountAggregateOutputType | null
    _avg: AlertPreferenceAvgAggregateOutputType | null
    _sum: AlertPreferenceSumAggregateOutputType | null
    _min: AlertPreferenceMinAggregateOutputType | null
    _max: AlertPreferenceMaxAggregateOutputType | null
  }

  type GetAlertPreferenceGroupByPayload<T extends AlertPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], AlertPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type AlertPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cities?: boolean
    maxDistanceKm?: boolean
    propertyTypes?: boolean
    minValue?: boolean
    maxValue?: boolean
    minBedrooms?: boolean
    maxBedrooms?: boolean
    alertTypes?: boolean
    minPriority?: boolean
    minOpportunityScore?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    maxAlertsPerDay?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertPreference"]>

  export type AlertPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cities?: boolean
    maxDistanceKm?: boolean
    propertyTypes?: boolean
    minValue?: boolean
    maxValue?: boolean
    minBedrooms?: boolean
    maxBedrooms?: boolean
    alertTypes?: boolean
    minPriority?: boolean
    minOpportunityScore?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    maxAlertsPerDay?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertPreference"]>

  export type AlertPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cities?: boolean
    maxDistanceKm?: boolean
    propertyTypes?: boolean
    minValue?: boolean
    maxValue?: boolean
    minBedrooms?: boolean
    maxBedrooms?: boolean
    alertTypes?: boolean
    minPriority?: boolean
    minOpportunityScore?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    maxAlertsPerDay?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertPreference"]>

  export type AlertPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    cities?: boolean
    maxDistanceKm?: boolean
    propertyTypes?: boolean
    minValue?: boolean
    maxValue?: boolean
    minBedrooms?: boolean
    maxBedrooms?: boolean
    alertTypes?: boolean
    minPriority?: boolean
    minOpportunityScore?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    maxAlertsPerDay?: boolean
    quietHoursStart?: boolean
    quietHoursEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlertPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "cities" | "maxDistanceKm" | "propertyTypes" | "minValue" | "maxValue" | "minBedrooms" | "maxBedrooms" | "alertTypes" | "minPriority" | "minOpportunityScore" | "emailNotifications" | "smsNotifications" | "pushNotifications" | "maxAlertsPerDay" | "quietHoursStart" | "quietHoursEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["alertPreference"]>
  export type AlertPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AlertPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AlertPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AlertPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlertPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      cities: string[]
      maxDistanceKm: number
      propertyTypes: string[]
      minValue: number | null
      maxValue: number | null
      minBedrooms: number | null
      maxBedrooms: number | null
      alertTypes: $Enums.AlertType[]
      minPriority: $Enums.Priority
      minOpportunityScore: number
      emailNotifications: boolean
      smsNotifications: boolean
      pushNotifications: boolean
      maxAlertsPerDay: number
      quietHoursStart: string | null
      quietHoursEnd: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alertPreference"]>
    composites: {}
  }

  type AlertPreferenceGetPayload<S extends boolean | null | undefined | AlertPreferenceDefaultArgs> = $Result.GetResult<Prisma.$AlertPreferencePayload, S>

  type AlertPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertPreferenceCountAggregateInputType | true
    }

  export interface AlertPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlertPreference'], meta: { name: 'AlertPreference' } }
    /**
     * Find zero or one AlertPreference that matches the filter.
     * @param {AlertPreferenceFindUniqueArgs} args - Arguments to find a AlertPreference
     * @example
     * // Get one AlertPreference
     * const alertPreference = await prisma.alertPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertPreferenceFindUniqueArgs>(args: SelectSubset<T, AlertPreferenceFindUniqueArgs<ExtArgs>>): Prisma__AlertPreferenceClient<$Result.GetResult<Prisma.$AlertPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AlertPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertPreferenceFindUniqueOrThrowArgs} args - Arguments to find a AlertPreference
     * @example
     * // Get one AlertPreference
     * const alertPreference = await prisma.alertPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertPreferenceClient<$Result.GetResult<Prisma.$AlertPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlertPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertPreferenceFindFirstArgs} args - Arguments to find a AlertPreference
     * @example
     * // Get one AlertPreference
     * const alertPreference = await prisma.alertPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertPreferenceFindFirstArgs>(args?: SelectSubset<T, AlertPreferenceFindFirstArgs<ExtArgs>>): Prisma__AlertPreferenceClient<$Result.GetResult<Prisma.$AlertPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AlertPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertPreferenceFindFirstOrThrowArgs} args - Arguments to find a AlertPreference
     * @example
     * // Get one AlertPreference
     * const alertPreference = await prisma.alertPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertPreferenceClient<$Result.GetResult<Prisma.$AlertPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AlertPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertPreferences
     * const alertPreferences = await prisma.alertPreference.findMany()
     * 
     * // Get first 10 AlertPreferences
     * const alertPreferences = await prisma.alertPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertPreferenceWithIdOnly = await prisma.alertPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertPreferenceFindManyArgs>(args?: SelectSubset<T, AlertPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AlertPreference.
     * @param {AlertPreferenceCreateArgs} args - Arguments to create a AlertPreference.
     * @example
     * // Create one AlertPreference
     * const AlertPreference = await prisma.alertPreference.create({
     *   data: {
     *     // ... data to create a AlertPreference
     *   }
     * })
     * 
     */
    create<T extends AlertPreferenceCreateArgs>(args: SelectSubset<T, AlertPreferenceCreateArgs<ExtArgs>>): Prisma__AlertPreferenceClient<$Result.GetResult<Prisma.$AlertPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AlertPreferences.
     * @param {AlertPreferenceCreateManyArgs} args - Arguments to create many AlertPreferences.
     * @example
     * // Create many AlertPreferences
     * const alertPreference = await prisma.alertPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertPreferenceCreateManyArgs>(args?: SelectSubset<T, AlertPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertPreferences and returns the data saved in the database.
     * @param {AlertPreferenceCreateManyAndReturnArgs} args - Arguments to create many AlertPreferences.
     * @example
     * // Create many AlertPreferences
     * const alertPreference = await prisma.alertPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertPreferences and only return the `id`
     * const alertPreferenceWithIdOnly = await prisma.alertPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AlertPreference.
     * @param {AlertPreferenceDeleteArgs} args - Arguments to delete one AlertPreference.
     * @example
     * // Delete one AlertPreference
     * const AlertPreference = await prisma.alertPreference.delete({
     *   where: {
     *     // ... filter to delete one AlertPreference
     *   }
     * })
     * 
     */
    delete<T extends AlertPreferenceDeleteArgs>(args: SelectSubset<T, AlertPreferenceDeleteArgs<ExtArgs>>): Prisma__AlertPreferenceClient<$Result.GetResult<Prisma.$AlertPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AlertPreference.
     * @param {AlertPreferenceUpdateArgs} args - Arguments to update one AlertPreference.
     * @example
     * // Update one AlertPreference
     * const alertPreference = await prisma.alertPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertPreferenceUpdateArgs>(args: SelectSubset<T, AlertPreferenceUpdateArgs<ExtArgs>>): Prisma__AlertPreferenceClient<$Result.GetResult<Prisma.$AlertPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AlertPreferences.
     * @param {AlertPreferenceDeleteManyArgs} args - Arguments to filter AlertPreferences to delete.
     * @example
     * // Delete a few AlertPreferences
     * const { count } = await prisma.alertPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertPreferenceDeleteManyArgs>(args?: SelectSubset<T, AlertPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertPreferences
     * const alertPreference = await prisma.alertPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertPreferenceUpdateManyArgs>(args: SelectSubset<T, AlertPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertPreferences and returns the data updated in the database.
     * @param {AlertPreferenceUpdateManyAndReturnArgs} args - Arguments to update many AlertPreferences.
     * @example
     * // Update many AlertPreferences
     * const alertPreference = await prisma.alertPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AlertPreferences and only return the `id`
     * const alertPreferenceWithIdOnly = await prisma.alertPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlertPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, AlertPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AlertPreference.
     * @param {AlertPreferenceUpsertArgs} args - Arguments to update or create a AlertPreference.
     * @example
     * // Update or create a AlertPreference
     * const alertPreference = await prisma.alertPreference.upsert({
     *   create: {
     *     // ... data to create a AlertPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertPreference we want to update
     *   }
     * })
     */
    upsert<T extends AlertPreferenceUpsertArgs>(args: SelectSubset<T, AlertPreferenceUpsertArgs<ExtArgs>>): Prisma__AlertPreferenceClient<$Result.GetResult<Prisma.$AlertPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AlertPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertPreferenceCountArgs} args - Arguments to filter AlertPreferences to count.
     * @example
     * // Count the number of AlertPreferences
     * const count = await prisma.alertPreference.count({
     *   where: {
     *     // ... the filter for the AlertPreferences we want to count
     *   }
     * })
    **/
    count<T extends AlertPreferenceCountArgs>(
      args?: Subset<T, AlertPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertPreferenceAggregateArgs>(args: Subset<T, AlertPreferenceAggregateArgs>): Prisma.PrismaPromise<GetAlertPreferenceAggregateType<T>>

    /**
     * Group by AlertPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: AlertPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlertPreference model
   */
  readonly fields: AlertPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlertPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlertPreference model
   */
  interface AlertPreferenceFieldRefs {
    readonly id: FieldRef<"AlertPreference", 'String'>
    readonly userId: FieldRef<"AlertPreference", 'String'>
    readonly cities: FieldRef<"AlertPreference", 'String[]'>
    readonly maxDistanceKm: FieldRef<"AlertPreference", 'Int'>
    readonly propertyTypes: FieldRef<"AlertPreference", 'String[]'>
    readonly minValue: FieldRef<"AlertPreference", 'Int'>
    readonly maxValue: FieldRef<"AlertPreference", 'Int'>
    readonly minBedrooms: FieldRef<"AlertPreference", 'Int'>
    readonly maxBedrooms: FieldRef<"AlertPreference", 'Int'>
    readonly alertTypes: FieldRef<"AlertPreference", 'AlertType[]'>
    readonly minPriority: FieldRef<"AlertPreference", 'Priority'>
    readonly minOpportunityScore: FieldRef<"AlertPreference", 'Int'>
    readonly emailNotifications: FieldRef<"AlertPreference", 'Boolean'>
    readonly smsNotifications: FieldRef<"AlertPreference", 'Boolean'>
    readonly pushNotifications: FieldRef<"AlertPreference", 'Boolean'>
    readonly maxAlertsPerDay: FieldRef<"AlertPreference", 'Int'>
    readonly quietHoursStart: FieldRef<"AlertPreference", 'String'>
    readonly quietHoursEnd: FieldRef<"AlertPreference", 'String'>
    readonly createdAt: FieldRef<"AlertPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"AlertPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AlertPreference findUnique
   */
  export type AlertPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which AlertPreference to fetch.
     */
    where: AlertPreferenceWhereUniqueInput
  }

  /**
   * AlertPreference findUniqueOrThrow
   */
  export type AlertPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which AlertPreference to fetch.
     */
    where: AlertPreferenceWhereUniqueInput
  }

  /**
   * AlertPreference findFirst
   */
  export type AlertPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which AlertPreference to fetch.
     */
    where?: AlertPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertPreferences to fetch.
     */
    orderBy?: AlertPreferenceOrderByWithRelationInput | AlertPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertPreferences.
     */
    cursor?: AlertPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertPreferences.
     */
    distinct?: AlertPreferenceScalarFieldEnum | AlertPreferenceScalarFieldEnum[]
  }

  /**
   * AlertPreference findFirstOrThrow
   */
  export type AlertPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which AlertPreference to fetch.
     */
    where?: AlertPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertPreferences to fetch.
     */
    orderBy?: AlertPreferenceOrderByWithRelationInput | AlertPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertPreferences.
     */
    cursor?: AlertPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertPreferences.
     */
    distinct?: AlertPreferenceScalarFieldEnum | AlertPreferenceScalarFieldEnum[]
  }

  /**
   * AlertPreference findMany
   */
  export type AlertPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which AlertPreferences to fetch.
     */
    where?: AlertPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertPreferences to fetch.
     */
    orderBy?: AlertPreferenceOrderByWithRelationInput | AlertPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlertPreferences.
     */
    cursor?: AlertPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertPreferences.
     */
    skip?: number
    distinct?: AlertPreferenceScalarFieldEnum | AlertPreferenceScalarFieldEnum[]
  }

  /**
   * AlertPreference create
   */
  export type AlertPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a AlertPreference.
     */
    data: XOR<AlertPreferenceCreateInput, AlertPreferenceUncheckedCreateInput>
  }

  /**
   * AlertPreference createMany
   */
  export type AlertPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlertPreferences.
     */
    data: AlertPreferenceCreateManyInput | AlertPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertPreference createManyAndReturn
   */
  export type AlertPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many AlertPreferences.
     */
    data: AlertPreferenceCreateManyInput | AlertPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlertPreference update
   */
  export type AlertPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a AlertPreference.
     */
    data: XOR<AlertPreferenceUpdateInput, AlertPreferenceUncheckedUpdateInput>
    /**
     * Choose, which AlertPreference to update.
     */
    where: AlertPreferenceWhereUniqueInput
  }

  /**
   * AlertPreference updateMany
   */
  export type AlertPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlertPreferences.
     */
    data: XOR<AlertPreferenceUpdateManyMutationInput, AlertPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which AlertPreferences to update
     */
    where?: AlertPreferenceWhereInput
    /**
     * Limit how many AlertPreferences to update.
     */
    limit?: number
  }

  /**
   * AlertPreference updateManyAndReturn
   */
  export type AlertPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update AlertPreferences.
     */
    data: XOR<AlertPreferenceUpdateManyMutationInput, AlertPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which AlertPreferences to update
     */
    where?: AlertPreferenceWhereInput
    /**
     * Limit how many AlertPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AlertPreference upsert
   */
  export type AlertPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the AlertPreference to update in case it exists.
     */
    where: AlertPreferenceWhereUniqueInput
    /**
     * In case the AlertPreference found by the `where` argument doesn't exist, create a new AlertPreference with this data.
     */
    create: XOR<AlertPreferenceCreateInput, AlertPreferenceUncheckedCreateInput>
    /**
     * In case the AlertPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertPreferenceUpdateInput, AlertPreferenceUncheckedUpdateInput>
  }

  /**
   * AlertPreference delete
   */
  export type AlertPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceInclude<ExtArgs> | null
    /**
     * Filter which AlertPreference to delete.
     */
    where: AlertPreferenceWhereUniqueInput
  }

  /**
   * AlertPreference deleteMany
   */
  export type AlertPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertPreferences to delete
     */
    where?: AlertPreferenceWhereInput
    /**
     * Limit how many AlertPreferences to delete.
     */
    limit?: number
  }

  /**
   * AlertPreference without action
   */
  export type AlertPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertPreference
     */
    select?: AlertPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AlertPreference
     */
    omit?: AlertPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model SavedProperty
   */

  export type AggregateSavedProperty = {
    _count: SavedPropertyCountAggregateOutputType | null
    _min: SavedPropertyMinAggregateOutputType | null
    _max: SavedPropertyMaxAggregateOutputType | null
  }

  export type SavedPropertyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    alertId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SavedPropertyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    alertId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SavedPropertyCountAggregateOutputType = {
    id: number
    userId: number
    alertId: number
    notes: number
    tags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SavedPropertyMinAggregateInputType = {
    id?: true
    userId?: true
    alertId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SavedPropertyMaxAggregateInputType = {
    id?: true
    userId?: true
    alertId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SavedPropertyCountAggregateInputType = {
    id?: true
    userId?: true
    alertId?: true
    notes?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SavedPropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedProperty to aggregate.
     */
    where?: SavedPropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedProperties to fetch.
     */
    orderBy?: SavedPropertyOrderByWithRelationInput | SavedPropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedPropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedProperties
    **/
    _count?: true | SavedPropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedPropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedPropertyMaxAggregateInputType
  }

  export type GetSavedPropertyAggregateType<T extends SavedPropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedProperty[P]>
      : GetScalarType<T[P], AggregateSavedProperty[P]>
  }




  export type SavedPropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedPropertyWhereInput
    orderBy?: SavedPropertyOrderByWithAggregationInput | SavedPropertyOrderByWithAggregationInput[]
    by: SavedPropertyScalarFieldEnum[] | SavedPropertyScalarFieldEnum
    having?: SavedPropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedPropertyCountAggregateInputType | true
    _min?: SavedPropertyMinAggregateInputType
    _max?: SavedPropertyMaxAggregateInputType
  }

  export type SavedPropertyGroupByOutputType = {
    id: string
    userId: string
    alertId: string
    notes: string | null
    tags: string[]
    createdAt: Date
    updatedAt: Date
    _count: SavedPropertyCountAggregateOutputType | null
    _min: SavedPropertyMinAggregateOutputType | null
    _max: SavedPropertyMaxAggregateOutputType | null
  }

  type GetSavedPropertyGroupByPayload<T extends SavedPropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedPropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedPropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedPropertyGroupByOutputType[P]>
            : GetScalarType<T[P], SavedPropertyGroupByOutputType[P]>
        }
      >
    >


  export type SavedPropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    alertId?: boolean
    notes?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedProperty"]>

  export type SavedPropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    alertId?: boolean
    notes?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedProperty"]>

  export type SavedPropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    alertId?: boolean
    notes?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedProperty"]>

  export type SavedPropertySelectScalar = {
    id?: boolean
    userId?: boolean
    alertId?: boolean
    notes?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SavedPropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "alertId" | "notes" | "tags" | "createdAt" | "updatedAt", ExtArgs["result"]["savedProperty"]>
  export type SavedPropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SavedPropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SavedPropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SavedPropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedProperty"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      alertId: string
      notes: string | null
      tags: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["savedProperty"]>
    composites: {}
  }

  type SavedPropertyGetPayload<S extends boolean | null | undefined | SavedPropertyDefaultArgs> = $Result.GetResult<Prisma.$SavedPropertyPayload, S>

  type SavedPropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SavedPropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SavedPropertyCountAggregateInputType | true
    }

  export interface SavedPropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedProperty'], meta: { name: 'SavedProperty' } }
    /**
     * Find zero or one SavedProperty that matches the filter.
     * @param {SavedPropertyFindUniqueArgs} args - Arguments to find a SavedProperty
     * @example
     * // Get one SavedProperty
     * const savedProperty = await prisma.savedProperty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedPropertyFindUniqueArgs>(args: SelectSubset<T, SavedPropertyFindUniqueArgs<ExtArgs>>): Prisma__SavedPropertyClient<$Result.GetResult<Prisma.$SavedPropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SavedProperty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SavedPropertyFindUniqueOrThrowArgs} args - Arguments to find a SavedProperty
     * @example
     * // Get one SavedProperty
     * const savedProperty = await prisma.savedProperty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedPropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedPropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedPropertyClient<$Result.GetResult<Prisma.$SavedPropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedProperty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPropertyFindFirstArgs} args - Arguments to find a SavedProperty
     * @example
     * // Get one SavedProperty
     * const savedProperty = await prisma.savedProperty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedPropertyFindFirstArgs>(args?: SelectSubset<T, SavedPropertyFindFirstArgs<ExtArgs>>): Prisma__SavedPropertyClient<$Result.GetResult<Prisma.$SavedPropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedProperty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPropertyFindFirstOrThrowArgs} args - Arguments to find a SavedProperty
     * @example
     * // Get one SavedProperty
     * const savedProperty = await prisma.savedProperty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedPropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedPropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedPropertyClient<$Result.GetResult<Prisma.$SavedPropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SavedProperties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedProperties
     * const savedProperties = await prisma.savedProperty.findMany()
     * 
     * // Get first 10 SavedProperties
     * const savedProperties = await prisma.savedProperty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedPropertyWithIdOnly = await prisma.savedProperty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedPropertyFindManyArgs>(args?: SelectSubset<T, SavedPropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedPropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SavedProperty.
     * @param {SavedPropertyCreateArgs} args - Arguments to create a SavedProperty.
     * @example
     * // Create one SavedProperty
     * const SavedProperty = await prisma.savedProperty.create({
     *   data: {
     *     // ... data to create a SavedProperty
     *   }
     * })
     * 
     */
    create<T extends SavedPropertyCreateArgs>(args: SelectSubset<T, SavedPropertyCreateArgs<ExtArgs>>): Prisma__SavedPropertyClient<$Result.GetResult<Prisma.$SavedPropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SavedProperties.
     * @param {SavedPropertyCreateManyArgs} args - Arguments to create many SavedProperties.
     * @example
     * // Create many SavedProperties
     * const savedProperty = await prisma.savedProperty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedPropertyCreateManyArgs>(args?: SelectSubset<T, SavedPropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedProperties and returns the data saved in the database.
     * @param {SavedPropertyCreateManyAndReturnArgs} args - Arguments to create many SavedProperties.
     * @example
     * // Create many SavedProperties
     * const savedProperty = await prisma.savedProperty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedProperties and only return the `id`
     * const savedPropertyWithIdOnly = await prisma.savedProperty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedPropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedPropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedPropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SavedProperty.
     * @param {SavedPropertyDeleteArgs} args - Arguments to delete one SavedProperty.
     * @example
     * // Delete one SavedProperty
     * const SavedProperty = await prisma.savedProperty.delete({
     *   where: {
     *     // ... filter to delete one SavedProperty
     *   }
     * })
     * 
     */
    delete<T extends SavedPropertyDeleteArgs>(args: SelectSubset<T, SavedPropertyDeleteArgs<ExtArgs>>): Prisma__SavedPropertyClient<$Result.GetResult<Prisma.$SavedPropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SavedProperty.
     * @param {SavedPropertyUpdateArgs} args - Arguments to update one SavedProperty.
     * @example
     * // Update one SavedProperty
     * const savedProperty = await prisma.savedProperty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedPropertyUpdateArgs>(args: SelectSubset<T, SavedPropertyUpdateArgs<ExtArgs>>): Prisma__SavedPropertyClient<$Result.GetResult<Prisma.$SavedPropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SavedProperties.
     * @param {SavedPropertyDeleteManyArgs} args - Arguments to filter SavedProperties to delete.
     * @example
     * // Delete a few SavedProperties
     * const { count } = await prisma.savedProperty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedPropertyDeleteManyArgs>(args?: SelectSubset<T, SavedPropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedProperties
     * const savedProperty = await prisma.savedProperty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedPropertyUpdateManyArgs>(args: SelectSubset<T, SavedPropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedProperties and returns the data updated in the database.
     * @param {SavedPropertyUpdateManyAndReturnArgs} args - Arguments to update many SavedProperties.
     * @example
     * // Update many SavedProperties
     * const savedProperty = await prisma.savedProperty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SavedProperties and only return the `id`
     * const savedPropertyWithIdOnly = await prisma.savedProperty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SavedPropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, SavedPropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedPropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SavedProperty.
     * @param {SavedPropertyUpsertArgs} args - Arguments to update or create a SavedProperty.
     * @example
     * // Update or create a SavedProperty
     * const savedProperty = await prisma.savedProperty.upsert({
     *   create: {
     *     // ... data to create a SavedProperty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedProperty we want to update
     *   }
     * })
     */
    upsert<T extends SavedPropertyUpsertArgs>(args: SelectSubset<T, SavedPropertyUpsertArgs<ExtArgs>>): Prisma__SavedPropertyClient<$Result.GetResult<Prisma.$SavedPropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SavedProperties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPropertyCountArgs} args - Arguments to filter SavedProperties to count.
     * @example
     * // Count the number of SavedProperties
     * const count = await prisma.savedProperty.count({
     *   where: {
     *     // ... the filter for the SavedProperties we want to count
     *   }
     * })
    **/
    count<T extends SavedPropertyCountArgs>(
      args?: Subset<T, SavedPropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedPropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedProperty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedPropertyAggregateArgs>(args: Subset<T, SavedPropertyAggregateArgs>): Prisma.PrismaPromise<GetSavedPropertyAggregateType<T>>

    /**
     * Group by SavedProperty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedPropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedPropertyGroupByArgs['orderBy'] }
        : { orderBy?: SavedPropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedPropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedProperty model
   */
  readonly fields: SavedPropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedProperty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedPropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedProperty model
   */
  interface SavedPropertyFieldRefs {
    readonly id: FieldRef<"SavedProperty", 'String'>
    readonly userId: FieldRef<"SavedProperty", 'String'>
    readonly alertId: FieldRef<"SavedProperty", 'String'>
    readonly notes: FieldRef<"SavedProperty", 'String'>
    readonly tags: FieldRef<"SavedProperty", 'String[]'>
    readonly createdAt: FieldRef<"SavedProperty", 'DateTime'>
    readonly updatedAt: FieldRef<"SavedProperty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedProperty findUnique
   */
  export type SavedPropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyInclude<ExtArgs> | null
    /**
     * Filter, which SavedProperty to fetch.
     */
    where: SavedPropertyWhereUniqueInput
  }

  /**
   * SavedProperty findUniqueOrThrow
   */
  export type SavedPropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyInclude<ExtArgs> | null
    /**
     * Filter, which SavedProperty to fetch.
     */
    where: SavedPropertyWhereUniqueInput
  }

  /**
   * SavedProperty findFirst
   */
  export type SavedPropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyInclude<ExtArgs> | null
    /**
     * Filter, which SavedProperty to fetch.
     */
    where?: SavedPropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedProperties to fetch.
     */
    orderBy?: SavedPropertyOrderByWithRelationInput | SavedPropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedProperties.
     */
    cursor?: SavedPropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedProperties.
     */
    distinct?: SavedPropertyScalarFieldEnum | SavedPropertyScalarFieldEnum[]
  }

  /**
   * SavedProperty findFirstOrThrow
   */
  export type SavedPropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyInclude<ExtArgs> | null
    /**
     * Filter, which SavedProperty to fetch.
     */
    where?: SavedPropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedProperties to fetch.
     */
    orderBy?: SavedPropertyOrderByWithRelationInput | SavedPropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedProperties.
     */
    cursor?: SavedPropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedProperties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedProperties.
     */
    distinct?: SavedPropertyScalarFieldEnum | SavedPropertyScalarFieldEnum[]
  }

  /**
   * SavedProperty findMany
   */
  export type SavedPropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyInclude<ExtArgs> | null
    /**
     * Filter, which SavedProperties to fetch.
     */
    where?: SavedPropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedProperties to fetch.
     */
    orderBy?: SavedPropertyOrderByWithRelationInput | SavedPropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedProperties.
     */
    cursor?: SavedPropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedProperties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedProperties.
     */
    skip?: number
    distinct?: SavedPropertyScalarFieldEnum | SavedPropertyScalarFieldEnum[]
  }

  /**
   * SavedProperty create
   */
  export type SavedPropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedProperty.
     */
    data: XOR<SavedPropertyCreateInput, SavedPropertyUncheckedCreateInput>
  }

  /**
   * SavedProperty createMany
   */
  export type SavedPropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedProperties.
     */
    data: SavedPropertyCreateManyInput | SavedPropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedProperty createManyAndReturn
   */
  export type SavedPropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * The data used to create many SavedProperties.
     */
    data: SavedPropertyCreateManyInput | SavedPropertyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedProperty update
   */
  export type SavedPropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedProperty.
     */
    data: XOR<SavedPropertyUpdateInput, SavedPropertyUncheckedUpdateInput>
    /**
     * Choose, which SavedProperty to update.
     */
    where: SavedPropertyWhereUniqueInput
  }

  /**
   * SavedProperty updateMany
   */
  export type SavedPropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedProperties.
     */
    data: XOR<SavedPropertyUpdateManyMutationInput, SavedPropertyUncheckedUpdateManyInput>
    /**
     * Filter which SavedProperties to update
     */
    where?: SavedPropertyWhereInput
    /**
     * Limit how many SavedProperties to update.
     */
    limit?: number
  }

  /**
   * SavedProperty updateManyAndReturn
   */
  export type SavedPropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * The data used to update SavedProperties.
     */
    data: XOR<SavedPropertyUpdateManyMutationInput, SavedPropertyUncheckedUpdateManyInput>
    /**
     * Filter which SavedProperties to update
     */
    where?: SavedPropertyWhereInput
    /**
     * Limit how many SavedProperties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedProperty upsert
   */
  export type SavedPropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedProperty to update in case it exists.
     */
    where: SavedPropertyWhereUniqueInput
    /**
     * In case the SavedProperty found by the `where` argument doesn't exist, create a new SavedProperty with this data.
     */
    create: XOR<SavedPropertyCreateInput, SavedPropertyUncheckedCreateInput>
    /**
     * In case the SavedProperty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedPropertyUpdateInput, SavedPropertyUncheckedUpdateInput>
  }

  /**
   * SavedProperty delete
   */
  export type SavedPropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyInclude<ExtArgs> | null
    /**
     * Filter which SavedProperty to delete.
     */
    where: SavedPropertyWhereUniqueInput
  }

  /**
   * SavedProperty deleteMany
   */
  export type SavedPropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedProperties to delete
     */
    where?: SavedPropertyWhereInput
    /**
     * Limit how many SavedProperties to delete.
     */
    limit?: number
  }

  /**
   * SavedProperty without action
   */
  export type SavedPropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedProperty
     */
    select?: SavedPropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SavedProperty
     */
    omit?: SavedPropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedPropertyInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: $Enums.ActivityType | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: $Enums.ActivityType | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    userId: string | null
    action: $Enums.ActivityType
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "details" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: $Enums.ActivityType
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ActivityLog$userArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly userId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'ActivityType'>
    readonly details: FieldRef<"ActivityLog", 'Json'>
    readonly ipAddress: FieldRef<"ActivityLog", 'String'>
    readonly userAgent: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog.user
   */
  export type ActivityLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model EarlyAdopterToken
   */

  export type AggregateEarlyAdopterToken = {
    _count: EarlyAdopterTokenCountAggregateOutputType | null
    _avg: EarlyAdopterTokenAvgAggregateOutputType | null
    _sum: EarlyAdopterTokenSumAggregateOutputType | null
    _min: EarlyAdopterTokenMinAggregateOutputType | null
    _max: EarlyAdopterTokenMaxAggregateOutputType | null
  }

  export type EarlyAdopterTokenAvgAggregateOutputType = {
    discountPercent: number | null
  }

  export type EarlyAdopterTokenSumAggregateOutputType = {
    discountPercent: number | null
  }

  export type EarlyAdopterTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    company: string | null
    location: string | null
    teamSize: string | null
    monthlyDeals: string | null
    primaryFocus: string | null
    techComfort: string | null
    isUsed: boolean | null
    usedAt: Date | null
    userId: string | null
    discountPercent: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EarlyAdopterTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    company: string | null
    location: string | null
    teamSize: string | null
    monthlyDeals: string | null
    primaryFocus: string | null
    techComfort: string | null
    isUsed: boolean | null
    usedAt: Date | null
    userId: string | null
    discountPercent: number | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EarlyAdopterTokenCountAggregateOutputType = {
    id: number
    token: number
    email: number
    firstName: number
    lastName: number
    phone: number
    company: number
    location: number
    teamSize: number
    monthlyDeals: number
    primaryFocus: number
    currentChallenges: number
    techComfort: number
    isUsed: number
    usedAt: number
    userId: number
    discountPercent: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EarlyAdopterTokenAvgAggregateInputType = {
    discountPercent?: true
  }

  export type EarlyAdopterTokenSumAggregateInputType = {
    discountPercent?: true
  }

  export type EarlyAdopterTokenMinAggregateInputType = {
    id?: true
    token?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    company?: true
    location?: true
    teamSize?: true
    monthlyDeals?: true
    primaryFocus?: true
    techComfort?: true
    isUsed?: true
    usedAt?: true
    userId?: true
    discountPercent?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EarlyAdopterTokenMaxAggregateInputType = {
    id?: true
    token?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    company?: true
    location?: true
    teamSize?: true
    monthlyDeals?: true
    primaryFocus?: true
    techComfort?: true
    isUsed?: true
    usedAt?: true
    userId?: true
    discountPercent?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EarlyAdopterTokenCountAggregateInputType = {
    id?: true
    token?: true
    email?: true
    firstName?: true
    lastName?: true
    phone?: true
    company?: true
    location?: true
    teamSize?: true
    monthlyDeals?: true
    primaryFocus?: true
    currentChallenges?: true
    techComfort?: true
    isUsed?: true
    usedAt?: true
    userId?: true
    discountPercent?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EarlyAdopterTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EarlyAdopterToken to aggregate.
     */
    where?: EarlyAdopterTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EarlyAdopterTokens to fetch.
     */
    orderBy?: EarlyAdopterTokenOrderByWithRelationInput | EarlyAdopterTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EarlyAdopterTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EarlyAdopterTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EarlyAdopterTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EarlyAdopterTokens
    **/
    _count?: true | EarlyAdopterTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EarlyAdopterTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EarlyAdopterTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EarlyAdopterTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EarlyAdopterTokenMaxAggregateInputType
  }

  export type GetEarlyAdopterTokenAggregateType<T extends EarlyAdopterTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateEarlyAdopterToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEarlyAdopterToken[P]>
      : GetScalarType<T[P], AggregateEarlyAdopterToken[P]>
  }




  export type EarlyAdopterTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EarlyAdopterTokenWhereInput
    orderBy?: EarlyAdopterTokenOrderByWithAggregationInput | EarlyAdopterTokenOrderByWithAggregationInput[]
    by: EarlyAdopterTokenScalarFieldEnum[] | EarlyAdopterTokenScalarFieldEnum
    having?: EarlyAdopterTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EarlyAdopterTokenCountAggregateInputType | true
    _avg?: EarlyAdopterTokenAvgAggregateInputType
    _sum?: EarlyAdopterTokenSumAggregateInputType
    _min?: EarlyAdopterTokenMinAggregateInputType
    _max?: EarlyAdopterTokenMaxAggregateInputType
  }

  export type EarlyAdopterTokenGroupByOutputType = {
    id: string
    token: string
    email: string
    firstName: string
    lastName: string
    phone: string
    company: string
    location: string
    teamSize: string
    monthlyDeals: string
    primaryFocus: string
    currentChallenges: string[]
    techComfort: string
    isUsed: boolean
    usedAt: Date | null
    userId: string | null
    discountPercent: number
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EarlyAdopterTokenCountAggregateOutputType | null
    _avg: EarlyAdopterTokenAvgAggregateOutputType | null
    _sum: EarlyAdopterTokenSumAggregateOutputType | null
    _min: EarlyAdopterTokenMinAggregateOutputType | null
    _max: EarlyAdopterTokenMaxAggregateOutputType | null
  }

  type GetEarlyAdopterTokenGroupByPayload<T extends EarlyAdopterTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EarlyAdopterTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EarlyAdopterTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EarlyAdopterTokenGroupByOutputType[P]>
            : GetScalarType<T[P], EarlyAdopterTokenGroupByOutputType[P]>
        }
      >
    >


  export type EarlyAdopterTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    company?: boolean
    location?: boolean
    teamSize?: boolean
    monthlyDeals?: boolean
    primaryFocus?: boolean
    currentChallenges?: boolean
    techComfort?: boolean
    isUsed?: boolean
    usedAt?: boolean
    userId?: boolean
    discountPercent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["earlyAdopterToken"]>

  export type EarlyAdopterTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    company?: boolean
    location?: boolean
    teamSize?: boolean
    monthlyDeals?: boolean
    primaryFocus?: boolean
    currentChallenges?: boolean
    techComfort?: boolean
    isUsed?: boolean
    usedAt?: boolean
    userId?: boolean
    discountPercent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["earlyAdopterToken"]>

  export type EarlyAdopterTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    company?: boolean
    location?: boolean
    teamSize?: boolean
    monthlyDeals?: boolean
    primaryFocus?: boolean
    currentChallenges?: boolean
    techComfort?: boolean
    isUsed?: boolean
    usedAt?: boolean
    userId?: boolean
    discountPercent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["earlyAdopterToken"]>

  export type EarlyAdopterTokenSelectScalar = {
    id?: boolean
    token?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    company?: boolean
    location?: boolean
    teamSize?: boolean
    monthlyDeals?: boolean
    primaryFocus?: boolean
    currentChallenges?: boolean
    techComfort?: boolean
    isUsed?: boolean
    usedAt?: boolean
    userId?: boolean
    discountPercent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EarlyAdopterTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "email" | "firstName" | "lastName" | "phone" | "company" | "location" | "teamSize" | "monthlyDeals" | "primaryFocus" | "currentChallenges" | "techComfort" | "isUsed" | "usedAt" | "userId" | "discountPercent" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["earlyAdopterToken"]>

  export type $EarlyAdopterTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EarlyAdopterToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      email: string
      firstName: string
      lastName: string
      phone: string
      company: string
      location: string
      teamSize: string
      monthlyDeals: string
      primaryFocus: string
      currentChallenges: string[]
      techComfort: string
      isUsed: boolean
      usedAt: Date | null
      userId: string | null
      discountPercent: number
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["earlyAdopterToken"]>
    composites: {}
  }

  type EarlyAdopterTokenGetPayload<S extends boolean | null | undefined | EarlyAdopterTokenDefaultArgs> = $Result.GetResult<Prisma.$EarlyAdopterTokenPayload, S>

  type EarlyAdopterTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EarlyAdopterTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EarlyAdopterTokenCountAggregateInputType | true
    }

  export interface EarlyAdopterTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EarlyAdopterToken'], meta: { name: 'EarlyAdopterToken' } }
    /**
     * Find zero or one EarlyAdopterToken that matches the filter.
     * @param {EarlyAdopterTokenFindUniqueArgs} args - Arguments to find a EarlyAdopterToken
     * @example
     * // Get one EarlyAdopterToken
     * const earlyAdopterToken = await prisma.earlyAdopterToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EarlyAdopterTokenFindUniqueArgs>(args: SelectSubset<T, EarlyAdopterTokenFindUniqueArgs<ExtArgs>>): Prisma__EarlyAdopterTokenClient<$Result.GetResult<Prisma.$EarlyAdopterTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EarlyAdopterToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EarlyAdopterTokenFindUniqueOrThrowArgs} args - Arguments to find a EarlyAdopterToken
     * @example
     * // Get one EarlyAdopterToken
     * const earlyAdopterToken = await prisma.earlyAdopterToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EarlyAdopterTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, EarlyAdopterTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EarlyAdopterTokenClient<$Result.GetResult<Prisma.$EarlyAdopterTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EarlyAdopterToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarlyAdopterTokenFindFirstArgs} args - Arguments to find a EarlyAdopterToken
     * @example
     * // Get one EarlyAdopterToken
     * const earlyAdopterToken = await prisma.earlyAdopterToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EarlyAdopterTokenFindFirstArgs>(args?: SelectSubset<T, EarlyAdopterTokenFindFirstArgs<ExtArgs>>): Prisma__EarlyAdopterTokenClient<$Result.GetResult<Prisma.$EarlyAdopterTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EarlyAdopterToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarlyAdopterTokenFindFirstOrThrowArgs} args - Arguments to find a EarlyAdopterToken
     * @example
     * // Get one EarlyAdopterToken
     * const earlyAdopterToken = await prisma.earlyAdopterToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EarlyAdopterTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, EarlyAdopterTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__EarlyAdopterTokenClient<$Result.GetResult<Prisma.$EarlyAdopterTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EarlyAdopterTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarlyAdopterTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EarlyAdopterTokens
     * const earlyAdopterTokens = await prisma.earlyAdopterToken.findMany()
     * 
     * // Get first 10 EarlyAdopterTokens
     * const earlyAdopterTokens = await prisma.earlyAdopterToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const earlyAdopterTokenWithIdOnly = await prisma.earlyAdopterToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EarlyAdopterTokenFindManyArgs>(args?: SelectSubset<T, EarlyAdopterTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EarlyAdopterTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EarlyAdopterToken.
     * @param {EarlyAdopterTokenCreateArgs} args - Arguments to create a EarlyAdopterToken.
     * @example
     * // Create one EarlyAdopterToken
     * const EarlyAdopterToken = await prisma.earlyAdopterToken.create({
     *   data: {
     *     // ... data to create a EarlyAdopterToken
     *   }
     * })
     * 
     */
    create<T extends EarlyAdopterTokenCreateArgs>(args: SelectSubset<T, EarlyAdopterTokenCreateArgs<ExtArgs>>): Prisma__EarlyAdopterTokenClient<$Result.GetResult<Prisma.$EarlyAdopterTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EarlyAdopterTokens.
     * @param {EarlyAdopterTokenCreateManyArgs} args - Arguments to create many EarlyAdopterTokens.
     * @example
     * // Create many EarlyAdopterTokens
     * const earlyAdopterToken = await prisma.earlyAdopterToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EarlyAdopterTokenCreateManyArgs>(args?: SelectSubset<T, EarlyAdopterTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EarlyAdopterTokens and returns the data saved in the database.
     * @param {EarlyAdopterTokenCreateManyAndReturnArgs} args - Arguments to create many EarlyAdopterTokens.
     * @example
     * // Create many EarlyAdopterTokens
     * const earlyAdopterToken = await prisma.earlyAdopterToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EarlyAdopterTokens and only return the `id`
     * const earlyAdopterTokenWithIdOnly = await prisma.earlyAdopterToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EarlyAdopterTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, EarlyAdopterTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EarlyAdopterTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EarlyAdopterToken.
     * @param {EarlyAdopterTokenDeleteArgs} args - Arguments to delete one EarlyAdopterToken.
     * @example
     * // Delete one EarlyAdopterToken
     * const EarlyAdopterToken = await prisma.earlyAdopterToken.delete({
     *   where: {
     *     // ... filter to delete one EarlyAdopterToken
     *   }
     * })
     * 
     */
    delete<T extends EarlyAdopterTokenDeleteArgs>(args: SelectSubset<T, EarlyAdopterTokenDeleteArgs<ExtArgs>>): Prisma__EarlyAdopterTokenClient<$Result.GetResult<Prisma.$EarlyAdopterTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EarlyAdopterToken.
     * @param {EarlyAdopterTokenUpdateArgs} args - Arguments to update one EarlyAdopterToken.
     * @example
     * // Update one EarlyAdopterToken
     * const earlyAdopterToken = await prisma.earlyAdopterToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EarlyAdopterTokenUpdateArgs>(args: SelectSubset<T, EarlyAdopterTokenUpdateArgs<ExtArgs>>): Prisma__EarlyAdopterTokenClient<$Result.GetResult<Prisma.$EarlyAdopterTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EarlyAdopterTokens.
     * @param {EarlyAdopterTokenDeleteManyArgs} args - Arguments to filter EarlyAdopterTokens to delete.
     * @example
     * // Delete a few EarlyAdopterTokens
     * const { count } = await prisma.earlyAdopterToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EarlyAdopterTokenDeleteManyArgs>(args?: SelectSubset<T, EarlyAdopterTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EarlyAdopterTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarlyAdopterTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EarlyAdopterTokens
     * const earlyAdopterToken = await prisma.earlyAdopterToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EarlyAdopterTokenUpdateManyArgs>(args: SelectSubset<T, EarlyAdopterTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EarlyAdopterTokens and returns the data updated in the database.
     * @param {EarlyAdopterTokenUpdateManyAndReturnArgs} args - Arguments to update many EarlyAdopterTokens.
     * @example
     * // Update many EarlyAdopterTokens
     * const earlyAdopterToken = await prisma.earlyAdopterToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EarlyAdopterTokens and only return the `id`
     * const earlyAdopterTokenWithIdOnly = await prisma.earlyAdopterToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EarlyAdopterTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, EarlyAdopterTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EarlyAdopterTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EarlyAdopterToken.
     * @param {EarlyAdopterTokenUpsertArgs} args - Arguments to update or create a EarlyAdopterToken.
     * @example
     * // Update or create a EarlyAdopterToken
     * const earlyAdopterToken = await prisma.earlyAdopterToken.upsert({
     *   create: {
     *     // ... data to create a EarlyAdopterToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EarlyAdopterToken we want to update
     *   }
     * })
     */
    upsert<T extends EarlyAdopterTokenUpsertArgs>(args: SelectSubset<T, EarlyAdopterTokenUpsertArgs<ExtArgs>>): Prisma__EarlyAdopterTokenClient<$Result.GetResult<Prisma.$EarlyAdopterTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EarlyAdopterTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarlyAdopterTokenCountArgs} args - Arguments to filter EarlyAdopterTokens to count.
     * @example
     * // Count the number of EarlyAdopterTokens
     * const count = await prisma.earlyAdopterToken.count({
     *   where: {
     *     // ... the filter for the EarlyAdopterTokens we want to count
     *   }
     * })
    **/
    count<T extends EarlyAdopterTokenCountArgs>(
      args?: Subset<T, EarlyAdopterTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EarlyAdopterTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EarlyAdopterToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarlyAdopterTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EarlyAdopterTokenAggregateArgs>(args: Subset<T, EarlyAdopterTokenAggregateArgs>): Prisma.PrismaPromise<GetEarlyAdopterTokenAggregateType<T>>

    /**
     * Group by EarlyAdopterToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EarlyAdopterTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EarlyAdopterTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EarlyAdopterTokenGroupByArgs['orderBy'] }
        : { orderBy?: EarlyAdopterTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EarlyAdopterTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEarlyAdopterTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EarlyAdopterToken model
   */
  readonly fields: EarlyAdopterTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EarlyAdopterToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EarlyAdopterTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EarlyAdopterToken model
   */
  interface EarlyAdopterTokenFieldRefs {
    readonly id: FieldRef<"EarlyAdopterToken", 'String'>
    readonly token: FieldRef<"EarlyAdopterToken", 'String'>
    readonly email: FieldRef<"EarlyAdopterToken", 'String'>
    readonly firstName: FieldRef<"EarlyAdopterToken", 'String'>
    readonly lastName: FieldRef<"EarlyAdopterToken", 'String'>
    readonly phone: FieldRef<"EarlyAdopterToken", 'String'>
    readonly company: FieldRef<"EarlyAdopterToken", 'String'>
    readonly location: FieldRef<"EarlyAdopterToken", 'String'>
    readonly teamSize: FieldRef<"EarlyAdopterToken", 'String'>
    readonly monthlyDeals: FieldRef<"EarlyAdopterToken", 'String'>
    readonly primaryFocus: FieldRef<"EarlyAdopterToken", 'String'>
    readonly currentChallenges: FieldRef<"EarlyAdopterToken", 'String[]'>
    readonly techComfort: FieldRef<"EarlyAdopterToken", 'String'>
    readonly isUsed: FieldRef<"EarlyAdopterToken", 'Boolean'>
    readonly usedAt: FieldRef<"EarlyAdopterToken", 'DateTime'>
    readonly userId: FieldRef<"EarlyAdopterToken", 'String'>
    readonly discountPercent: FieldRef<"EarlyAdopterToken", 'Int'>
    readonly expiresAt: FieldRef<"EarlyAdopterToken", 'DateTime'>
    readonly createdAt: FieldRef<"EarlyAdopterToken", 'DateTime'>
    readonly updatedAt: FieldRef<"EarlyAdopterToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EarlyAdopterToken findUnique
   */
  export type EarlyAdopterTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EarlyAdopterToken
     */
    select?: EarlyAdopterTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EarlyAdopterToken
     */
    omit?: EarlyAdopterTokenOmit<ExtArgs> | null
    /**
     * Filter, which EarlyAdopterToken to fetch.
     */
    where: EarlyAdopterTokenWhereUniqueInput
  }

  /**
   * EarlyAdopterToken findUniqueOrThrow
   */
  export type EarlyAdopterTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EarlyAdopterToken
     */
    select?: EarlyAdopterTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EarlyAdopterToken
     */
    omit?: EarlyAdopterTokenOmit<ExtArgs> | null
    /**
     * Filter, which EarlyAdopterToken to fetch.
     */
    where: EarlyAdopterTokenWhereUniqueInput
  }

  /**
   * EarlyAdopterToken findFirst
   */
  export type EarlyAdopterTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EarlyAdopterToken
     */
    select?: EarlyAdopterTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EarlyAdopterToken
     */
    omit?: EarlyAdopterTokenOmit<ExtArgs> | null
    /**
     * Filter, which EarlyAdopterToken to fetch.
     */
    where?: EarlyAdopterTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EarlyAdopterTokens to fetch.
     */
    orderBy?: EarlyAdopterTokenOrderByWithRelationInput | EarlyAdopterTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EarlyAdopterTokens.
     */
    cursor?: EarlyAdopterTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EarlyAdopterTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EarlyAdopterTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EarlyAdopterTokens.
     */
    distinct?: EarlyAdopterTokenScalarFieldEnum | EarlyAdopterTokenScalarFieldEnum[]
  }

  /**
   * EarlyAdopterToken findFirstOrThrow
   */
  export type EarlyAdopterTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EarlyAdopterToken
     */
    select?: EarlyAdopterTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EarlyAdopterToken
     */
    omit?: EarlyAdopterTokenOmit<ExtArgs> | null
    /**
     * Filter, which EarlyAdopterToken to fetch.
     */
    where?: EarlyAdopterTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EarlyAdopterTokens to fetch.
     */
    orderBy?: EarlyAdopterTokenOrderByWithRelationInput | EarlyAdopterTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EarlyAdopterTokens.
     */
    cursor?: EarlyAdopterTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EarlyAdopterTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EarlyAdopterTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EarlyAdopterTokens.
     */
    distinct?: EarlyAdopterTokenScalarFieldEnum | EarlyAdopterTokenScalarFieldEnum[]
  }

  /**
   * EarlyAdopterToken findMany
   */
  export type EarlyAdopterTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EarlyAdopterToken
     */
    select?: EarlyAdopterTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EarlyAdopterToken
     */
    omit?: EarlyAdopterTokenOmit<ExtArgs> | null
    /**
     * Filter, which EarlyAdopterTokens to fetch.
     */
    where?: EarlyAdopterTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EarlyAdopterTokens to fetch.
     */
    orderBy?: EarlyAdopterTokenOrderByWithRelationInput | EarlyAdopterTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EarlyAdopterTokens.
     */
    cursor?: EarlyAdopterTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EarlyAdopterTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EarlyAdopterTokens.
     */
    skip?: number
    distinct?: EarlyAdopterTokenScalarFieldEnum | EarlyAdopterTokenScalarFieldEnum[]
  }

  /**
   * EarlyAdopterToken create
   */
  export type EarlyAdopterTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EarlyAdopterToken
     */
    select?: EarlyAdopterTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EarlyAdopterToken
     */
    omit?: EarlyAdopterTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a EarlyAdopterToken.
     */
    data: XOR<EarlyAdopterTokenCreateInput, EarlyAdopterTokenUncheckedCreateInput>
  }

  /**
   * EarlyAdopterToken createMany
   */
  export type EarlyAdopterTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EarlyAdopterTokens.
     */
    data: EarlyAdopterTokenCreateManyInput | EarlyAdopterTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EarlyAdopterToken createManyAndReturn
   */
  export type EarlyAdopterTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EarlyAdopterToken
     */
    select?: EarlyAdopterTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EarlyAdopterToken
     */
    omit?: EarlyAdopterTokenOmit<ExtArgs> | null
    /**
     * The data used to create many EarlyAdopterTokens.
     */
    data: EarlyAdopterTokenCreateManyInput | EarlyAdopterTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EarlyAdopterToken update
   */
  export type EarlyAdopterTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EarlyAdopterToken
     */
    select?: EarlyAdopterTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EarlyAdopterToken
     */
    omit?: EarlyAdopterTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a EarlyAdopterToken.
     */
    data: XOR<EarlyAdopterTokenUpdateInput, EarlyAdopterTokenUncheckedUpdateInput>
    /**
     * Choose, which EarlyAdopterToken to update.
     */
    where: EarlyAdopterTokenWhereUniqueInput
  }

  /**
   * EarlyAdopterToken updateMany
   */
  export type EarlyAdopterTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EarlyAdopterTokens.
     */
    data: XOR<EarlyAdopterTokenUpdateManyMutationInput, EarlyAdopterTokenUncheckedUpdateManyInput>
    /**
     * Filter which EarlyAdopterTokens to update
     */
    where?: EarlyAdopterTokenWhereInput
    /**
     * Limit how many EarlyAdopterTokens to update.
     */
    limit?: number
  }

  /**
   * EarlyAdopterToken updateManyAndReturn
   */
  export type EarlyAdopterTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EarlyAdopterToken
     */
    select?: EarlyAdopterTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EarlyAdopterToken
     */
    omit?: EarlyAdopterTokenOmit<ExtArgs> | null
    /**
     * The data used to update EarlyAdopterTokens.
     */
    data: XOR<EarlyAdopterTokenUpdateManyMutationInput, EarlyAdopterTokenUncheckedUpdateManyInput>
    /**
     * Filter which EarlyAdopterTokens to update
     */
    where?: EarlyAdopterTokenWhereInput
    /**
     * Limit how many EarlyAdopterTokens to update.
     */
    limit?: number
  }

  /**
   * EarlyAdopterToken upsert
   */
  export type EarlyAdopterTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EarlyAdopterToken
     */
    select?: EarlyAdopterTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EarlyAdopterToken
     */
    omit?: EarlyAdopterTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the EarlyAdopterToken to update in case it exists.
     */
    where: EarlyAdopterTokenWhereUniqueInput
    /**
     * In case the EarlyAdopterToken found by the `where` argument doesn't exist, create a new EarlyAdopterToken with this data.
     */
    create: XOR<EarlyAdopterTokenCreateInput, EarlyAdopterTokenUncheckedCreateInput>
    /**
     * In case the EarlyAdopterToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EarlyAdopterTokenUpdateInput, EarlyAdopterTokenUncheckedUpdateInput>
  }

  /**
   * EarlyAdopterToken delete
   */
  export type EarlyAdopterTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EarlyAdopterToken
     */
    select?: EarlyAdopterTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EarlyAdopterToken
     */
    omit?: EarlyAdopterTokenOmit<ExtArgs> | null
    /**
     * Filter which EarlyAdopterToken to delete.
     */
    where: EarlyAdopterTokenWhereUniqueInput
  }

  /**
   * EarlyAdopterToken deleteMany
   */
  export type EarlyAdopterTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EarlyAdopterTokens to delete
     */
    where?: EarlyAdopterTokenWhereInput
    /**
     * Limit how many EarlyAdopterTokens to delete.
     */
    limit?: number
  }

  /**
   * EarlyAdopterToken without action
   */
  export type EarlyAdopterTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EarlyAdopterToken
     */
    select?: EarlyAdopterTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EarlyAdopterToken
     */
    omit?: EarlyAdopterTokenOmit<ExtArgs> | null
  }


  /**
   * Model CourtCase
   */

  export type AggregateCourtCase = {
    _count: CourtCaseCountAggregateOutputType | null
    _min: CourtCaseMinAggregateOutputType | null
    _max: CourtCaseMaxAggregateOutputType | null
  }

  export type CourtCaseMinAggregateOutputType = {
    id: string | null
    guid: string | null
    title: string | null
    neutralCitation: string | null
    court: $Enums.CourtType | null
    publishDate: Date | null
    caseUrl: string | null
    summary: string | null
    fullText: string | null
    riskLevel: $Enums.RiskLevel | null
    isProcessed: boolean | null
    nerProcessed: boolean | null
    classified: boolean | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourtCaseMaxAggregateOutputType = {
    id: string | null
    guid: string | null
    title: string | null
    neutralCitation: string | null
    court: $Enums.CourtType | null
    publishDate: Date | null
    caseUrl: string | null
    summary: string | null
    fullText: string | null
    riskLevel: $Enums.RiskLevel | null
    isProcessed: boolean | null
    nerProcessed: boolean | null
    classified: boolean | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourtCaseCountAggregateOutputType = {
    id: number
    guid: number
    title: number
    neutralCitation: number
    court: number
    publishDate: number
    caseUrl: number
    summary: number
    fullText: number
    addresses: number
    municipalities: number
    parties: number
    statutes: number
    caseTypes: number
    riskLevel: number
    isProcessed: number
    nerProcessed: number
    classified: number
    source: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourtCaseMinAggregateInputType = {
    id?: true
    guid?: true
    title?: true
    neutralCitation?: true
    court?: true
    publishDate?: true
    caseUrl?: true
    summary?: true
    fullText?: true
    riskLevel?: true
    isProcessed?: true
    nerProcessed?: true
    classified?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourtCaseMaxAggregateInputType = {
    id?: true
    guid?: true
    title?: true
    neutralCitation?: true
    court?: true
    publishDate?: true
    caseUrl?: true
    summary?: true
    fullText?: true
    riskLevel?: true
    isProcessed?: true
    nerProcessed?: true
    classified?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourtCaseCountAggregateInputType = {
    id?: true
    guid?: true
    title?: true
    neutralCitation?: true
    court?: true
    publishDate?: true
    caseUrl?: true
    summary?: true
    fullText?: true
    addresses?: true
    municipalities?: true
    parties?: true
    statutes?: true
    caseTypes?: true
    riskLevel?: true
    isProcessed?: true
    nerProcessed?: true
    classified?: true
    source?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourtCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourtCase to aggregate.
     */
    where?: CourtCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourtCases to fetch.
     */
    orderBy?: CourtCaseOrderByWithRelationInput | CourtCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourtCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourtCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourtCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourtCases
    **/
    _count?: true | CourtCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourtCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourtCaseMaxAggregateInputType
  }

  export type GetCourtCaseAggregateType<T extends CourtCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourtCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourtCase[P]>
      : GetScalarType<T[P], AggregateCourtCase[P]>
  }




  export type CourtCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtCaseWhereInput
    orderBy?: CourtCaseOrderByWithAggregationInput | CourtCaseOrderByWithAggregationInput[]
    by: CourtCaseScalarFieldEnum[] | CourtCaseScalarFieldEnum
    having?: CourtCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourtCaseCountAggregateInputType | true
    _min?: CourtCaseMinAggregateInputType
    _max?: CourtCaseMaxAggregateInputType
  }

  export type CourtCaseGroupByOutputType = {
    id: string
    guid: string
    title: string
    neutralCitation: string | null
    court: $Enums.CourtType
    publishDate: Date
    caseUrl: string
    summary: string | null
    fullText: string | null
    addresses: string[]
    municipalities: string[]
    parties: string[]
    statutes: string[]
    caseTypes: $Enums.RealEstateCaseType[]
    riskLevel: $Enums.RiskLevel
    isProcessed: boolean
    nerProcessed: boolean
    classified: boolean
    source: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: CourtCaseCountAggregateOutputType | null
    _min: CourtCaseMinAggregateOutputType | null
    _max: CourtCaseMaxAggregateOutputType | null
  }

  type GetCourtCaseGroupByPayload<T extends CourtCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourtCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourtCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourtCaseGroupByOutputType[P]>
            : GetScalarType<T[P], CourtCaseGroupByOutputType[P]>
        }
      >
    >


  export type CourtCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guid?: boolean
    title?: boolean
    neutralCitation?: boolean
    court?: boolean
    publishDate?: boolean
    caseUrl?: boolean
    summary?: boolean
    fullText?: boolean
    addresses?: boolean
    municipalities?: boolean
    parties?: boolean
    statutes?: boolean
    caseTypes?: boolean
    riskLevel?: boolean
    isProcessed?: boolean
    nerProcessed?: boolean
    classified?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alerts?: boolean | CourtCase$alertsArgs<ExtArgs>
    processingQueue?: boolean | CourtCase$processingQueueArgs<ExtArgs>
    _count?: boolean | CourtCaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courtCase"]>

  export type CourtCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guid?: boolean
    title?: boolean
    neutralCitation?: boolean
    court?: boolean
    publishDate?: boolean
    caseUrl?: boolean
    summary?: boolean
    fullText?: boolean
    addresses?: boolean
    municipalities?: boolean
    parties?: boolean
    statutes?: boolean
    caseTypes?: boolean
    riskLevel?: boolean
    isProcessed?: boolean
    nerProcessed?: boolean
    classified?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["courtCase"]>

  export type CourtCaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guid?: boolean
    title?: boolean
    neutralCitation?: boolean
    court?: boolean
    publishDate?: boolean
    caseUrl?: boolean
    summary?: boolean
    fullText?: boolean
    addresses?: boolean
    municipalities?: boolean
    parties?: boolean
    statutes?: boolean
    caseTypes?: boolean
    riskLevel?: boolean
    isProcessed?: boolean
    nerProcessed?: boolean
    classified?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["courtCase"]>

  export type CourtCaseSelectScalar = {
    id?: boolean
    guid?: boolean
    title?: boolean
    neutralCitation?: boolean
    court?: boolean
    publishDate?: boolean
    caseUrl?: boolean
    summary?: boolean
    fullText?: boolean
    addresses?: boolean
    municipalities?: boolean
    parties?: boolean
    statutes?: boolean
    caseTypes?: boolean
    riskLevel?: boolean
    isProcessed?: boolean
    nerProcessed?: boolean
    classified?: boolean
    source?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourtCaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "guid" | "title" | "neutralCitation" | "court" | "publishDate" | "caseUrl" | "summary" | "fullText" | "addresses" | "municipalities" | "parties" | "statutes" | "caseTypes" | "riskLevel" | "isProcessed" | "nerProcessed" | "classified" | "source" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["courtCase"]>
  export type CourtCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alerts?: boolean | CourtCase$alertsArgs<ExtArgs>
    processingQueue?: boolean | CourtCase$processingQueueArgs<ExtArgs>
    _count?: boolean | CourtCaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourtCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CourtCaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CourtCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourtCase"
    objects: {
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      processingQueue: Prisma.$CaseProcessingQueuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      guid: string
      title: string
      neutralCitation: string | null
      court: $Enums.CourtType
      publishDate: Date
      caseUrl: string
      summary: string | null
      fullText: string | null
      addresses: string[]
      municipalities: string[]
      parties: string[]
      statutes: string[]
      caseTypes: $Enums.RealEstateCaseType[]
      riskLevel: $Enums.RiskLevel
      isProcessed: boolean
      nerProcessed: boolean
      classified: boolean
      source: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["courtCase"]>
    composites: {}
  }

  type CourtCaseGetPayload<S extends boolean | null | undefined | CourtCaseDefaultArgs> = $Result.GetResult<Prisma.$CourtCasePayload, S>

  type CourtCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourtCaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourtCaseCountAggregateInputType | true
    }

  export interface CourtCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourtCase'], meta: { name: 'CourtCase' } }
    /**
     * Find zero or one CourtCase that matches the filter.
     * @param {CourtCaseFindUniqueArgs} args - Arguments to find a CourtCase
     * @example
     * // Get one CourtCase
     * const courtCase = await prisma.courtCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourtCaseFindUniqueArgs>(args: SelectSubset<T, CourtCaseFindUniqueArgs<ExtArgs>>): Prisma__CourtCaseClient<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourtCase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourtCaseFindUniqueOrThrowArgs} args - Arguments to find a CourtCase
     * @example
     * // Get one CourtCase
     * const courtCase = await prisma.courtCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourtCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourtCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourtCaseClient<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourtCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCaseFindFirstArgs} args - Arguments to find a CourtCase
     * @example
     * // Get one CourtCase
     * const courtCase = await prisma.courtCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourtCaseFindFirstArgs>(args?: SelectSubset<T, CourtCaseFindFirstArgs<ExtArgs>>): Prisma__CourtCaseClient<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourtCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCaseFindFirstOrThrowArgs} args - Arguments to find a CourtCase
     * @example
     * // Get one CourtCase
     * const courtCase = await prisma.courtCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourtCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourtCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourtCaseClient<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourtCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourtCases
     * const courtCases = await prisma.courtCase.findMany()
     * 
     * // Get first 10 CourtCases
     * const courtCases = await prisma.courtCase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courtCaseWithIdOnly = await prisma.courtCase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourtCaseFindManyArgs>(args?: SelectSubset<T, CourtCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourtCase.
     * @param {CourtCaseCreateArgs} args - Arguments to create a CourtCase.
     * @example
     * // Create one CourtCase
     * const CourtCase = await prisma.courtCase.create({
     *   data: {
     *     // ... data to create a CourtCase
     *   }
     * })
     * 
     */
    create<T extends CourtCaseCreateArgs>(args: SelectSubset<T, CourtCaseCreateArgs<ExtArgs>>): Prisma__CourtCaseClient<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourtCases.
     * @param {CourtCaseCreateManyArgs} args - Arguments to create many CourtCases.
     * @example
     * // Create many CourtCases
     * const courtCase = await prisma.courtCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourtCaseCreateManyArgs>(args?: SelectSubset<T, CourtCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourtCases and returns the data saved in the database.
     * @param {CourtCaseCreateManyAndReturnArgs} args - Arguments to create many CourtCases.
     * @example
     * // Create many CourtCases
     * const courtCase = await prisma.courtCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourtCases and only return the `id`
     * const courtCaseWithIdOnly = await prisma.courtCase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourtCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourtCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourtCase.
     * @param {CourtCaseDeleteArgs} args - Arguments to delete one CourtCase.
     * @example
     * // Delete one CourtCase
     * const CourtCase = await prisma.courtCase.delete({
     *   where: {
     *     // ... filter to delete one CourtCase
     *   }
     * })
     * 
     */
    delete<T extends CourtCaseDeleteArgs>(args: SelectSubset<T, CourtCaseDeleteArgs<ExtArgs>>): Prisma__CourtCaseClient<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourtCase.
     * @param {CourtCaseUpdateArgs} args - Arguments to update one CourtCase.
     * @example
     * // Update one CourtCase
     * const courtCase = await prisma.courtCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourtCaseUpdateArgs>(args: SelectSubset<T, CourtCaseUpdateArgs<ExtArgs>>): Prisma__CourtCaseClient<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourtCases.
     * @param {CourtCaseDeleteManyArgs} args - Arguments to filter CourtCases to delete.
     * @example
     * // Delete a few CourtCases
     * const { count } = await prisma.courtCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourtCaseDeleteManyArgs>(args?: SelectSubset<T, CourtCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourtCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourtCases
     * const courtCase = await prisma.courtCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourtCaseUpdateManyArgs>(args: SelectSubset<T, CourtCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourtCases and returns the data updated in the database.
     * @param {CourtCaseUpdateManyAndReturnArgs} args - Arguments to update many CourtCases.
     * @example
     * // Update many CourtCases
     * const courtCase = await prisma.courtCase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourtCases and only return the `id`
     * const courtCaseWithIdOnly = await prisma.courtCase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourtCaseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourtCaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourtCase.
     * @param {CourtCaseUpsertArgs} args - Arguments to update or create a CourtCase.
     * @example
     * // Update or create a CourtCase
     * const courtCase = await prisma.courtCase.upsert({
     *   create: {
     *     // ... data to create a CourtCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourtCase we want to update
     *   }
     * })
     */
    upsert<T extends CourtCaseUpsertArgs>(args: SelectSubset<T, CourtCaseUpsertArgs<ExtArgs>>): Prisma__CourtCaseClient<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourtCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCaseCountArgs} args - Arguments to filter CourtCases to count.
     * @example
     * // Count the number of CourtCases
     * const count = await prisma.courtCase.count({
     *   where: {
     *     // ... the filter for the CourtCases we want to count
     *   }
     * })
    **/
    count<T extends CourtCaseCountArgs>(
      args?: Subset<T, CourtCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourtCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourtCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourtCaseAggregateArgs>(args: Subset<T, CourtCaseAggregateArgs>): Prisma.PrismaPromise<GetCourtCaseAggregateType<T>>

    /**
     * Group by CourtCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourtCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourtCaseGroupByArgs['orderBy'] }
        : { orderBy?: CourtCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourtCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourtCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourtCase model
   */
  readonly fields: CourtCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourtCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourtCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alerts<T extends CourtCase$alertsArgs<ExtArgs> = {}>(args?: Subset<T, CourtCase$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    processingQueue<T extends CourtCase$processingQueueArgs<ExtArgs> = {}>(args?: Subset<T, CourtCase$processingQueueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseProcessingQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourtCase model
   */
  interface CourtCaseFieldRefs {
    readonly id: FieldRef<"CourtCase", 'String'>
    readonly guid: FieldRef<"CourtCase", 'String'>
    readonly title: FieldRef<"CourtCase", 'String'>
    readonly neutralCitation: FieldRef<"CourtCase", 'String'>
    readonly court: FieldRef<"CourtCase", 'CourtType'>
    readonly publishDate: FieldRef<"CourtCase", 'DateTime'>
    readonly caseUrl: FieldRef<"CourtCase", 'String'>
    readonly summary: FieldRef<"CourtCase", 'String'>
    readonly fullText: FieldRef<"CourtCase", 'String'>
    readonly addresses: FieldRef<"CourtCase", 'String[]'>
    readonly municipalities: FieldRef<"CourtCase", 'String[]'>
    readonly parties: FieldRef<"CourtCase", 'String[]'>
    readonly statutes: FieldRef<"CourtCase", 'String[]'>
    readonly caseTypes: FieldRef<"CourtCase", 'RealEstateCaseType[]'>
    readonly riskLevel: FieldRef<"CourtCase", 'RiskLevel'>
    readonly isProcessed: FieldRef<"CourtCase", 'Boolean'>
    readonly nerProcessed: FieldRef<"CourtCase", 'Boolean'>
    readonly classified: FieldRef<"CourtCase", 'Boolean'>
    readonly source: FieldRef<"CourtCase", 'String'>
    readonly metadata: FieldRef<"CourtCase", 'Json'>
    readonly createdAt: FieldRef<"CourtCase", 'DateTime'>
    readonly updatedAt: FieldRef<"CourtCase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourtCase findUnique
   */
  export type CourtCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCaseInclude<ExtArgs> | null
    /**
     * Filter, which CourtCase to fetch.
     */
    where: CourtCaseWhereUniqueInput
  }

  /**
   * CourtCase findUniqueOrThrow
   */
  export type CourtCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCaseInclude<ExtArgs> | null
    /**
     * Filter, which CourtCase to fetch.
     */
    where: CourtCaseWhereUniqueInput
  }

  /**
   * CourtCase findFirst
   */
  export type CourtCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCaseInclude<ExtArgs> | null
    /**
     * Filter, which CourtCase to fetch.
     */
    where?: CourtCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourtCases to fetch.
     */
    orderBy?: CourtCaseOrderByWithRelationInput | CourtCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourtCases.
     */
    cursor?: CourtCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourtCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourtCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourtCases.
     */
    distinct?: CourtCaseScalarFieldEnum | CourtCaseScalarFieldEnum[]
  }

  /**
   * CourtCase findFirstOrThrow
   */
  export type CourtCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCaseInclude<ExtArgs> | null
    /**
     * Filter, which CourtCase to fetch.
     */
    where?: CourtCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourtCases to fetch.
     */
    orderBy?: CourtCaseOrderByWithRelationInput | CourtCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourtCases.
     */
    cursor?: CourtCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourtCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourtCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourtCases.
     */
    distinct?: CourtCaseScalarFieldEnum | CourtCaseScalarFieldEnum[]
  }

  /**
   * CourtCase findMany
   */
  export type CourtCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCaseInclude<ExtArgs> | null
    /**
     * Filter, which CourtCases to fetch.
     */
    where?: CourtCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourtCases to fetch.
     */
    orderBy?: CourtCaseOrderByWithRelationInput | CourtCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourtCases.
     */
    cursor?: CourtCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourtCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourtCases.
     */
    skip?: number
    distinct?: CourtCaseScalarFieldEnum | CourtCaseScalarFieldEnum[]
  }

  /**
   * CourtCase create
   */
  export type CourtCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a CourtCase.
     */
    data: XOR<CourtCaseCreateInput, CourtCaseUncheckedCreateInput>
  }

  /**
   * CourtCase createMany
   */
  export type CourtCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourtCases.
     */
    data: CourtCaseCreateManyInput | CourtCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourtCase createManyAndReturn
   */
  export type CourtCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * The data used to create many CourtCases.
     */
    data: CourtCaseCreateManyInput | CourtCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourtCase update
   */
  export type CourtCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a CourtCase.
     */
    data: XOR<CourtCaseUpdateInput, CourtCaseUncheckedUpdateInput>
    /**
     * Choose, which CourtCase to update.
     */
    where: CourtCaseWhereUniqueInput
  }

  /**
   * CourtCase updateMany
   */
  export type CourtCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourtCases.
     */
    data: XOR<CourtCaseUpdateManyMutationInput, CourtCaseUncheckedUpdateManyInput>
    /**
     * Filter which CourtCases to update
     */
    where?: CourtCaseWhereInput
    /**
     * Limit how many CourtCases to update.
     */
    limit?: number
  }

  /**
   * CourtCase updateManyAndReturn
   */
  export type CourtCaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * The data used to update CourtCases.
     */
    data: XOR<CourtCaseUpdateManyMutationInput, CourtCaseUncheckedUpdateManyInput>
    /**
     * Filter which CourtCases to update
     */
    where?: CourtCaseWhereInput
    /**
     * Limit how many CourtCases to update.
     */
    limit?: number
  }

  /**
   * CourtCase upsert
   */
  export type CourtCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the CourtCase to update in case it exists.
     */
    where: CourtCaseWhereUniqueInput
    /**
     * In case the CourtCase found by the `where` argument doesn't exist, create a new CourtCase with this data.
     */
    create: XOR<CourtCaseCreateInput, CourtCaseUncheckedCreateInput>
    /**
     * In case the CourtCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourtCaseUpdateInput, CourtCaseUncheckedUpdateInput>
  }

  /**
   * CourtCase delete
   */
  export type CourtCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCaseInclude<ExtArgs> | null
    /**
     * Filter which CourtCase to delete.
     */
    where: CourtCaseWhereUniqueInput
  }

  /**
   * CourtCase deleteMany
   */
  export type CourtCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourtCases to delete
     */
    where?: CourtCaseWhereInput
    /**
     * Limit how many CourtCases to delete.
     */
    limit?: number
  }

  /**
   * CourtCase.alerts
   */
  export type CourtCase$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * CourtCase.processingQueue
   */
  export type CourtCase$processingQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueInclude<ExtArgs> | null
    where?: CaseProcessingQueueWhereInput
    orderBy?: CaseProcessingQueueOrderByWithRelationInput | CaseProcessingQueueOrderByWithRelationInput[]
    cursor?: CaseProcessingQueueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseProcessingQueueScalarFieldEnum | CaseProcessingQueueScalarFieldEnum[]
  }

  /**
   * CourtCase without action
   */
  export type CourtCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCase
     */
    select?: CourtCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtCase
     */
    omit?: CourtCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtCaseInclude<ExtArgs> | null
  }


  /**
   * Model CaseProcessingQueue
   */

  export type AggregateCaseProcessingQueue = {
    _count: CaseProcessingQueueCountAggregateOutputType | null
    _avg: CaseProcessingQueueAvgAggregateOutputType | null
    _sum: CaseProcessingQueueSumAggregateOutputType | null
    _min: CaseProcessingQueueMinAggregateOutputType | null
    _max: CaseProcessingQueueMaxAggregateOutputType | null
  }

  export type CaseProcessingQueueAvgAggregateOutputType = {
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type CaseProcessingQueueSumAggregateOutputType = {
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
  }

  export type CaseProcessingQueueMinAggregateOutputType = {
    id: string | null
    caseId: string | null
    processType: $Enums.ProcessingType | null
    status: $Enums.ProcessingStatus | null
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
    error: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type CaseProcessingQueueMaxAggregateOutputType = {
    id: string | null
    caseId: string | null
    processType: $Enums.ProcessingType | null
    status: $Enums.ProcessingStatus | null
    priority: number | null
    attempts: number | null
    maxAttempts: number | null
    error: string | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type CaseProcessingQueueCountAggregateOutputType = {
    id: number
    caseId: number
    processType: number
    status: number
    priority: number
    attempts: number
    maxAttempts: number
    error: number
    scheduledAt: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type CaseProcessingQueueAvgAggregateInputType = {
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type CaseProcessingQueueSumAggregateInputType = {
    priority?: true
    attempts?: true
    maxAttempts?: true
  }

  export type CaseProcessingQueueMinAggregateInputType = {
    id?: true
    caseId?: true
    processType?: true
    status?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    error?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type CaseProcessingQueueMaxAggregateInputType = {
    id?: true
    caseId?: true
    processType?: true
    status?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    error?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
  }

  export type CaseProcessingQueueCountAggregateInputType = {
    id?: true
    caseId?: true
    processType?: true
    status?: true
    priority?: true
    attempts?: true
    maxAttempts?: true
    error?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type CaseProcessingQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseProcessingQueue to aggregate.
     */
    where?: CaseProcessingQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseProcessingQueues to fetch.
     */
    orderBy?: CaseProcessingQueueOrderByWithRelationInput | CaseProcessingQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaseProcessingQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseProcessingQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseProcessingQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CaseProcessingQueues
    **/
    _count?: true | CaseProcessingQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CaseProcessingQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CaseProcessingQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaseProcessingQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaseProcessingQueueMaxAggregateInputType
  }

  export type GetCaseProcessingQueueAggregateType<T extends CaseProcessingQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseProcessingQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseProcessingQueue[P]>
      : GetScalarType<T[P], AggregateCaseProcessingQueue[P]>
  }




  export type CaseProcessingQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseProcessingQueueWhereInput
    orderBy?: CaseProcessingQueueOrderByWithAggregationInput | CaseProcessingQueueOrderByWithAggregationInput[]
    by: CaseProcessingQueueScalarFieldEnum[] | CaseProcessingQueueScalarFieldEnum
    having?: CaseProcessingQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseProcessingQueueCountAggregateInputType | true
    _avg?: CaseProcessingQueueAvgAggregateInputType
    _sum?: CaseProcessingQueueSumAggregateInputType
    _min?: CaseProcessingQueueMinAggregateInputType
    _max?: CaseProcessingQueueMaxAggregateInputType
  }

  export type CaseProcessingQueueGroupByOutputType = {
    id: string
    caseId: string
    processType: $Enums.ProcessingType
    status: $Enums.ProcessingStatus
    priority: number
    attempts: number
    maxAttempts: number
    error: string | null
    scheduledAt: Date
    startedAt: Date | null
    completedAt: Date | null
    _count: CaseProcessingQueueCountAggregateOutputType | null
    _avg: CaseProcessingQueueAvgAggregateOutputType | null
    _sum: CaseProcessingQueueSumAggregateOutputType | null
    _min: CaseProcessingQueueMinAggregateOutputType | null
    _max: CaseProcessingQueueMaxAggregateOutputType | null
  }

  type GetCaseProcessingQueueGroupByPayload<T extends CaseProcessingQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseProcessingQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseProcessingQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseProcessingQueueGroupByOutputType[P]>
            : GetScalarType<T[P], CaseProcessingQueueGroupByOutputType[P]>
        }
      >
    >


  export type CaseProcessingQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    processType?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    error?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    case?: boolean | CourtCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseProcessingQueue"]>

  export type CaseProcessingQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    processType?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    error?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    case?: boolean | CourtCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseProcessingQueue"]>

  export type CaseProcessingQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    processType?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    error?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    case?: boolean | CourtCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseProcessingQueue"]>

  export type CaseProcessingQueueSelectScalar = {
    id?: boolean
    caseId?: boolean
    processType?: boolean
    status?: boolean
    priority?: boolean
    attempts?: boolean
    maxAttempts?: boolean
    error?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type CaseProcessingQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseId" | "processType" | "status" | "priority" | "attempts" | "maxAttempts" | "error" | "scheduledAt" | "startedAt" | "completedAt", ExtArgs["result"]["caseProcessingQueue"]>
  export type CaseProcessingQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | CourtCaseDefaultArgs<ExtArgs>
  }
  export type CaseProcessingQueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | CourtCaseDefaultArgs<ExtArgs>
  }
  export type CaseProcessingQueueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | CourtCaseDefaultArgs<ExtArgs>
  }

  export type $CaseProcessingQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseProcessingQueue"
    objects: {
      case: Prisma.$CourtCasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseId: string
      processType: $Enums.ProcessingType
      status: $Enums.ProcessingStatus
      priority: number
      attempts: number
      maxAttempts: number
      error: string | null
      scheduledAt: Date
      startedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["caseProcessingQueue"]>
    composites: {}
  }

  type CaseProcessingQueueGetPayload<S extends boolean | null | undefined | CaseProcessingQueueDefaultArgs> = $Result.GetResult<Prisma.$CaseProcessingQueuePayload, S>

  type CaseProcessingQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseProcessingQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseProcessingQueueCountAggregateInputType | true
    }

  export interface CaseProcessingQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseProcessingQueue'], meta: { name: 'CaseProcessingQueue' } }
    /**
     * Find zero or one CaseProcessingQueue that matches the filter.
     * @param {CaseProcessingQueueFindUniqueArgs} args - Arguments to find a CaseProcessingQueue
     * @example
     * // Get one CaseProcessingQueue
     * const caseProcessingQueue = await prisma.caseProcessingQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseProcessingQueueFindUniqueArgs>(args: SelectSubset<T, CaseProcessingQueueFindUniqueArgs<ExtArgs>>): Prisma__CaseProcessingQueueClient<$Result.GetResult<Prisma.$CaseProcessingQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseProcessingQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseProcessingQueueFindUniqueOrThrowArgs} args - Arguments to find a CaseProcessingQueue
     * @example
     * // Get one CaseProcessingQueue
     * const caseProcessingQueue = await prisma.caseProcessingQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseProcessingQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseProcessingQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseProcessingQueueClient<$Result.GetResult<Prisma.$CaseProcessingQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseProcessingQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseProcessingQueueFindFirstArgs} args - Arguments to find a CaseProcessingQueue
     * @example
     * // Get one CaseProcessingQueue
     * const caseProcessingQueue = await prisma.caseProcessingQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseProcessingQueueFindFirstArgs>(args?: SelectSubset<T, CaseProcessingQueueFindFirstArgs<ExtArgs>>): Prisma__CaseProcessingQueueClient<$Result.GetResult<Prisma.$CaseProcessingQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseProcessingQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseProcessingQueueFindFirstOrThrowArgs} args - Arguments to find a CaseProcessingQueue
     * @example
     * // Get one CaseProcessingQueue
     * const caseProcessingQueue = await prisma.caseProcessingQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseProcessingQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseProcessingQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseProcessingQueueClient<$Result.GetResult<Prisma.$CaseProcessingQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseProcessingQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseProcessingQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseProcessingQueues
     * const caseProcessingQueues = await prisma.caseProcessingQueue.findMany()
     * 
     * // Get first 10 CaseProcessingQueues
     * const caseProcessingQueues = await prisma.caseProcessingQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caseProcessingQueueWithIdOnly = await prisma.caseProcessingQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaseProcessingQueueFindManyArgs>(args?: SelectSubset<T, CaseProcessingQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseProcessingQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseProcessingQueue.
     * @param {CaseProcessingQueueCreateArgs} args - Arguments to create a CaseProcessingQueue.
     * @example
     * // Create one CaseProcessingQueue
     * const CaseProcessingQueue = await prisma.caseProcessingQueue.create({
     *   data: {
     *     // ... data to create a CaseProcessingQueue
     *   }
     * })
     * 
     */
    create<T extends CaseProcessingQueueCreateArgs>(args: SelectSubset<T, CaseProcessingQueueCreateArgs<ExtArgs>>): Prisma__CaseProcessingQueueClient<$Result.GetResult<Prisma.$CaseProcessingQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseProcessingQueues.
     * @param {CaseProcessingQueueCreateManyArgs} args - Arguments to create many CaseProcessingQueues.
     * @example
     * // Create many CaseProcessingQueues
     * const caseProcessingQueue = await prisma.caseProcessingQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaseProcessingQueueCreateManyArgs>(args?: SelectSubset<T, CaseProcessingQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseProcessingQueues and returns the data saved in the database.
     * @param {CaseProcessingQueueCreateManyAndReturnArgs} args - Arguments to create many CaseProcessingQueues.
     * @example
     * // Create many CaseProcessingQueues
     * const caseProcessingQueue = await prisma.caseProcessingQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CaseProcessingQueues and only return the `id`
     * const caseProcessingQueueWithIdOnly = await prisma.caseProcessingQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaseProcessingQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseProcessingQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseProcessingQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseProcessingQueue.
     * @param {CaseProcessingQueueDeleteArgs} args - Arguments to delete one CaseProcessingQueue.
     * @example
     * // Delete one CaseProcessingQueue
     * const CaseProcessingQueue = await prisma.caseProcessingQueue.delete({
     *   where: {
     *     // ... filter to delete one CaseProcessingQueue
     *   }
     * })
     * 
     */
    delete<T extends CaseProcessingQueueDeleteArgs>(args: SelectSubset<T, CaseProcessingQueueDeleteArgs<ExtArgs>>): Prisma__CaseProcessingQueueClient<$Result.GetResult<Prisma.$CaseProcessingQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseProcessingQueue.
     * @param {CaseProcessingQueueUpdateArgs} args - Arguments to update one CaseProcessingQueue.
     * @example
     * // Update one CaseProcessingQueue
     * const caseProcessingQueue = await prisma.caseProcessingQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaseProcessingQueueUpdateArgs>(args: SelectSubset<T, CaseProcessingQueueUpdateArgs<ExtArgs>>): Prisma__CaseProcessingQueueClient<$Result.GetResult<Prisma.$CaseProcessingQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseProcessingQueues.
     * @param {CaseProcessingQueueDeleteManyArgs} args - Arguments to filter CaseProcessingQueues to delete.
     * @example
     * // Delete a few CaseProcessingQueues
     * const { count } = await prisma.caseProcessingQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaseProcessingQueueDeleteManyArgs>(args?: SelectSubset<T, CaseProcessingQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseProcessingQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseProcessingQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseProcessingQueues
     * const caseProcessingQueue = await prisma.caseProcessingQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaseProcessingQueueUpdateManyArgs>(args: SelectSubset<T, CaseProcessingQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseProcessingQueues and returns the data updated in the database.
     * @param {CaseProcessingQueueUpdateManyAndReturnArgs} args - Arguments to update many CaseProcessingQueues.
     * @example
     * // Update many CaseProcessingQueues
     * const caseProcessingQueue = await prisma.caseProcessingQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CaseProcessingQueues and only return the `id`
     * const caseProcessingQueueWithIdOnly = await prisma.caseProcessingQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CaseProcessingQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, CaseProcessingQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseProcessingQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CaseProcessingQueue.
     * @param {CaseProcessingQueueUpsertArgs} args - Arguments to update or create a CaseProcessingQueue.
     * @example
     * // Update or create a CaseProcessingQueue
     * const caseProcessingQueue = await prisma.caseProcessingQueue.upsert({
     *   create: {
     *     // ... data to create a CaseProcessingQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseProcessingQueue we want to update
     *   }
     * })
     */
    upsert<T extends CaseProcessingQueueUpsertArgs>(args: SelectSubset<T, CaseProcessingQueueUpsertArgs<ExtArgs>>): Prisma__CaseProcessingQueueClient<$Result.GetResult<Prisma.$CaseProcessingQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseProcessingQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseProcessingQueueCountArgs} args - Arguments to filter CaseProcessingQueues to count.
     * @example
     * // Count the number of CaseProcessingQueues
     * const count = await prisma.caseProcessingQueue.count({
     *   where: {
     *     // ... the filter for the CaseProcessingQueues we want to count
     *   }
     * })
    **/
    count<T extends CaseProcessingQueueCountArgs>(
      args?: Subset<T, CaseProcessingQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseProcessingQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseProcessingQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseProcessingQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseProcessingQueueAggregateArgs>(args: Subset<T, CaseProcessingQueueAggregateArgs>): Prisma.PrismaPromise<GetCaseProcessingQueueAggregateType<T>>

    /**
     * Group by CaseProcessingQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseProcessingQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaseProcessingQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseProcessingQueueGroupByArgs['orderBy'] }
        : { orderBy?: CaseProcessingQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseProcessingQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseProcessingQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseProcessingQueue model
   */
  readonly fields: CaseProcessingQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseProcessingQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseProcessingQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    case<T extends CourtCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourtCaseDefaultArgs<ExtArgs>>): Prisma__CourtCaseClient<$Result.GetResult<Prisma.$CourtCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseProcessingQueue model
   */
  interface CaseProcessingQueueFieldRefs {
    readonly id: FieldRef<"CaseProcessingQueue", 'String'>
    readonly caseId: FieldRef<"CaseProcessingQueue", 'String'>
    readonly processType: FieldRef<"CaseProcessingQueue", 'ProcessingType'>
    readonly status: FieldRef<"CaseProcessingQueue", 'ProcessingStatus'>
    readonly priority: FieldRef<"CaseProcessingQueue", 'Int'>
    readonly attempts: FieldRef<"CaseProcessingQueue", 'Int'>
    readonly maxAttempts: FieldRef<"CaseProcessingQueue", 'Int'>
    readonly error: FieldRef<"CaseProcessingQueue", 'String'>
    readonly scheduledAt: FieldRef<"CaseProcessingQueue", 'DateTime'>
    readonly startedAt: FieldRef<"CaseProcessingQueue", 'DateTime'>
    readonly completedAt: FieldRef<"CaseProcessingQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CaseProcessingQueue findUnique
   */
  export type CaseProcessingQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueInclude<ExtArgs> | null
    /**
     * Filter, which CaseProcessingQueue to fetch.
     */
    where: CaseProcessingQueueWhereUniqueInput
  }

  /**
   * CaseProcessingQueue findUniqueOrThrow
   */
  export type CaseProcessingQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueInclude<ExtArgs> | null
    /**
     * Filter, which CaseProcessingQueue to fetch.
     */
    where: CaseProcessingQueueWhereUniqueInput
  }

  /**
   * CaseProcessingQueue findFirst
   */
  export type CaseProcessingQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueInclude<ExtArgs> | null
    /**
     * Filter, which CaseProcessingQueue to fetch.
     */
    where?: CaseProcessingQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseProcessingQueues to fetch.
     */
    orderBy?: CaseProcessingQueueOrderByWithRelationInput | CaseProcessingQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaseProcessingQueues.
     */
    cursor?: CaseProcessingQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseProcessingQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseProcessingQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaseProcessingQueues.
     */
    distinct?: CaseProcessingQueueScalarFieldEnum | CaseProcessingQueueScalarFieldEnum[]
  }

  /**
   * CaseProcessingQueue findFirstOrThrow
   */
  export type CaseProcessingQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueInclude<ExtArgs> | null
    /**
     * Filter, which CaseProcessingQueue to fetch.
     */
    where?: CaseProcessingQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseProcessingQueues to fetch.
     */
    orderBy?: CaseProcessingQueueOrderByWithRelationInput | CaseProcessingQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CaseProcessingQueues.
     */
    cursor?: CaseProcessingQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseProcessingQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseProcessingQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CaseProcessingQueues.
     */
    distinct?: CaseProcessingQueueScalarFieldEnum | CaseProcessingQueueScalarFieldEnum[]
  }

  /**
   * CaseProcessingQueue findMany
   */
  export type CaseProcessingQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueInclude<ExtArgs> | null
    /**
     * Filter, which CaseProcessingQueues to fetch.
     */
    where?: CaseProcessingQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CaseProcessingQueues to fetch.
     */
    orderBy?: CaseProcessingQueueOrderByWithRelationInput | CaseProcessingQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CaseProcessingQueues.
     */
    cursor?: CaseProcessingQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CaseProcessingQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CaseProcessingQueues.
     */
    skip?: number
    distinct?: CaseProcessingQueueScalarFieldEnum | CaseProcessingQueueScalarFieldEnum[]
  }

  /**
   * CaseProcessingQueue create
   */
  export type CaseProcessingQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a CaseProcessingQueue.
     */
    data: XOR<CaseProcessingQueueCreateInput, CaseProcessingQueueUncheckedCreateInput>
  }

  /**
   * CaseProcessingQueue createMany
   */
  export type CaseProcessingQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseProcessingQueues.
     */
    data: CaseProcessingQueueCreateManyInput | CaseProcessingQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseProcessingQueue createManyAndReturn
   */
  export type CaseProcessingQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * The data used to create many CaseProcessingQueues.
     */
    data: CaseProcessingQueueCreateManyInput | CaseProcessingQueueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseProcessingQueue update
   */
  export type CaseProcessingQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a CaseProcessingQueue.
     */
    data: XOR<CaseProcessingQueueUpdateInput, CaseProcessingQueueUncheckedUpdateInput>
    /**
     * Choose, which CaseProcessingQueue to update.
     */
    where: CaseProcessingQueueWhereUniqueInput
  }

  /**
   * CaseProcessingQueue updateMany
   */
  export type CaseProcessingQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseProcessingQueues.
     */
    data: XOR<CaseProcessingQueueUpdateManyMutationInput, CaseProcessingQueueUncheckedUpdateManyInput>
    /**
     * Filter which CaseProcessingQueues to update
     */
    where?: CaseProcessingQueueWhereInput
    /**
     * Limit how many CaseProcessingQueues to update.
     */
    limit?: number
  }

  /**
   * CaseProcessingQueue updateManyAndReturn
   */
  export type CaseProcessingQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * The data used to update CaseProcessingQueues.
     */
    data: XOR<CaseProcessingQueueUpdateManyMutationInput, CaseProcessingQueueUncheckedUpdateManyInput>
    /**
     * Filter which CaseProcessingQueues to update
     */
    where?: CaseProcessingQueueWhereInput
    /**
     * Limit how many CaseProcessingQueues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseProcessingQueue upsert
   */
  export type CaseProcessingQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the CaseProcessingQueue to update in case it exists.
     */
    where: CaseProcessingQueueWhereUniqueInput
    /**
     * In case the CaseProcessingQueue found by the `where` argument doesn't exist, create a new CaseProcessingQueue with this data.
     */
    create: XOR<CaseProcessingQueueCreateInput, CaseProcessingQueueUncheckedCreateInput>
    /**
     * In case the CaseProcessingQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseProcessingQueueUpdateInput, CaseProcessingQueueUncheckedUpdateInput>
  }

  /**
   * CaseProcessingQueue delete
   */
  export type CaseProcessingQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueInclude<ExtArgs> | null
    /**
     * Filter which CaseProcessingQueue to delete.
     */
    where: CaseProcessingQueueWhereUniqueInput
  }

  /**
   * CaseProcessingQueue deleteMany
   */
  export type CaseProcessingQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseProcessingQueues to delete
     */
    where?: CaseProcessingQueueWhereInput
    /**
     * Limit how many CaseProcessingQueues to delete.
     */
    limit?: number
  }

  /**
   * CaseProcessingQueue without action
   */
  export type CaseProcessingQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseProcessingQueue
     */
    select?: CaseProcessingQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseProcessingQueue
     */
    omit?: CaseProcessingQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseProcessingQueueInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    status: $Enums.SupportTicketStatus | null
    priority: $Enums.SupportTicketPriority | null
    category: string | null
    assignedToId: string | null
    resolution: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    status: $Enums.SupportTicketStatus | null
    priority: $Enums.SupportTicketPriority | null
    category: string | null
    assignedToId: string | null
    resolution: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    status: number
    priority: number
    category: number
    assignedToId: number
    resolution: number
    resolvedAt: number
    resolvedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupportTicketMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    category?: true
    assignedToId?: true
    resolution?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    category?: true
    assignedToId?: true
    resolution?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    category?: true
    assignedToId?: true
    resolution?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string
    status: $Enums.SupportTicketStatus
    priority: $Enums.SupportTicketPriority
    category: string | null
    assignedToId: string | null
    resolution: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    category?: boolean
    assignedToId?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | SupportTicket$messagesArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    category?: boolean
    assignedToId?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    category?: boolean
    assignedToId?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    category?: boolean
    assignedToId?: boolean
    resolution?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupportTicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "description" | "status" | "priority" | "category" | "assignedToId" | "resolution" | "resolvedAt" | "resolvedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["supportTicket"]>
  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | SupportTicket$messagesArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupportTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupportTicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$SupportTicketMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string
      status: $Enums.SupportTicketStatus
      priority: $Enums.SupportTicketPriority
      category: string | null
      assignedToId: string | null
      resolution: string | null
      resolvedAt: Date | null
      resolvedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTickets and returns the data saved in the database.
     * @param {SupportTicketCreateManyAndReturnArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets and returns the data updated in the database.
     * @param {SupportTicketUpdateManyAndReturnArgs} args - Arguments to update many SupportTickets.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportTicketUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportTicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends SupportTicket$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends SupportTicket$messagesArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'String'>
    readonly userId: FieldRef<"SupportTicket", 'String'>
    readonly title: FieldRef<"SupportTicket", 'String'>
    readonly description: FieldRef<"SupportTicket", 'String'>
    readonly status: FieldRef<"SupportTicket", 'SupportTicketStatus'>
    readonly priority: FieldRef<"SupportTicket", 'SupportTicketPriority'>
    readonly category: FieldRef<"SupportTicket", 'String'>
    readonly assignedToId: FieldRef<"SupportTicket", 'String'>
    readonly resolution: FieldRef<"SupportTicket", 'String'>
    readonly resolvedAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly resolvedBy: FieldRef<"SupportTicket", 'String'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket createManyAndReturn
   */
  export type SupportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
  }

  /**
   * SupportTicket updateManyAndReturn
   */
  export type SupportTicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
    /**
     * Limit how many SupportTickets to delete.
     */
    limit?: number
  }

  /**
   * SupportTicket.assignedTo
   */
  export type SupportTicket$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SupportTicket.messages
   */
  export type SupportTicket$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageInclude<ExtArgs> | null
    where?: SupportTicketMessageWhereInput
    orderBy?: SupportTicketMessageOrderByWithRelationInput | SupportTicketMessageOrderByWithRelationInput[]
    cursor?: SupportTicketMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketMessageScalarFieldEnum | SupportTicketMessageScalarFieldEnum[]
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicket
     */
    omit?: SupportTicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model SupportTicketMessage
   */

  export type AggregateSupportTicketMessage = {
    _count: SupportTicketMessageCountAggregateOutputType | null
    _min: SupportTicketMessageMinAggregateOutputType | null
    _max: SupportTicketMessageMaxAggregateOutputType | null
  }

  export type SupportTicketMessageMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    userId: string | null
    message: string | null
    isFromAdmin: boolean | null
    createdAt: Date | null
  }

  export type SupportTicketMessageMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    userId: string | null
    message: string | null
    isFromAdmin: boolean | null
    createdAt: Date | null
  }

  export type SupportTicketMessageCountAggregateOutputType = {
    id: number
    ticketId: number
    userId: number
    message: number
    isFromAdmin: number
    attachments: number
    createdAt: number
    _all: number
  }


  export type SupportTicketMessageMinAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    message?: true
    isFromAdmin?: true
    createdAt?: true
  }

  export type SupportTicketMessageMaxAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    message?: true
    isFromAdmin?: true
    createdAt?: true
  }

  export type SupportTicketMessageCountAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    message?: true
    isFromAdmin?: true
    attachments?: true
    createdAt?: true
    _all?: true
  }

  export type SupportTicketMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicketMessage to aggregate.
     */
    where?: SupportTicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTicketMessages to fetch.
     */
    orderBy?: SupportTicketMessageOrderByWithRelationInput | SupportTicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTicketMessages
    **/
    _count?: true | SupportTicketMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMessageMaxAggregateInputType
  }

  export type GetSupportTicketMessageAggregateType<T extends SupportTicketMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicketMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicketMessage[P]>
      : GetScalarType<T[P], AggregateSupportTicketMessage[P]>
  }




  export type SupportTicketMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketMessageWhereInput
    orderBy?: SupportTicketMessageOrderByWithAggregationInput | SupportTicketMessageOrderByWithAggregationInput[]
    by: SupportTicketMessageScalarFieldEnum[] | SupportTicketMessageScalarFieldEnum
    having?: SupportTicketMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketMessageCountAggregateInputType | true
    _min?: SupportTicketMessageMinAggregateInputType
    _max?: SupportTicketMessageMaxAggregateInputType
  }

  export type SupportTicketMessageGroupByOutputType = {
    id: string
    ticketId: string
    userId: string
    message: string
    isFromAdmin: boolean
    attachments: string[]
    createdAt: Date
    _count: SupportTicketMessageCountAggregateOutputType | null
    _min: SupportTicketMessageMinAggregateOutputType | null
    _max: SupportTicketMessageMaxAggregateOutputType | null
  }

  type GetSupportTicketMessageGroupByPayload<T extends SupportTicketMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketMessageGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketMessageGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    message?: boolean
    isFromAdmin?: boolean
    attachments?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicketMessage"]>

  export type SupportTicketMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    message?: boolean
    isFromAdmin?: boolean
    attachments?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicketMessage"]>

  export type SupportTicketMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    message?: boolean
    isFromAdmin?: boolean
    attachments?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicketMessage"]>

  export type SupportTicketMessageSelectScalar = {
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    message?: boolean
    isFromAdmin?: boolean
    attachments?: boolean
    createdAt?: boolean
  }

  export type SupportTicketMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketId" | "userId" | "message" | "isFromAdmin" | "attachments" | "createdAt", ExtArgs["result"]["supportTicketMessage"]>
  export type SupportTicketMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupportTicketMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupportTicketMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SupportTicketMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicketMessage"
    objects: {
      ticket: Prisma.$SupportTicketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      userId: string
      message: string
      isFromAdmin: boolean
      attachments: string[]
      createdAt: Date
    }, ExtArgs["result"]["supportTicketMessage"]>
    composites: {}
  }

  type SupportTicketMessageGetPayload<S extends boolean | null | undefined | SupportTicketMessageDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketMessagePayload, S>

  type SupportTicketMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportTicketMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportTicketMessageCountAggregateInputType | true
    }

  export interface SupportTicketMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicketMessage'], meta: { name: 'SupportTicketMessage' } }
    /**
     * Find zero or one SupportTicketMessage that matches the filter.
     * @param {SupportTicketMessageFindUniqueArgs} args - Arguments to find a SupportTicketMessage
     * @example
     * // Get one SupportTicketMessage
     * const supportTicketMessage = await prisma.supportTicketMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketMessageFindUniqueArgs>(args: SelectSubset<T, SupportTicketMessageFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketMessageClient<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportTicketMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportTicketMessageFindUniqueOrThrowArgs} args - Arguments to find a SupportTicketMessage
     * @example
     * // Get one SupportTicketMessage
     * const supportTicketMessage = await prisma.supportTicketMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketMessageClient<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicketMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketMessageFindFirstArgs} args - Arguments to find a SupportTicketMessage
     * @example
     * // Get one SupportTicketMessage
     * const supportTicketMessage = await prisma.supportTicketMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketMessageFindFirstArgs>(args?: SelectSubset<T, SupportTicketMessageFindFirstArgs<ExtArgs>>): Prisma__SupportTicketMessageClient<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportTicketMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketMessageFindFirstOrThrowArgs} args - Arguments to find a SupportTicketMessage
     * @example
     * // Get one SupportTicketMessage
     * const supportTicketMessage = await prisma.supportTicketMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketMessageClient<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportTicketMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTicketMessages
     * const supportTicketMessages = await prisma.supportTicketMessage.findMany()
     * 
     * // Get first 10 SupportTicketMessages
     * const supportTicketMessages = await prisma.supportTicketMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketMessageWithIdOnly = await prisma.supportTicketMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketMessageFindManyArgs>(args?: SelectSubset<T, SupportTicketMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportTicketMessage.
     * @param {SupportTicketMessageCreateArgs} args - Arguments to create a SupportTicketMessage.
     * @example
     * // Create one SupportTicketMessage
     * const SupportTicketMessage = await prisma.supportTicketMessage.create({
     *   data: {
     *     // ... data to create a SupportTicketMessage
     *   }
     * })
     * 
     */
    create<T extends SupportTicketMessageCreateArgs>(args: SelectSubset<T, SupportTicketMessageCreateArgs<ExtArgs>>): Prisma__SupportTicketMessageClient<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportTicketMessages.
     * @param {SupportTicketMessageCreateManyArgs} args - Arguments to create many SupportTicketMessages.
     * @example
     * // Create many SupportTicketMessages
     * const supportTicketMessage = await prisma.supportTicketMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketMessageCreateManyArgs>(args?: SelectSubset<T, SupportTicketMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTicketMessages and returns the data saved in the database.
     * @param {SupportTicketMessageCreateManyAndReturnArgs} args - Arguments to create many SupportTicketMessages.
     * @example
     * // Create many SupportTicketMessages
     * const supportTicketMessage = await prisma.supportTicketMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTicketMessages and only return the `id`
     * const supportTicketMessageWithIdOnly = await prisma.supportTicketMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupportTicketMessage.
     * @param {SupportTicketMessageDeleteArgs} args - Arguments to delete one SupportTicketMessage.
     * @example
     * // Delete one SupportTicketMessage
     * const SupportTicketMessage = await prisma.supportTicketMessage.delete({
     *   where: {
     *     // ... filter to delete one SupportTicketMessage
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketMessageDeleteArgs>(args: SelectSubset<T, SupportTicketMessageDeleteArgs<ExtArgs>>): Prisma__SupportTicketMessageClient<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportTicketMessage.
     * @param {SupportTicketMessageUpdateArgs} args - Arguments to update one SupportTicketMessage.
     * @example
     * // Update one SupportTicketMessage
     * const supportTicketMessage = await prisma.supportTicketMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketMessageUpdateArgs>(args: SelectSubset<T, SupportTicketMessageUpdateArgs<ExtArgs>>): Prisma__SupportTicketMessageClient<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportTicketMessages.
     * @param {SupportTicketMessageDeleteManyArgs} args - Arguments to filter SupportTicketMessages to delete.
     * @example
     * // Delete a few SupportTicketMessages
     * const { count } = await prisma.supportTicketMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketMessageDeleteManyArgs>(args?: SelectSubset<T, SupportTicketMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTicketMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTicketMessages
     * const supportTicketMessage = await prisma.supportTicketMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketMessageUpdateManyArgs>(args: SelectSubset<T, SupportTicketMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTicketMessages and returns the data updated in the database.
     * @param {SupportTicketMessageUpdateManyAndReturnArgs} args - Arguments to update many SupportTicketMessages.
     * @example
     * // Update many SupportTicketMessages
     * const supportTicketMessage = await prisma.supportTicketMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportTicketMessages and only return the `id`
     * const supportTicketMessageWithIdOnly = await prisma.supportTicketMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportTicketMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportTicketMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupportTicketMessage.
     * @param {SupportTicketMessageUpsertArgs} args - Arguments to update or create a SupportTicketMessage.
     * @example
     * // Update or create a SupportTicketMessage
     * const supportTicketMessage = await prisma.supportTicketMessage.upsert({
     *   create: {
     *     // ... data to create a SupportTicketMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicketMessage we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketMessageUpsertArgs>(args: SelectSubset<T, SupportTicketMessageUpsertArgs<ExtArgs>>): Prisma__SupportTicketMessageClient<$Result.GetResult<Prisma.$SupportTicketMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportTicketMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketMessageCountArgs} args - Arguments to filter SupportTicketMessages to count.
     * @example
     * // Count the number of SupportTicketMessages
     * const count = await prisma.supportTicketMessage.count({
     *   where: {
     *     // ... the filter for the SupportTicketMessages we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketMessageCountArgs>(
      args?: Subset<T, SupportTicketMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicketMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketMessageAggregateArgs>(args: Subset<T, SupportTicketMessageAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketMessageAggregateType<T>>

    /**
     * Group by SupportTicketMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketMessageGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicketMessage model
   */
  readonly fields: SupportTicketMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicketMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends SupportTicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicketDefaultArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicketMessage model
   */
  interface SupportTicketMessageFieldRefs {
    readonly id: FieldRef<"SupportTicketMessage", 'String'>
    readonly ticketId: FieldRef<"SupportTicketMessage", 'String'>
    readonly userId: FieldRef<"SupportTicketMessage", 'String'>
    readonly message: FieldRef<"SupportTicketMessage", 'String'>
    readonly isFromAdmin: FieldRef<"SupportTicketMessage", 'Boolean'>
    readonly attachments: FieldRef<"SupportTicketMessage", 'String[]'>
    readonly createdAt: FieldRef<"SupportTicketMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicketMessage findUnique
   */
  export type SupportTicketMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicketMessage to fetch.
     */
    where: SupportTicketMessageWhereUniqueInput
  }

  /**
   * SupportTicketMessage findUniqueOrThrow
   */
  export type SupportTicketMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicketMessage to fetch.
     */
    where: SupportTicketMessageWhereUniqueInput
  }

  /**
   * SupportTicketMessage findFirst
   */
  export type SupportTicketMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicketMessage to fetch.
     */
    where?: SupportTicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTicketMessages to fetch.
     */
    orderBy?: SupportTicketMessageOrderByWithRelationInput | SupportTicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTicketMessages.
     */
    cursor?: SupportTicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTicketMessages.
     */
    distinct?: SupportTicketMessageScalarFieldEnum | SupportTicketMessageScalarFieldEnum[]
  }

  /**
   * SupportTicketMessage findFirstOrThrow
   */
  export type SupportTicketMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicketMessage to fetch.
     */
    where?: SupportTicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTicketMessages to fetch.
     */
    orderBy?: SupportTicketMessageOrderByWithRelationInput | SupportTicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTicketMessages.
     */
    cursor?: SupportTicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTicketMessages.
     */
    distinct?: SupportTicketMessageScalarFieldEnum | SupportTicketMessageScalarFieldEnum[]
  }

  /**
   * SupportTicketMessage findMany
   */
  export type SupportTicketMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicketMessages to fetch.
     */
    where?: SupportTicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTicketMessages to fetch.
     */
    orderBy?: SupportTicketMessageOrderByWithRelationInput | SupportTicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTicketMessages.
     */
    cursor?: SupportTicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTicketMessages.
     */
    skip?: number
    distinct?: SupportTicketMessageScalarFieldEnum | SupportTicketMessageScalarFieldEnum[]
  }

  /**
   * SupportTicketMessage create
   */
  export type SupportTicketMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicketMessage.
     */
    data: XOR<SupportTicketMessageCreateInput, SupportTicketMessageUncheckedCreateInput>
  }

  /**
   * SupportTicketMessage createMany
   */
  export type SupportTicketMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTicketMessages.
     */
    data: SupportTicketMessageCreateManyInput | SupportTicketMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicketMessage createManyAndReturn
   */
  export type SupportTicketMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * The data used to create many SupportTicketMessages.
     */
    data: SupportTicketMessageCreateManyInput | SupportTicketMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicketMessage update
   */
  export type SupportTicketMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicketMessage.
     */
    data: XOR<SupportTicketMessageUpdateInput, SupportTicketMessageUncheckedUpdateInput>
    /**
     * Choose, which SupportTicketMessage to update.
     */
    where: SupportTicketMessageWhereUniqueInput
  }

  /**
   * SupportTicketMessage updateMany
   */
  export type SupportTicketMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTicketMessages.
     */
    data: XOR<SupportTicketMessageUpdateManyMutationInput, SupportTicketMessageUncheckedUpdateManyInput>
    /**
     * Filter which SupportTicketMessages to update
     */
    where?: SupportTicketMessageWhereInput
    /**
     * Limit how many SupportTicketMessages to update.
     */
    limit?: number
  }

  /**
   * SupportTicketMessage updateManyAndReturn
   */
  export type SupportTicketMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * The data used to update SupportTicketMessages.
     */
    data: XOR<SupportTicketMessageUpdateManyMutationInput, SupportTicketMessageUncheckedUpdateManyInput>
    /**
     * Filter which SupportTicketMessages to update
     */
    where?: SupportTicketMessageWhereInput
    /**
     * Limit how many SupportTicketMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicketMessage upsert
   */
  export type SupportTicketMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicketMessage to update in case it exists.
     */
    where: SupportTicketMessageWhereUniqueInput
    /**
     * In case the SupportTicketMessage found by the `where` argument doesn't exist, create a new SupportTicketMessage with this data.
     */
    create: XOR<SupportTicketMessageCreateInput, SupportTicketMessageUncheckedCreateInput>
    /**
     * In case the SupportTicketMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketMessageUpdateInput, SupportTicketMessageUncheckedUpdateInput>
  }

  /**
   * SupportTicketMessage delete
   */
  export type SupportTicketMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageInclude<ExtArgs> | null
    /**
     * Filter which SupportTicketMessage to delete.
     */
    where: SupportTicketMessageWhereUniqueInput
  }

  /**
   * SupportTicketMessage deleteMany
   */
  export type SupportTicketMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicketMessages to delete
     */
    where?: SupportTicketMessageWhereInput
    /**
     * Limit how many SupportTicketMessages to delete.
     */
    limit?: number
  }

  /**
   * SupportTicketMessage without action
   */
  export type SupportTicketMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketMessage
     */
    select?: SupportTicketMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportTicketMessage
     */
    omit?: SupportTicketMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketMessageInclude<ExtArgs> | null
  }


  /**
   * Model AdminAction
   */

  export type AggregateAdminAction = {
    _count: AdminActionCountAggregateOutputType | null
    _min: AdminActionMinAggregateOutputType | null
    _max: AdminActionMaxAggregateOutputType | null
  }

  export type AdminActionMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    targetType: string | null
    targetId: string | null
    description: string | null
    createdAt: Date | null
  }

  export type AdminActionMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    targetType: string | null
    targetId: string | null
    description: string | null
    createdAt: Date | null
  }

  export type AdminActionCountAggregateOutputType = {
    id: number
    adminId: number
    action: number
    targetType: number
    targetId: number
    description: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AdminActionMinAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetType?: true
    targetId?: true
    description?: true
    createdAt?: true
  }

  export type AdminActionMaxAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetType?: true
    targetId?: true
    description?: true
    createdAt?: true
  }

  export type AdminActionCountAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    targetType?: true
    targetId?: true
    description?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AdminActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAction to aggregate.
     */
    where?: AdminActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActions to fetch.
     */
    orderBy?: AdminActionOrderByWithRelationInput | AdminActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminActions
    **/
    _count?: true | AdminActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminActionMaxAggregateInputType
  }

  export type GetAdminActionAggregateType<T extends AdminActionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAction[P]>
      : GetScalarType<T[P], AggregateAdminAction[P]>
  }




  export type AdminActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActionWhereInput
    orderBy?: AdminActionOrderByWithAggregationInput | AdminActionOrderByWithAggregationInput[]
    by: AdminActionScalarFieldEnum[] | AdminActionScalarFieldEnum
    having?: AdminActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminActionCountAggregateInputType | true
    _min?: AdminActionMinAggregateInputType
    _max?: AdminActionMaxAggregateInputType
  }

  export type AdminActionGroupByOutputType = {
    id: string
    adminId: string
    action: string
    targetType: string
    targetId: string | null
    description: string
    metadata: JsonValue | null
    createdAt: Date
    _count: AdminActionCountAggregateOutputType | null
    _min: AdminActionMinAggregateOutputType | null
    _max: AdminActionMaxAggregateOutputType | null
  }

  type GetAdminActionGroupByPayload<T extends AdminActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminActionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminActionGroupByOutputType[P]>
        }
      >
    >


  export type AdminActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAction"]>

  export type AdminActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAction"]>

  export type AdminActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAction"]>

  export type AdminActionSelectScalar = {
    id?: boolean
    adminId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AdminActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "action" | "targetType" | "targetId" | "description" | "metadata" | "createdAt", ExtArgs["result"]["adminAction"]>
  export type AdminActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAction"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      action: string
      targetType: string
      targetId: string | null
      description: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["adminAction"]>
    composites: {}
  }

  type AdminActionGetPayload<S extends boolean | null | undefined | AdminActionDefaultArgs> = $Result.GetResult<Prisma.$AdminActionPayload, S>

  type AdminActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminActionCountAggregateInputType | true
    }

  export interface AdminActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAction'], meta: { name: 'AdminAction' } }
    /**
     * Find zero or one AdminAction that matches the filter.
     * @param {AdminActionFindUniqueArgs} args - Arguments to find a AdminAction
     * @example
     * // Get one AdminAction
     * const adminAction = await prisma.adminAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminActionFindUniqueArgs>(args: SelectSubset<T, AdminActionFindUniqueArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminActionFindUniqueOrThrowArgs} args - Arguments to find a AdminAction
     * @example
     * // Get one AdminAction
     * const adminAction = await prisma.adminAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminActionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionFindFirstArgs} args - Arguments to find a AdminAction
     * @example
     * // Get one AdminAction
     * const adminAction = await prisma.adminAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminActionFindFirstArgs>(args?: SelectSubset<T, AdminActionFindFirstArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionFindFirstOrThrowArgs} args - Arguments to find a AdminAction
     * @example
     * // Get one AdminAction
     * const adminAction = await prisma.adminAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminActionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminActions
     * const adminActions = await prisma.adminAction.findMany()
     * 
     * // Get first 10 AdminActions
     * const adminActions = await prisma.adminAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminActionWithIdOnly = await prisma.adminAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminActionFindManyArgs>(args?: SelectSubset<T, AdminActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminAction.
     * @param {AdminActionCreateArgs} args - Arguments to create a AdminAction.
     * @example
     * // Create one AdminAction
     * const AdminAction = await prisma.adminAction.create({
     *   data: {
     *     // ... data to create a AdminAction
     *   }
     * })
     * 
     */
    create<T extends AdminActionCreateArgs>(args: SelectSubset<T, AdminActionCreateArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminActions.
     * @param {AdminActionCreateManyArgs} args - Arguments to create many AdminActions.
     * @example
     * // Create many AdminActions
     * const adminAction = await prisma.adminAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminActionCreateManyArgs>(args?: SelectSubset<T, AdminActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminActions and returns the data saved in the database.
     * @param {AdminActionCreateManyAndReturnArgs} args - Arguments to create many AdminActions.
     * @example
     * // Create many AdminActions
     * const adminAction = await prisma.adminAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminActions and only return the `id`
     * const adminActionWithIdOnly = await prisma.adminAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminActionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminAction.
     * @param {AdminActionDeleteArgs} args - Arguments to delete one AdminAction.
     * @example
     * // Delete one AdminAction
     * const AdminAction = await prisma.adminAction.delete({
     *   where: {
     *     // ... filter to delete one AdminAction
     *   }
     * })
     * 
     */
    delete<T extends AdminActionDeleteArgs>(args: SelectSubset<T, AdminActionDeleteArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminAction.
     * @param {AdminActionUpdateArgs} args - Arguments to update one AdminAction.
     * @example
     * // Update one AdminAction
     * const adminAction = await prisma.adminAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminActionUpdateArgs>(args: SelectSubset<T, AdminActionUpdateArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminActions.
     * @param {AdminActionDeleteManyArgs} args - Arguments to filter AdminActions to delete.
     * @example
     * // Delete a few AdminActions
     * const { count } = await prisma.adminAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminActionDeleteManyArgs>(args?: SelectSubset<T, AdminActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminActions
     * const adminAction = await prisma.adminAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminActionUpdateManyArgs>(args: SelectSubset<T, AdminActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminActions and returns the data updated in the database.
     * @param {AdminActionUpdateManyAndReturnArgs} args - Arguments to update many AdminActions.
     * @example
     * // Update many AdminActions
     * const adminAction = await prisma.adminAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminActions and only return the `id`
     * const adminActionWithIdOnly = await prisma.adminAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminActionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminAction.
     * @param {AdminActionUpsertArgs} args - Arguments to update or create a AdminAction.
     * @example
     * // Update or create a AdminAction
     * const adminAction = await prisma.adminAction.upsert({
     *   create: {
     *     // ... data to create a AdminAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAction we want to update
     *   }
     * })
     */
    upsert<T extends AdminActionUpsertArgs>(args: SelectSubset<T, AdminActionUpsertArgs<ExtArgs>>): Prisma__AdminActionClient<$Result.GetResult<Prisma.$AdminActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionCountArgs} args - Arguments to filter AdminActions to count.
     * @example
     * // Count the number of AdminActions
     * const count = await prisma.adminAction.count({
     *   where: {
     *     // ... the filter for the AdminActions we want to count
     *   }
     * })
    **/
    count<T extends AdminActionCountArgs>(
      args?: Subset<T, AdminActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminActionAggregateArgs>(args: Subset<T, AdminActionAggregateArgs>): Prisma.PrismaPromise<GetAdminActionAggregateType<T>>

    /**
     * Group by AdminAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminActionGroupByArgs['orderBy'] }
        : { orderBy?: AdminActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAction model
   */
  readonly fields: AdminActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAction model
   */
  interface AdminActionFieldRefs {
    readonly id: FieldRef<"AdminAction", 'String'>
    readonly adminId: FieldRef<"AdminAction", 'String'>
    readonly action: FieldRef<"AdminAction", 'String'>
    readonly targetType: FieldRef<"AdminAction", 'String'>
    readonly targetId: FieldRef<"AdminAction", 'String'>
    readonly description: FieldRef<"AdminAction", 'String'>
    readonly metadata: FieldRef<"AdminAction", 'Json'>
    readonly createdAt: FieldRef<"AdminAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAction findUnique
   */
  export type AdminActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * Filter, which AdminAction to fetch.
     */
    where: AdminActionWhereUniqueInput
  }

  /**
   * AdminAction findUniqueOrThrow
   */
  export type AdminActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * Filter, which AdminAction to fetch.
     */
    where: AdminActionWhereUniqueInput
  }

  /**
   * AdminAction findFirst
   */
  export type AdminActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * Filter, which AdminAction to fetch.
     */
    where?: AdminActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActions to fetch.
     */
    orderBy?: AdminActionOrderByWithRelationInput | AdminActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminActions.
     */
    cursor?: AdminActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminActions.
     */
    distinct?: AdminActionScalarFieldEnum | AdminActionScalarFieldEnum[]
  }

  /**
   * AdminAction findFirstOrThrow
   */
  export type AdminActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * Filter, which AdminAction to fetch.
     */
    where?: AdminActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActions to fetch.
     */
    orderBy?: AdminActionOrderByWithRelationInput | AdminActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminActions.
     */
    cursor?: AdminActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminActions.
     */
    distinct?: AdminActionScalarFieldEnum | AdminActionScalarFieldEnum[]
  }

  /**
   * AdminAction findMany
   */
  export type AdminActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * Filter, which AdminActions to fetch.
     */
    where?: AdminActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActions to fetch.
     */
    orderBy?: AdminActionOrderByWithRelationInput | AdminActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminActions.
     */
    cursor?: AdminActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActions.
     */
    skip?: number
    distinct?: AdminActionScalarFieldEnum | AdminActionScalarFieldEnum[]
  }

  /**
   * AdminAction create
   */
  export type AdminActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAction.
     */
    data: XOR<AdminActionCreateInput, AdminActionUncheckedCreateInput>
  }

  /**
   * AdminAction createMany
   */
  export type AdminActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminActions.
     */
    data: AdminActionCreateManyInput | AdminActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAction createManyAndReturn
   */
  export type AdminActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * The data used to create many AdminActions.
     */
    data: AdminActionCreateManyInput | AdminActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAction update
   */
  export type AdminActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAction.
     */
    data: XOR<AdminActionUpdateInput, AdminActionUncheckedUpdateInput>
    /**
     * Choose, which AdminAction to update.
     */
    where: AdminActionWhereUniqueInput
  }

  /**
   * AdminAction updateMany
   */
  export type AdminActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminActions.
     */
    data: XOR<AdminActionUpdateManyMutationInput, AdminActionUncheckedUpdateManyInput>
    /**
     * Filter which AdminActions to update
     */
    where?: AdminActionWhereInput
    /**
     * Limit how many AdminActions to update.
     */
    limit?: number
  }

  /**
   * AdminAction updateManyAndReturn
   */
  export type AdminActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * The data used to update AdminActions.
     */
    data: XOR<AdminActionUpdateManyMutationInput, AdminActionUncheckedUpdateManyInput>
    /**
     * Filter which AdminActions to update
     */
    where?: AdminActionWhereInput
    /**
     * Limit how many AdminActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAction upsert
   */
  export type AdminActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAction to update in case it exists.
     */
    where: AdminActionWhereUniqueInput
    /**
     * In case the AdminAction found by the `where` argument doesn't exist, create a new AdminAction with this data.
     */
    create: XOR<AdminActionCreateInput, AdminActionUncheckedCreateInput>
    /**
     * In case the AdminAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminActionUpdateInput, AdminActionUncheckedUpdateInput>
  }

  /**
   * AdminAction delete
   */
  export type AdminActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
    /**
     * Filter which AdminAction to delete.
     */
    where: AdminActionWhereUniqueInput
  }

  /**
   * AdminAction deleteMany
   */
  export type AdminActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminActions to delete
     */
    where?: AdminActionWhereInput
    /**
     * Limit how many AdminActions to delete.
     */
    limit?: number
  }

  /**
   * AdminAction without action
   */
  export type AdminActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAction
     */
    select?: AdminActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAction
     */
    omit?: AdminActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActionInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    category: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      category: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'String'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly description: FieldRef<"SystemSetting", 'String'>
    readonly category: FieldRef<"SystemSetting", 'String'>
    readonly createdAt: FieldRef<"SystemSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    password: 'password',
    phone: 'phone',
    isActive: 'isActive',
    role: 'role',
    subscriptionTier: 'subscriptionTier',
    stripeCustomerId: 'stripeCustomerId',
    subscriptionId: 'subscriptionId',
    subscriptionStatus: 'subscriptionStatus',
    company: 'company',
    location: 'location',
    teamSize: 'teamSize',
    monthlyDeals: 'monthlyDeals',
    primaryFocus: 'primaryFocus',
    techComfort: 'techComfort',
    currentChallenges: 'currentChallenges',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLogin: 'lastLogin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    address: 'address',
    city: 'city',
    province: 'province',
    postalCode: 'postalCode',
    alertType: 'alertType',
    source: 'source',
    status: 'status',
    priority: 'priority',
    opportunityScore: 'opportunityScore',
    timelineMonths: 'timelineMonths',
    propertyType: 'propertyType',
    estimatedValue: 'estimatedValue',
    lotSize: 'lotSize',
    bedrooms: 'bedrooms',
    bathrooms: 'bathrooms',
    courtFileNumber: 'courtFileNumber',
    courtDate: 'courtDate',
    courtCaseId: 'courtCaseId',
    probateNumber: 'probateNumber',
    executorName: 'executorName',
    executorContact: 'executorContact',
    applicationNumber: 'applicationNumber',
    municipalOffice: 'municipalOffice',
    applicationDate: 'applicationDate',
    latitude: 'latitude',
    longitude: 'longitude',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    discoveredAt: 'discoveredAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const UserAlertScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    alertId: 'alertId',
    isNotified: 'isNotified',
    notifiedAt: 'notifiedAt',
    isViewed: 'isViewed',
    viewedAt: 'viewedAt',
    isBookmarked: 'isBookmarked',
    createdAt: 'createdAt'
  };

  export type UserAlertScalarFieldEnum = (typeof UserAlertScalarFieldEnum)[keyof typeof UserAlertScalarFieldEnum]


  export const AlertPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cities: 'cities',
    maxDistanceKm: 'maxDistanceKm',
    propertyTypes: 'propertyTypes',
    minValue: 'minValue',
    maxValue: 'maxValue',
    minBedrooms: 'minBedrooms',
    maxBedrooms: 'maxBedrooms',
    alertTypes: 'alertTypes',
    minPriority: 'minPriority',
    minOpportunityScore: 'minOpportunityScore',
    emailNotifications: 'emailNotifications',
    smsNotifications: 'smsNotifications',
    pushNotifications: 'pushNotifications',
    maxAlertsPerDay: 'maxAlertsPerDay',
    quietHoursStart: 'quietHoursStart',
    quietHoursEnd: 'quietHoursEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlertPreferenceScalarFieldEnum = (typeof AlertPreferenceScalarFieldEnum)[keyof typeof AlertPreferenceScalarFieldEnum]


  export const SavedPropertyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    alertId: 'alertId',
    notes: 'notes',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SavedPropertyScalarFieldEnum = (typeof SavedPropertyScalarFieldEnum)[keyof typeof SavedPropertyScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const EarlyAdopterTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    company: 'company',
    location: 'location',
    teamSize: 'teamSize',
    monthlyDeals: 'monthlyDeals',
    primaryFocus: 'primaryFocus',
    currentChallenges: 'currentChallenges',
    techComfort: 'techComfort',
    isUsed: 'isUsed',
    usedAt: 'usedAt',
    userId: 'userId',
    discountPercent: 'discountPercent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EarlyAdopterTokenScalarFieldEnum = (typeof EarlyAdopterTokenScalarFieldEnum)[keyof typeof EarlyAdopterTokenScalarFieldEnum]


  export const CourtCaseScalarFieldEnum: {
    id: 'id',
    guid: 'guid',
    title: 'title',
    neutralCitation: 'neutralCitation',
    court: 'court',
    publishDate: 'publishDate',
    caseUrl: 'caseUrl',
    summary: 'summary',
    fullText: 'fullText',
    addresses: 'addresses',
    municipalities: 'municipalities',
    parties: 'parties',
    statutes: 'statutes',
    caseTypes: 'caseTypes',
    riskLevel: 'riskLevel',
    isProcessed: 'isProcessed',
    nerProcessed: 'nerProcessed',
    classified: 'classified',
    source: 'source',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourtCaseScalarFieldEnum = (typeof CourtCaseScalarFieldEnum)[keyof typeof CourtCaseScalarFieldEnum]


  export const CaseProcessingQueueScalarFieldEnum: {
    id: 'id',
    caseId: 'caseId',
    processType: 'processType',
    status: 'status',
    priority: 'priority',
    attempts: 'attempts',
    maxAttempts: 'maxAttempts',
    error: 'error',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type CaseProcessingQueueScalarFieldEnum = (typeof CaseProcessingQueueScalarFieldEnum)[keyof typeof CaseProcessingQueueScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    category: 'category',
    assignedToId: 'assignedToId',
    resolution: 'resolution',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const SupportTicketMessageScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    userId: 'userId',
    message: 'message',
    isFromAdmin: 'isFromAdmin',
    attachments: 'attachments',
    createdAt: 'createdAt'
  };

  export type SupportTicketMessageScalarFieldEnum = (typeof SupportTicketMessageScalarFieldEnum)[keyof typeof SupportTicketMessageScalarFieldEnum]


  export const AdminActionScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    action: 'action',
    targetType: 'targetType',
    targetId: 'targetId',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AdminActionScalarFieldEnum = (typeof AdminActionScalarFieldEnum)[keyof typeof AdminActionScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    


  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AlertType'
   */
  export type EnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType'>
    


  /**
   * Reference to a field of type 'AlertType[]'
   */
  export type ListEnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType[]'>
    


  /**
   * Reference to a field of type 'DataSource'
   */
  export type EnumDataSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataSource'>
    


  /**
   * Reference to a field of type 'DataSource[]'
   */
  export type ListEnumDataSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataSource[]'>
    


  /**
   * Reference to a field of type 'AlertStatus'
   */
  export type EnumAlertStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertStatus'>
    


  /**
   * Reference to a field of type 'AlertStatus[]'
   */
  export type ListEnumAlertStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'CourtType'
   */
  export type EnumCourtTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourtType'>
    


  /**
   * Reference to a field of type 'CourtType[]'
   */
  export type ListEnumCourtTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourtType[]'>
    


  /**
   * Reference to a field of type 'RealEstateCaseType[]'
   */
  export type ListEnumRealEstateCaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RealEstateCaseType[]'>
    


  /**
   * Reference to a field of type 'RealEstateCaseType'
   */
  export type EnumRealEstateCaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RealEstateCaseType'>
    


  /**
   * Reference to a field of type 'RiskLevel'
   */
  export type EnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel'>
    


  /**
   * Reference to a field of type 'RiskLevel[]'
   */
  export type ListEnumRiskLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskLevel[]'>
    


  /**
   * Reference to a field of type 'ProcessingType'
   */
  export type EnumProcessingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingType'>
    


  /**
   * Reference to a field of type 'ProcessingType[]'
   */
  export type ListEnumProcessingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingType[]'>
    


  /**
   * Reference to a field of type 'ProcessingStatus'
   */
  export type EnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus'>
    


  /**
   * Reference to a field of type 'ProcessingStatus[]'
   */
  export type ListEnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus[]'>
    


  /**
   * Reference to a field of type 'SupportTicketStatus'
   */
  export type EnumSupportTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportTicketStatus'>
    


  /**
   * Reference to a field of type 'SupportTicketStatus[]'
   */
  export type ListEnumSupportTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportTicketStatus[]'>
    


  /**
   * Reference to a field of type 'SupportTicketPriority'
   */
  export type EnumSupportTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportTicketPriority'>
    


  /**
   * Reference to a field of type 'SupportTicketPriority[]'
   */
  export type ListEnumSupportTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportTicketPriority[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFilter<"User"> | $Enums.SubscriptionTier
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    subscriptionId?: StringNullableFilter<"User"> | string | null
    subscriptionStatus?: StringNullableFilter<"User"> | string | null
    company?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    teamSize?: StringNullableFilter<"User"> | string | null
    monthlyDeals?: StringNullableFilter<"User"> | string | null
    primaryFocus?: StringNullableFilter<"User"> | string | null
    techComfort?: StringNullableFilter<"User"> | string | null
    currentChallenges?: StringNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    alertPreferences?: AlertPreferenceListRelationFilter
    userAlerts?: UserAlertListRelationFilter
    savedProperties?: SavedPropertyListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
    assignedTickets?: SupportTicketListRelationFilter
    ticketMessages?: SupportTicketMessageListRelationFilter
    adminActions?: AdminActionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    role?: SortOrder
    subscriptionTier?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    teamSize?: SortOrderInput | SortOrder
    monthlyDeals?: SortOrderInput | SortOrder
    primaryFocus?: SortOrderInput | SortOrder
    techComfort?: SortOrderInput | SortOrder
    currentChallenges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    alertPreferences?: AlertPreferenceOrderByRelationAggregateInput
    userAlerts?: UserAlertOrderByRelationAggregateInput
    savedProperties?: SavedPropertyOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    supportTickets?: SupportTicketOrderByRelationAggregateInput
    assignedTickets?: SupportTicketOrderByRelationAggregateInput
    ticketMessages?: SupportTicketMessageOrderByRelationAggregateInput
    adminActions?: AdminActionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    stripeCustomerId?: string
    subscriptionId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFilter<"User"> | $Enums.SubscriptionTier
    subscriptionStatus?: StringNullableFilter<"User"> | string | null
    company?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    teamSize?: StringNullableFilter<"User"> | string | null
    monthlyDeals?: StringNullableFilter<"User"> | string | null
    primaryFocus?: StringNullableFilter<"User"> | string | null
    techComfort?: StringNullableFilter<"User"> | string | null
    currentChallenges?: StringNullableListFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    alertPreferences?: AlertPreferenceListRelationFilter
    userAlerts?: UserAlertListRelationFilter
    savedProperties?: SavedPropertyListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
    assignedTickets?: SupportTicketListRelationFilter
    ticketMessages?: SupportTicketMessageListRelationFilter
    adminActions?: AdminActionListRelationFilter
  }, "id" | "email" | "stripeCustomerId" | "subscriptionId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    role?: SortOrder
    subscriptionTier?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    teamSize?: SortOrderInput | SortOrder
    monthlyDeals?: SortOrderInput | SortOrder
    primaryFocus?: SortOrderInput | SortOrder
    techComfort?: SortOrderInput | SortOrder
    currentChallenges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierWithAggregatesFilter<"User"> | $Enums.SubscriptionTier
    stripeCustomerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscriptionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscriptionStatus?: StringNullableWithAggregatesFilter<"User"> | string | null
    company?: StringNullableWithAggregatesFilter<"User"> | string | null
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    teamSize?: StringNullableWithAggregatesFilter<"User"> | string | null
    monthlyDeals?: StringNullableWithAggregatesFilter<"User"> | string | null
    primaryFocus?: StringNullableWithAggregatesFilter<"User"> | string | null
    techComfort?: StringNullableWithAggregatesFilter<"User"> | string | null
    currentChallenges?: StringNullableListFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    title?: StringFilter<"Alert"> | string
    description?: StringFilter<"Alert"> | string
    address?: StringFilter<"Alert"> | string
    city?: StringFilter<"Alert"> | string
    province?: StringFilter<"Alert"> | string
    postalCode?: StringNullableFilter<"Alert"> | string | null
    alertType?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    source?: EnumDataSourceFilter<"Alert"> | $Enums.DataSource
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    priority?: EnumPriorityFilter<"Alert"> | $Enums.Priority
    opportunityScore?: IntFilter<"Alert"> | number
    timelineMonths?: IntNullableFilter<"Alert"> | number | null
    propertyType?: StringNullableFilter<"Alert"> | string | null
    estimatedValue?: IntNullableFilter<"Alert"> | number | null
    lotSize?: StringNullableFilter<"Alert"> | string | null
    bedrooms?: IntNullableFilter<"Alert"> | number | null
    bathrooms?: FloatNullableFilter<"Alert"> | number | null
    courtFileNumber?: StringNullableFilter<"Alert"> | string | null
    courtDate?: DateTimeNullableFilter<"Alert"> | Date | string | null
    courtCaseId?: StringNullableFilter<"Alert"> | string | null
    probateNumber?: StringNullableFilter<"Alert"> | string | null
    executorName?: StringNullableFilter<"Alert"> | string | null
    executorContact?: StringNullableFilter<"Alert"> | string | null
    applicationNumber?: StringNullableFilter<"Alert"> | string | null
    municipalOffice?: StringNullableFilter<"Alert"> | string | null
    applicationDate?: DateTimeNullableFilter<"Alert"> | Date | string | null
    latitude?: FloatNullableFilter<"Alert"> | number | null
    longitude?: FloatNullableFilter<"Alert"> | number | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    discoveredAt?: DateTimeFilter<"Alert"> | Date | string
    userAlerts?: UserAlertListRelationFilter
    courtCase?: XOR<CourtCaseNullableScalarRelationFilter, CourtCaseWhereInput> | null
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    alertType?: SortOrder
    source?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    opportunityScore?: SortOrder
    timelineMonths?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    lotSize?: SortOrderInput | SortOrder
    bedrooms?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    courtFileNumber?: SortOrderInput | SortOrder
    courtDate?: SortOrderInput | SortOrder
    courtCaseId?: SortOrderInput | SortOrder
    probateNumber?: SortOrderInput | SortOrder
    executorName?: SortOrderInput | SortOrder
    executorContact?: SortOrderInput | SortOrder
    applicationNumber?: SortOrderInput | SortOrder
    municipalOffice?: SortOrderInput | SortOrder
    applicationDate?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discoveredAt?: SortOrder
    userAlerts?: UserAlertOrderByRelationAggregateInput
    courtCase?: CourtCaseOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    title?: StringFilter<"Alert"> | string
    description?: StringFilter<"Alert"> | string
    address?: StringFilter<"Alert"> | string
    city?: StringFilter<"Alert"> | string
    province?: StringFilter<"Alert"> | string
    postalCode?: StringNullableFilter<"Alert"> | string | null
    alertType?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    source?: EnumDataSourceFilter<"Alert"> | $Enums.DataSource
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    priority?: EnumPriorityFilter<"Alert"> | $Enums.Priority
    opportunityScore?: IntFilter<"Alert"> | number
    timelineMonths?: IntNullableFilter<"Alert"> | number | null
    propertyType?: StringNullableFilter<"Alert"> | string | null
    estimatedValue?: IntNullableFilter<"Alert"> | number | null
    lotSize?: StringNullableFilter<"Alert"> | string | null
    bedrooms?: IntNullableFilter<"Alert"> | number | null
    bathrooms?: FloatNullableFilter<"Alert"> | number | null
    courtFileNumber?: StringNullableFilter<"Alert"> | string | null
    courtDate?: DateTimeNullableFilter<"Alert"> | Date | string | null
    courtCaseId?: StringNullableFilter<"Alert"> | string | null
    probateNumber?: StringNullableFilter<"Alert"> | string | null
    executorName?: StringNullableFilter<"Alert"> | string | null
    executorContact?: StringNullableFilter<"Alert"> | string | null
    applicationNumber?: StringNullableFilter<"Alert"> | string | null
    municipalOffice?: StringNullableFilter<"Alert"> | string | null
    applicationDate?: DateTimeNullableFilter<"Alert"> | Date | string | null
    latitude?: FloatNullableFilter<"Alert"> | number | null
    longitude?: FloatNullableFilter<"Alert"> | number | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    discoveredAt?: DateTimeFilter<"Alert"> | Date | string
    userAlerts?: UserAlertListRelationFilter
    courtCase?: XOR<CourtCaseNullableScalarRelationFilter, CourtCaseWhereInput> | null
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    alertType?: SortOrder
    source?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    opportunityScore?: SortOrder
    timelineMonths?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    estimatedValue?: SortOrderInput | SortOrder
    lotSize?: SortOrderInput | SortOrder
    bedrooms?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    courtFileNumber?: SortOrderInput | SortOrder
    courtDate?: SortOrderInput | SortOrder
    courtCaseId?: SortOrderInput | SortOrder
    probateNumber?: SortOrderInput | SortOrder
    executorName?: SortOrderInput | SortOrder
    executorContact?: SortOrderInput | SortOrder
    applicationNumber?: SortOrderInput | SortOrder
    municipalOffice?: SortOrderInput | SortOrder
    applicationDate?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discoveredAt?: SortOrder
    _count?: AlertCountOrderByAggregateInput
    _avg?: AlertAvgOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
    _sum?: AlertSumOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    title?: StringWithAggregatesFilter<"Alert"> | string
    description?: StringWithAggregatesFilter<"Alert"> | string
    address?: StringWithAggregatesFilter<"Alert"> | string
    city?: StringWithAggregatesFilter<"Alert"> | string
    province?: StringWithAggregatesFilter<"Alert"> | string
    postalCode?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    alertType?: EnumAlertTypeWithAggregatesFilter<"Alert"> | $Enums.AlertType
    source?: EnumDataSourceWithAggregatesFilter<"Alert"> | $Enums.DataSource
    status?: EnumAlertStatusWithAggregatesFilter<"Alert"> | $Enums.AlertStatus
    priority?: EnumPriorityWithAggregatesFilter<"Alert"> | $Enums.Priority
    opportunityScore?: IntWithAggregatesFilter<"Alert"> | number
    timelineMonths?: IntNullableWithAggregatesFilter<"Alert"> | number | null
    propertyType?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    estimatedValue?: IntNullableWithAggregatesFilter<"Alert"> | number | null
    lotSize?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    bedrooms?: IntNullableWithAggregatesFilter<"Alert"> | number | null
    bathrooms?: FloatNullableWithAggregatesFilter<"Alert"> | number | null
    courtFileNumber?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    courtDate?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
    courtCaseId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    probateNumber?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    executorName?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    executorContact?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    applicationNumber?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    municipalOffice?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    applicationDate?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Alert"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Alert"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    discoveredAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
  }

  export type UserAlertWhereInput = {
    AND?: UserAlertWhereInput | UserAlertWhereInput[]
    OR?: UserAlertWhereInput[]
    NOT?: UserAlertWhereInput | UserAlertWhereInput[]
    id?: StringFilter<"UserAlert"> | string
    userId?: StringFilter<"UserAlert"> | string
    alertId?: StringFilter<"UserAlert"> | string
    isNotified?: BoolFilter<"UserAlert"> | boolean
    notifiedAt?: DateTimeNullableFilter<"UserAlert"> | Date | string | null
    isViewed?: BoolFilter<"UserAlert"> | boolean
    viewedAt?: DateTimeNullableFilter<"UserAlert"> | Date | string | null
    isBookmarked?: BoolFilter<"UserAlert"> | boolean
    createdAt?: DateTimeFilter<"UserAlert"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    alert?: XOR<AlertScalarRelationFilter, AlertWhereInput>
  }

  export type UserAlertOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    alertId?: SortOrder
    isNotified?: SortOrder
    notifiedAt?: SortOrderInput | SortOrder
    isViewed?: SortOrder
    viewedAt?: SortOrderInput | SortOrder
    isBookmarked?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    alert?: AlertOrderByWithRelationInput
  }

  export type UserAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_alertId?: UserAlertUserIdAlertIdCompoundUniqueInput
    AND?: UserAlertWhereInput | UserAlertWhereInput[]
    OR?: UserAlertWhereInput[]
    NOT?: UserAlertWhereInput | UserAlertWhereInput[]
    userId?: StringFilter<"UserAlert"> | string
    alertId?: StringFilter<"UserAlert"> | string
    isNotified?: BoolFilter<"UserAlert"> | boolean
    notifiedAt?: DateTimeNullableFilter<"UserAlert"> | Date | string | null
    isViewed?: BoolFilter<"UserAlert"> | boolean
    viewedAt?: DateTimeNullableFilter<"UserAlert"> | Date | string | null
    isBookmarked?: BoolFilter<"UserAlert"> | boolean
    createdAt?: DateTimeFilter<"UserAlert"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    alert?: XOR<AlertScalarRelationFilter, AlertWhereInput>
  }, "id" | "userId_alertId">

  export type UserAlertOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    alertId?: SortOrder
    isNotified?: SortOrder
    notifiedAt?: SortOrderInput | SortOrder
    isViewed?: SortOrder
    viewedAt?: SortOrderInput | SortOrder
    isBookmarked?: SortOrder
    createdAt?: SortOrder
    _count?: UserAlertCountOrderByAggregateInput
    _max?: UserAlertMaxOrderByAggregateInput
    _min?: UserAlertMinOrderByAggregateInput
  }

  export type UserAlertScalarWhereWithAggregatesInput = {
    AND?: UserAlertScalarWhereWithAggregatesInput | UserAlertScalarWhereWithAggregatesInput[]
    OR?: UserAlertScalarWhereWithAggregatesInput[]
    NOT?: UserAlertScalarWhereWithAggregatesInput | UserAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAlert"> | string
    userId?: StringWithAggregatesFilter<"UserAlert"> | string
    alertId?: StringWithAggregatesFilter<"UserAlert"> | string
    isNotified?: BoolWithAggregatesFilter<"UserAlert"> | boolean
    notifiedAt?: DateTimeNullableWithAggregatesFilter<"UserAlert"> | Date | string | null
    isViewed?: BoolWithAggregatesFilter<"UserAlert"> | boolean
    viewedAt?: DateTimeNullableWithAggregatesFilter<"UserAlert"> | Date | string | null
    isBookmarked?: BoolWithAggregatesFilter<"UserAlert"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserAlert"> | Date | string
  }

  export type AlertPreferenceWhereInput = {
    AND?: AlertPreferenceWhereInput | AlertPreferenceWhereInput[]
    OR?: AlertPreferenceWhereInput[]
    NOT?: AlertPreferenceWhereInput | AlertPreferenceWhereInput[]
    id?: StringFilter<"AlertPreference"> | string
    userId?: StringFilter<"AlertPreference"> | string
    cities?: StringNullableListFilter<"AlertPreference">
    maxDistanceKm?: IntFilter<"AlertPreference"> | number
    propertyTypes?: StringNullableListFilter<"AlertPreference">
    minValue?: IntNullableFilter<"AlertPreference"> | number | null
    maxValue?: IntNullableFilter<"AlertPreference"> | number | null
    minBedrooms?: IntNullableFilter<"AlertPreference"> | number | null
    maxBedrooms?: IntNullableFilter<"AlertPreference"> | number | null
    alertTypes?: EnumAlertTypeNullableListFilter<"AlertPreference">
    minPriority?: EnumPriorityFilter<"AlertPreference"> | $Enums.Priority
    minOpportunityScore?: IntFilter<"AlertPreference"> | number
    emailNotifications?: BoolFilter<"AlertPreference"> | boolean
    smsNotifications?: BoolFilter<"AlertPreference"> | boolean
    pushNotifications?: BoolFilter<"AlertPreference"> | boolean
    maxAlertsPerDay?: IntFilter<"AlertPreference"> | number
    quietHoursStart?: StringNullableFilter<"AlertPreference"> | string | null
    quietHoursEnd?: StringNullableFilter<"AlertPreference"> | string | null
    createdAt?: DateTimeFilter<"AlertPreference"> | Date | string
    updatedAt?: DateTimeFilter<"AlertPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AlertPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cities?: SortOrder
    maxDistanceKm?: SortOrder
    propertyTypes?: SortOrder
    minValue?: SortOrderInput | SortOrder
    maxValue?: SortOrderInput | SortOrder
    minBedrooms?: SortOrderInput | SortOrder
    maxBedrooms?: SortOrderInput | SortOrder
    alertTypes?: SortOrder
    minPriority?: SortOrder
    minOpportunityScore?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    maxAlertsPerDay?: SortOrder
    quietHoursStart?: SortOrderInput | SortOrder
    quietHoursEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AlertPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AlertPreferenceWhereInput | AlertPreferenceWhereInput[]
    OR?: AlertPreferenceWhereInput[]
    NOT?: AlertPreferenceWhereInput | AlertPreferenceWhereInput[]
    cities?: StringNullableListFilter<"AlertPreference">
    maxDistanceKm?: IntFilter<"AlertPreference"> | number
    propertyTypes?: StringNullableListFilter<"AlertPreference">
    minValue?: IntNullableFilter<"AlertPreference"> | number | null
    maxValue?: IntNullableFilter<"AlertPreference"> | number | null
    minBedrooms?: IntNullableFilter<"AlertPreference"> | number | null
    maxBedrooms?: IntNullableFilter<"AlertPreference"> | number | null
    alertTypes?: EnumAlertTypeNullableListFilter<"AlertPreference">
    minPriority?: EnumPriorityFilter<"AlertPreference"> | $Enums.Priority
    minOpportunityScore?: IntFilter<"AlertPreference"> | number
    emailNotifications?: BoolFilter<"AlertPreference"> | boolean
    smsNotifications?: BoolFilter<"AlertPreference"> | boolean
    pushNotifications?: BoolFilter<"AlertPreference"> | boolean
    maxAlertsPerDay?: IntFilter<"AlertPreference"> | number
    quietHoursStart?: StringNullableFilter<"AlertPreference"> | string | null
    quietHoursEnd?: StringNullableFilter<"AlertPreference"> | string | null
    createdAt?: DateTimeFilter<"AlertPreference"> | Date | string
    updatedAt?: DateTimeFilter<"AlertPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AlertPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cities?: SortOrder
    maxDistanceKm?: SortOrder
    propertyTypes?: SortOrder
    minValue?: SortOrderInput | SortOrder
    maxValue?: SortOrderInput | SortOrder
    minBedrooms?: SortOrderInput | SortOrder
    maxBedrooms?: SortOrderInput | SortOrder
    alertTypes?: SortOrder
    minPriority?: SortOrder
    minOpportunityScore?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    maxAlertsPerDay?: SortOrder
    quietHoursStart?: SortOrderInput | SortOrder
    quietHoursEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlertPreferenceCountOrderByAggregateInput
    _avg?: AlertPreferenceAvgOrderByAggregateInput
    _max?: AlertPreferenceMaxOrderByAggregateInput
    _min?: AlertPreferenceMinOrderByAggregateInput
    _sum?: AlertPreferenceSumOrderByAggregateInput
  }

  export type AlertPreferenceScalarWhereWithAggregatesInput = {
    AND?: AlertPreferenceScalarWhereWithAggregatesInput | AlertPreferenceScalarWhereWithAggregatesInput[]
    OR?: AlertPreferenceScalarWhereWithAggregatesInput[]
    NOT?: AlertPreferenceScalarWhereWithAggregatesInput | AlertPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AlertPreference"> | string
    userId?: StringWithAggregatesFilter<"AlertPreference"> | string
    cities?: StringNullableListFilter<"AlertPreference">
    maxDistanceKm?: IntWithAggregatesFilter<"AlertPreference"> | number
    propertyTypes?: StringNullableListFilter<"AlertPreference">
    minValue?: IntNullableWithAggregatesFilter<"AlertPreference"> | number | null
    maxValue?: IntNullableWithAggregatesFilter<"AlertPreference"> | number | null
    minBedrooms?: IntNullableWithAggregatesFilter<"AlertPreference"> | number | null
    maxBedrooms?: IntNullableWithAggregatesFilter<"AlertPreference"> | number | null
    alertTypes?: EnumAlertTypeNullableListFilter<"AlertPreference">
    minPriority?: EnumPriorityWithAggregatesFilter<"AlertPreference"> | $Enums.Priority
    minOpportunityScore?: IntWithAggregatesFilter<"AlertPreference"> | number
    emailNotifications?: BoolWithAggregatesFilter<"AlertPreference"> | boolean
    smsNotifications?: BoolWithAggregatesFilter<"AlertPreference"> | boolean
    pushNotifications?: BoolWithAggregatesFilter<"AlertPreference"> | boolean
    maxAlertsPerDay?: IntWithAggregatesFilter<"AlertPreference"> | number
    quietHoursStart?: StringNullableWithAggregatesFilter<"AlertPreference"> | string | null
    quietHoursEnd?: StringNullableWithAggregatesFilter<"AlertPreference"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AlertPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AlertPreference"> | Date | string
  }

  export type SavedPropertyWhereInput = {
    AND?: SavedPropertyWhereInput | SavedPropertyWhereInput[]
    OR?: SavedPropertyWhereInput[]
    NOT?: SavedPropertyWhereInput | SavedPropertyWhereInput[]
    id?: StringFilter<"SavedProperty"> | string
    userId?: StringFilter<"SavedProperty"> | string
    alertId?: StringFilter<"SavedProperty"> | string
    notes?: StringNullableFilter<"SavedProperty"> | string | null
    tags?: StringNullableListFilter<"SavedProperty">
    createdAt?: DateTimeFilter<"SavedProperty"> | Date | string
    updatedAt?: DateTimeFilter<"SavedProperty"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SavedPropertyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    alertId?: SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SavedPropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_alertId?: SavedPropertyUserIdAlertIdCompoundUniqueInput
    AND?: SavedPropertyWhereInput | SavedPropertyWhereInput[]
    OR?: SavedPropertyWhereInput[]
    NOT?: SavedPropertyWhereInput | SavedPropertyWhereInput[]
    userId?: StringFilter<"SavedProperty"> | string
    alertId?: StringFilter<"SavedProperty"> | string
    notes?: StringNullableFilter<"SavedProperty"> | string | null
    tags?: StringNullableListFilter<"SavedProperty">
    createdAt?: DateTimeFilter<"SavedProperty"> | Date | string
    updatedAt?: DateTimeFilter<"SavedProperty"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_alertId">

  export type SavedPropertyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    alertId?: SortOrder
    notes?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SavedPropertyCountOrderByAggregateInput
    _max?: SavedPropertyMaxOrderByAggregateInput
    _min?: SavedPropertyMinOrderByAggregateInput
  }

  export type SavedPropertyScalarWhereWithAggregatesInput = {
    AND?: SavedPropertyScalarWhereWithAggregatesInput | SavedPropertyScalarWhereWithAggregatesInput[]
    OR?: SavedPropertyScalarWhereWithAggregatesInput[]
    NOT?: SavedPropertyScalarWhereWithAggregatesInput | SavedPropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedProperty"> | string
    userId?: StringWithAggregatesFilter<"SavedProperty"> | string
    alertId?: StringWithAggregatesFilter<"SavedProperty"> | string
    notes?: StringNullableWithAggregatesFilter<"SavedProperty"> | string | null
    tags?: StringNullableListFilter<"SavedProperty">
    createdAt?: DateTimeWithAggregatesFilter<"SavedProperty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SavedProperty"> | Date | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: EnumActivityTypeFilter<"ActivityLog"> | $Enums.ActivityType
    details?: JsonNullableFilter<"ActivityLog">
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: EnumActivityTypeFilter<"ActivityLog"> | $Enums.ActivityType
    details?: JsonNullableFilter<"ActivityLog">
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    userId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    action?: EnumActivityTypeWithAggregatesFilter<"ActivityLog"> | $Enums.ActivityType
    details?: JsonNullableWithAggregatesFilter<"ActivityLog">
    ipAddress?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type EarlyAdopterTokenWhereInput = {
    AND?: EarlyAdopterTokenWhereInput | EarlyAdopterTokenWhereInput[]
    OR?: EarlyAdopterTokenWhereInput[]
    NOT?: EarlyAdopterTokenWhereInput | EarlyAdopterTokenWhereInput[]
    id?: StringFilter<"EarlyAdopterToken"> | string
    token?: StringFilter<"EarlyAdopterToken"> | string
    email?: StringFilter<"EarlyAdopterToken"> | string
    firstName?: StringFilter<"EarlyAdopterToken"> | string
    lastName?: StringFilter<"EarlyAdopterToken"> | string
    phone?: StringFilter<"EarlyAdopterToken"> | string
    company?: StringFilter<"EarlyAdopterToken"> | string
    location?: StringFilter<"EarlyAdopterToken"> | string
    teamSize?: StringFilter<"EarlyAdopterToken"> | string
    monthlyDeals?: StringFilter<"EarlyAdopterToken"> | string
    primaryFocus?: StringFilter<"EarlyAdopterToken"> | string
    currentChallenges?: StringNullableListFilter<"EarlyAdopterToken">
    techComfort?: StringFilter<"EarlyAdopterToken"> | string
    isUsed?: BoolFilter<"EarlyAdopterToken"> | boolean
    usedAt?: DateTimeNullableFilter<"EarlyAdopterToken"> | Date | string | null
    userId?: StringNullableFilter<"EarlyAdopterToken"> | string | null
    discountPercent?: IntFilter<"EarlyAdopterToken"> | number
    expiresAt?: DateTimeNullableFilter<"EarlyAdopterToken"> | Date | string | null
    createdAt?: DateTimeFilter<"EarlyAdopterToken"> | Date | string
    updatedAt?: DateTimeFilter<"EarlyAdopterToken"> | Date | string
  }

  export type EarlyAdopterTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    location?: SortOrder
    teamSize?: SortOrder
    monthlyDeals?: SortOrder
    primaryFocus?: SortOrder
    currentChallenges?: SortOrder
    techComfort?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    discountPercent?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EarlyAdopterTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email?: string
    userId?: string
    AND?: EarlyAdopterTokenWhereInput | EarlyAdopterTokenWhereInput[]
    OR?: EarlyAdopterTokenWhereInput[]
    NOT?: EarlyAdopterTokenWhereInput | EarlyAdopterTokenWhereInput[]
    firstName?: StringFilter<"EarlyAdopterToken"> | string
    lastName?: StringFilter<"EarlyAdopterToken"> | string
    phone?: StringFilter<"EarlyAdopterToken"> | string
    company?: StringFilter<"EarlyAdopterToken"> | string
    location?: StringFilter<"EarlyAdopterToken"> | string
    teamSize?: StringFilter<"EarlyAdopterToken"> | string
    monthlyDeals?: StringFilter<"EarlyAdopterToken"> | string
    primaryFocus?: StringFilter<"EarlyAdopterToken"> | string
    currentChallenges?: StringNullableListFilter<"EarlyAdopterToken">
    techComfort?: StringFilter<"EarlyAdopterToken"> | string
    isUsed?: BoolFilter<"EarlyAdopterToken"> | boolean
    usedAt?: DateTimeNullableFilter<"EarlyAdopterToken"> | Date | string | null
    discountPercent?: IntFilter<"EarlyAdopterToken"> | number
    expiresAt?: DateTimeNullableFilter<"EarlyAdopterToken"> | Date | string | null
    createdAt?: DateTimeFilter<"EarlyAdopterToken"> | Date | string
    updatedAt?: DateTimeFilter<"EarlyAdopterToken"> | Date | string
  }, "id" | "token" | "email" | "userId">

  export type EarlyAdopterTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    location?: SortOrder
    teamSize?: SortOrder
    monthlyDeals?: SortOrder
    primaryFocus?: SortOrder
    currentChallenges?: SortOrder
    techComfort?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    discountPercent?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EarlyAdopterTokenCountOrderByAggregateInput
    _avg?: EarlyAdopterTokenAvgOrderByAggregateInput
    _max?: EarlyAdopterTokenMaxOrderByAggregateInput
    _min?: EarlyAdopterTokenMinOrderByAggregateInput
    _sum?: EarlyAdopterTokenSumOrderByAggregateInput
  }

  export type EarlyAdopterTokenScalarWhereWithAggregatesInput = {
    AND?: EarlyAdopterTokenScalarWhereWithAggregatesInput | EarlyAdopterTokenScalarWhereWithAggregatesInput[]
    OR?: EarlyAdopterTokenScalarWhereWithAggregatesInput[]
    NOT?: EarlyAdopterTokenScalarWhereWithAggregatesInput | EarlyAdopterTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EarlyAdopterToken"> | string
    token?: StringWithAggregatesFilter<"EarlyAdopterToken"> | string
    email?: StringWithAggregatesFilter<"EarlyAdopterToken"> | string
    firstName?: StringWithAggregatesFilter<"EarlyAdopterToken"> | string
    lastName?: StringWithAggregatesFilter<"EarlyAdopterToken"> | string
    phone?: StringWithAggregatesFilter<"EarlyAdopterToken"> | string
    company?: StringWithAggregatesFilter<"EarlyAdopterToken"> | string
    location?: StringWithAggregatesFilter<"EarlyAdopterToken"> | string
    teamSize?: StringWithAggregatesFilter<"EarlyAdopterToken"> | string
    monthlyDeals?: StringWithAggregatesFilter<"EarlyAdopterToken"> | string
    primaryFocus?: StringWithAggregatesFilter<"EarlyAdopterToken"> | string
    currentChallenges?: StringNullableListFilter<"EarlyAdopterToken">
    techComfort?: StringWithAggregatesFilter<"EarlyAdopterToken"> | string
    isUsed?: BoolWithAggregatesFilter<"EarlyAdopterToken"> | boolean
    usedAt?: DateTimeNullableWithAggregatesFilter<"EarlyAdopterToken"> | Date | string | null
    userId?: StringNullableWithAggregatesFilter<"EarlyAdopterToken"> | string | null
    discountPercent?: IntWithAggregatesFilter<"EarlyAdopterToken"> | number
    expiresAt?: DateTimeNullableWithAggregatesFilter<"EarlyAdopterToken"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EarlyAdopterToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EarlyAdopterToken"> | Date | string
  }

  export type CourtCaseWhereInput = {
    AND?: CourtCaseWhereInput | CourtCaseWhereInput[]
    OR?: CourtCaseWhereInput[]
    NOT?: CourtCaseWhereInput | CourtCaseWhereInput[]
    id?: StringFilter<"CourtCase"> | string
    guid?: StringFilter<"CourtCase"> | string
    title?: StringFilter<"CourtCase"> | string
    neutralCitation?: StringNullableFilter<"CourtCase"> | string | null
    court?: EnumCourtTypeFilter<"CourtCase"> | $Enums.CourtType
    publishDate?: DateTimeFilter<"CourtCase"> | Date | string
    caseUrl?: StringFilter<"CourtCase"> | string
    summary?: StringNullableFilter<"CourtCase"> | string | null
    fullText?: StringNullableFilter<"CourtCase"> | string | null
    addresses?: StringNullableListFilter<"CourtCase">
    municipalities?: StringNullableListFilter<"CourtCase">
    parties?: StringNullableListFilter<"CourtCase">
    statutes?: StringNullableListFilter<"CourtCase">
    caseTypes?: EnumRealEstateCaseTypeNullableListFilter<"CourtCase">
    riskLevel?: EnumRiskLevelFilter<"CourtCase"> | $Enums.RiskLevel
    isProcessed?: BoolFilter<"CourtCase"> | boolean
    nerProcessed?: BoolFilter<"CourtCase"> | boolean
    classified?: BoolFilter<"CourtCase"> | boolean
    source?: StringFilter<"CourtCase"> | string
    metadata?: JsonNullableFilter<"CourtCase">
    createdAt?: DateTimeFilter<"CourtCase"> | Date | string
    updatedAt?: DateTimeFilter<"CourtCase"> | Date | string
    alerts?: AlertListRelationFilter
    processingQueue?: CaseProcessingQueueListRelationFilter
  }

  export type CourtCaseOrderByWithRelationInput = {
    id?: SortOrder
    guid?: SortOrder
    title?: SortOrder
    neutralCitation?: SortOrderInput | SortOrder
    court?: SortOrder
    publishDate?: SortOrder
    caseUrl?: SortOrder
    summary?: SortOrderInput | SortOrder
    fullText?: SortOrderInput | SortOrder
    addresses?: SortOrder
    municipalities?: SortOrder
    parties?: SortOrder
    statutes?: SortOrder
    caseTypes?: SortOrder
    riskLevel?: SortOrder
    isProcessed?: SortOrder
    nerProcessed?: SortOrder
    classified?: SortOrder
    source?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    alerts?: AlertOrderByRelationAggregateInput
    processingQueue?: CaseProcessingQueueOrderByRelationAggregateInput
  }

  export type CourtCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    guid?: string
    AND?: CourtCaseWhereInput | CourtCaseWhereInput[]
    OR?: CourtCaseWhereInput[]
    NOT?: CourtCaseWhereInput | CourtCaseWhereInput[]
    title?: StringFilter<"CourtCase"> | string
    neutralCitation?: StringNullableFilter<"CourtCase"> | string | null
    court?: EnumCourtTypeFilter<"CourtCase"> | $Enums.CourtType
    publishDate?: DateTimeFilter<"CourtCase"> | Date | string
    caseUrl?: StringFilter<"CourtCase"> | string
    summary?: StringNullableFilter<"CourtCase"> | string | null
    fullText?: StringNullableFilter<"CourtCase"> | string | null
    addresses?: StringNullableListFilter<"CourtCase">
    municipalities?: StringNullableListFilter<"CourtCase">
    parties?: StringNullableListFilter<"CourtCase">
    statutes?: StringNullableListFilter<"CourtCase">
    caseTypes?: EnumRealEstateCaseTypeNullableListFilter<"CourtCase">
    riskLevel?: EnumRiskLevelFilter<"CourtCase"> | $Enums.RiskLevel
    isProcessed?: BoolFilter<"CourtCase"> | boolean
    nerProcessed?: BoolFilter<"CourtCase"> | boolean
    classified?: BoolFilter<"CourtCase"> | boolean
    source?: StringFilter<"CourtCase"> | string
    metadata?: JsonNullableFilter<"CourtCase">
    createdAt?: DateTimeFilter<"CourtCase"> | Date | string
    updatedAt?: DateTimeFilter<"CourtCase"> | Date | string
    alerts?: AlertListRelationFilter
    processingQueue?: CaseProcessingQueueListRelationFilter
  }, "id" | "guid">

  export type CourtCaseOrderByWithAggregationInput = {
    id?: SortOrder
    guid?: SortOrder
    title?: SortOrder
    neutralCitation?: SortOrderInput | SortOrder
    court?: SortOrder
    publishDate?: SortOrder
    caseUrl?: SortOrder
    summary?: SortOrderInput | SortOrder
    fullText?: SortOrderInput | SortOrder
    addresses?: SortOrder
    municipalities?: SortOrder
    parties?: SortOrder
    statutes?: SortOrder
    caseTypes?: SortOrder
    riskLevel?: SortOrder
    isProcessed?: SortOrder
    nerProcessed?: SortOrder
    classified?: SortOrder
    source?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourtCaseCountOrderByAggregateInput
    _max?: CourtCaseMaxOrderByAggregateInput
    _min?: CourtCaseMinOrderByAggregateInput
  }

  export type CourtCaseScalarWhereWithAggregatesInput = {
    AND?: CourtCaseScalarWhereWithAggregatesInput | CourtCaseScalarWhereWithAggregatesInput[]
    OR?: CourtCaseScalarWhereWithAggregatesInput[]
    NOT?: CourtCaseScalarWhereWithAggregatesInput | CourtCaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourtCase"> | string
    guid?: StringWithAggregatesFilter<"CourtCase"> | string
    title?: StringWithAggregatesFilter<"CourtCase"> | string
    neutralCitation?: StringNullableWithAggregatesFilter<"CourtCase"> | string | null
    court?: EnumCourtTypeWithAggregatesFilter<"CourtCase"> | $Enums.CourtType
    publishDate?: DateTimeWithAggregatesFilter<"CourtCase"> | Date | string
    caseUrl?: StringWithAggregatesFilter<"CourtCase"> | string
    summary?: StringNullableWithAggregatesFilter<"CourtCase"> | string | null
    fullText?: StringNullableWithAggregatesFilter<"CourtCase"> | string | null
    addresses?: StringNullableListFilter<"CourtCase">
    municipalities?: StringNullableListFilter<"CourtCase">
    parties?: StringNullableListFilter<"CourtCase">
    statutes?: StringNullableListFilter<"CourtCase">
    caseTypes?: EnumRealEstateCaseTypeNullableListFilter<"CourtCase">
    riskLevel?: EnumRiskLevelWithAggregatesFilter<"CourtCase"> | $Enums.RiskLevel
    isProcessed?: BoolWithAggregatesFilter<"CourtCase"> | boolean
    nerProcessed?: BoolWithAggregatesFilter<"CourtCase"> | boolean
    classified?: BoolWithAggregatesFilter<"CourtCase"> | boolean
    source?: StringWithAggregatesFilter<"CourtCase"> | string
    metadata?: JsonNullableWithAggregatesFilter<"CourtCase">
    createdAt?: DateTimeWithAggregatesFilter<"CourtCase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CourtCase"> | Date | string
  }

  export type CaseProcessingQueueWhereInput = {
    AND?: CaseProcessingQueueWhereInput | CaseProcessingQueueWhereInput[]
    OR?: CaseProcessingQueueWhereInput[]
    NOT?: CaseProcessingQueueWhereInput | CaseProcessingQueueWhereInput[]
    id?: StringFilter<"CaseProcessingQueue"> | string
    caseId?: StringFilter<"CaseProcessingQueue"> | string
    processType?: EnumProcessingTypeFilter<"CaseProcessingQueue"> | $Enums.ProcessingType
    status?: EnumProcessingStatusFilter<"CaseProcessingQueue"> | $Enums.ProcessingStatus
    priority?: IntFilter<"CaseProcessingQueue"> | number
    attempts?: IntFilter<"CaseProcessingQueue"> | number
    maxAttempts?: IntFilter<"CaseProcessingQueue"> | number
    error?: StringNullableFilter<"CaseProcessingQueue"> | string | null
    scheduledAt?: DateTimeFilter<"CaseProcessingQueue"> | Date | string
    startedAt?: DateTimeNullableFilter<"CaseProcessingQueue"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CaseProcessingQueue"> | Date | string | null
    case?: XOR<CourtCaseScalarRelationFilter, CourtCaseWhereInput>
  }

  export type CaseProcessingQueueOrderByWithRelationInput = {
    id?: SortOrder
    caseId?: SortOrder
    processType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    error?: SortOrderInput | SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    case?: CourtCaseOrderByWithRelationInput
  }

  export type CaseProcessingQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CaseProcessingQueueWhereInput | CaseProcessingQueueWhereInput[]
    OR?: CaseProcessingQueueWhereInput[]
    NOT?: CaseProcessingQueueWhereInput | CaseProcessingQueueWhereInput[]
    caseId?: StringFilter<"CaseProcessingQueue"> | string
    processType?: EnumProcessingTypeFilter<"CaseProcessingQueue"> | $Enums.ProcessingType
    status?: EnumProcessingStatusFilter<"CaseProcessingQueue"> | $Enums.ProcessingStatus
    priority?: IntFilter<"CaseProcessingQueue"> | number
    attempts?: IntFilter<"CaseProcessingQueue"> | number
    maxAttempts?: IntFilter<"CaseProcessingQueue"> | number
    error?: StringNullableFilter<"CaseProcessingQueue"> | string | null
    scheduledAt?: DateTimeFilter<"CaseProcessingQueue"> | Date | string
    startedAt?: DateTimeNullableFilter<"CaseProcessingQueue"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CaseProcessingQueue"> | Date | string | null
    case?: XOR<CourtCaseScalarRelationFilter, CourtCaseWhereInput>
  }, "id">

  export type CaseProcessingQueueOrderByWithAggregationInput = {
    id?: SortOrder
    caseId?: SortOrder
    processType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    error?: SortOrderInput | SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: CaseProcessingQueueCountOrderByAggregateInput
    _avg?: CaseProcessingQueueAvgOrderByAggregateInput
    _max?: CaseProcessingQueueMaxOrderByAggregateInput
    _min?: CaseProcessingQueueMinOrderByAggregateInput
    _sum?: CaseProcessingQueueSumOrderByAggregateInput
  }

  export type CaseProcessingQueueScalarWhereWithAggregatesInput = {
    AND?: CaseProcessingQueueScalarWhereWithAggregatesInput | CaseProcessingQueueScalarWhereWithAggregatesInput[]
    OR?: CaseProcessingQueueScalarWhereWithAggregatesInput[]
    NOT?: CaseProcessingQueueScalarWhereWithAggregatesInput | CaseProcessingQueueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CaseProcessingQueue"> | string
    caseId?: StringWithAggregatesFilter<"CaseProcessingQueue"> | string
    processType?: EnumProcessingTypeWithAggregatesFilter<"CaseProcessingQueue"> | $Enums.ProcessingType
    status?: EnumProcessingStatusWithAggregatesFilter<"CaseProcessingQueue"> | $Enums.ProcessingStatus
    priority?: IntWithAggregatesFilter<"CaseProcessingQueue"> | number
    attempts?: IntWithAggregatesFilter<"CaseProcessingQueue"> | number
    maxAttempts?: IntWithAggregatesFilter<"CaseProcessingQueue"> | number
    error?: StringNullableWithAggregatesFilter<"CaseProcessingQueue"> | string | null
    scheduledAt?: DateTimeWithAggregatesFilter<"CaseProcessingQueue"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"CaseProcessingQueue"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"CaseProcessingQueue"> | Date | string | null
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    userId?: StringFilter<"SupportTicket"> | string
    title?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: EnumSupportTicketStatusFilter<"SupportTicket"> | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFilter<"SupportTicket"> | $Enums.SupportTicketPriority
    category?: StringNullableFilter<"SupportTicket"> | string | null
    assignedToId?: StringNullableFilter<"SupportTicket"> | string | null
    resolution?: StringNullableFilter<"SupportTicket"> | string | null
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    resolvedBy?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: SupportTicketMessageListRelationFilter
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedTo?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    messages?: SupportTicketMessageOrderByRelationAggregateInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    userId?: StringFilter<"SupportTicket"> | string
    title?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: EnumSupportTicketStatusFilter<"SupportTicket"> | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFilter<"SupportTicket"> | $Enums.SupportTicketPriority
    category?: StringNullableFilter<"SupportTicket"> | string | null
    assignedToId?: StringNullableFilter<"SupportTicket"> | string | null
    resolution?: StringNullableFilter<"SupportTicket"> | string | null
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    resolvedBy?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: SupportTicketMessageListRelationFilter
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrderInput | SortOrder
    assignedToId?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportTicket"> | string
    userId?: StringWithAggregatesFilter<"SupportTicket"> | string
    title?: StringWithAggregatesFilter<"SupportTicket"> | string
    description?: StringWithAggregatesFilter<"SupportTicket"> | string
    status?: EnumSupportTicketStatusWithAggregatesFilter<"SupportTicket"> | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityWithAggregatesFilter<"SupportTicket"> | $Enums.SupportTicketPriority
    category?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    assignedToId?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    resolution?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"SupportTicket"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
  }

  export type SupportTicketMessageWhereInput = {
    AND?: SupportTicketMessageWhereInput | SupportTicketMessageWhereInput[]
    OR?: SupportTicketMessageWhereInput[]
    NOT?: SupportTicketMessageWhereInput | SupportTicketMessageWhereInput[]
    id?: StringFilter<"SupportTicketMessage"> | string
    ticketId?: StringFilter<"SupportTicketMessage"> | string
    userId?: StringFilter<"SupportTicketMessage"> | string
    message?: StringFilter<"SupportTicketMessage"> | string
    isFromAdmin?: BoolFilter<"SupportTicketMessage"> | boolean
    attachments?: StringNullableListFilter<"SupportTicketMessage">
    createdAt?: DateTimeFilter<"SupportTicketMessage"> | Date | string
    ticket?: XOR<SupportTicketScalarRelationFilter, SupportTicketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SupportTicketMessageOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isFromAdmin?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    ticket?: SupportTicketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SupportTicketMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportTicketMessageWhereInput | SupportTicketMessageWhereInput[]
    OR?: SupportTicketMessageWhereInput[]
    NOT?: SupportTicketMessageWhereInput | SupportTicketMessageWhereInput[]
    ticketId?: StringFilter<"SupportTicketMessage"> | string
    userId?: StringFilter<"SupportTicketMessage"> | string
    message?: StringFilter<"SupportTicketMessage"> | string
    isFromAdmin?: BoolFilter<"SupportTicketMessage"> | boolean
    attachments?: StringNullableListFilter<"SupportTicketMessage">
    createdAt?: DateTimeFilter<"SupportTicketMessage"> | Date | string
    ticket?: XOR<SupportTicketScalarRelationFilter, SupportTicketWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SupportTicketMessageOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isFromAdmin?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    _count?: SupportTicketMessageCountOrderByAggregateInput
    _max?: SupportTicketMessageMaxOrderByAggregateInput
    _min?: SupportTicketMessageMinOrderByAggregateInput
  }

  export type SupportTicketMessageScalarWhereWithAggregatesInput = {
    AND?: SupportTicketMessageScalarWhereWithAggregatesInput | SupportTicketMessageScalarWhereWithAggregatesInput[]
    OR?: SupportTicketMessageScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketMessageScalarWhereWithAggregatesInput | SupportTicketMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportTicketMessage"> | string
    ticketId?: StringWithAggregatesFilter<"SupportTicketMessage"> | string
    userId?: StringWithAggregatesFilter<"SupportTicketMessage"> | string
    message?: StringWithAggregatesFilter<"SupportTicketMessage"> | string
    isFromAdmin?: BoolWithAggregatesFilter<"SupportTicketMessage"> | boolean
    attachments?: StringNullableListFilter<"SupportTicketMessage">
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicketMessage"> | Date | string
  }

  export type AdminActionWhereInput = {
    AND?: AdminActionWhereInput | AdminActionWhereInput[]
    OR?: AdminActionWhereInput[]
    NOT?: AdminActionWhereInput | AdminActionWhereInput[]
    id?: StringFilter<"AdminAction"> | string
    adminId?: StringFilter<"AdminAction"> | string
    action?: StringFilter<"AdminAction"> | string
    targetType?: StringFilter<"AdminAction"> | string
    targetId?: StringNullableFilter<"AdminAction"> | string | null
    description?: StringFilter<"AdminAction"> | string
    metadata?: JsonNullableFilter<"AdminAction">
    createdAt?: DateTimeFilter<"AdminAction"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminActionOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type AdminActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminActionWhereInput | AdminActionWhereInput[]
    OR?: AdminActionWhereInput[]
    NOT?: AdminActionWhereInput | AdminActionWhereInput[]
    adminId?: StringFilter<"AdminAction"> | string
    action?: StringFilter<"AdminAction"> | string
    targetType?: StringFilter<"AdminAction"> | string
    targetId?: StringNullableFilter<"AdminAction"> | string | null
    description?: StringFilter<"AdminAction"> | string
    metadata?: JsonNullableFilter<"AdminAction">
    createdAt?: DateTimeFilter<"AdminAction"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AdminActionOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminActionCountOrderByAggregateInput
    _max?: AdminActionMaxOrderByAggregateInput
    _min?: AdminActionMinOrderByAggregateInput
  }

  export type AdminActionScalarWhereWithAggregatesInput = {
    AND?: AdminActionScalarWhereWithAggregatesInput | AdminActionScalarWhereWithAggregatesInput[]
    OR?: AdminActionScalarWhereWithAggregatesInput[]
    NOT?: AdminActionScalarWhereWithAggregatesInput | AdminActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAction"> | string
    adminId?: StringWithAggregatesFilter<"AdminAction"> | string
    action?: StringWithAggregatesFilter<"AdminAction"> | string
    targetType?: StringWithAggregatesFilter<"AdminAction"> | string
    targetId?: StringNullableWithAggregatesFilter<"AdminAction"> | string | null
    description?: StringWithAggregatesFilter<"AdminAction"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AdminAction">
    createdAt?: DateTimeWithAggregatesFilter<"AdminAction"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: StringFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    category?: StringNullableFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    category?: StringNullableFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSetting"> | string
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
    description?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    category?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutAdminInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceUncheckedCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertUncheckedCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutAdminNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUncheckedUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUncheckedUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertCreateInput = {
    id?: string
    title: string
    description: string
    address: string
    city: string
    province?: string
    postalCode?: string | null
    alertType: $Enums.AlertType
    source: $Enums.DataSource
    status?: $Enums.AlertStatus
    priority?: $Enums.Priority
    opportunityScore?: number
    timelineMonths?: number | null
    propertyType?: string | null
    estimatedValue?: number | null
    lotSize?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    courtFileNumber?: string | null
    courtDate?: Date | string | null
    probateNumber?: string | null
    executorName?: string | null
    executorContact?: string | null
    applicationNumber?: string | null
    municipalOffice?: string | null
    applicationDate?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    discoveredAt?: Date | string
    userAlerts?: UserAlertCreateNestedManyWithoutAlertInput
    courtCase?: CourtCaseCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    address: string
    city: string
    province?: string
    postalCode?: string | null
    alertType: $Enums.AlertType
    source: $Enums.DataSource
    status?: $Enums.AlertStatus
    priority?: $Enums.Priority
    opportunityScore?: number
    timelineMonths?: number | null
    propertyType?: string | null
    estimatedValue?: number | null
    lotSize?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    courtFileNumber?: string | null
    courtDate?: Date | string | null
    courtCaseId?: string | null
    probateNumber?: string | null
    executorName?: string | null
    executorContact?: string | null
    applicationNumber?: string | null
    municipalOffice?: string | null
    applicationDate?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    discoveredAt?: Date | string
    userAlerts?: UserAlertUncheckedCreateNestedManyWithoutAlertInput
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    source?: EnumDataSourceFieldUpdateOperationsInput | $Enums.DataSource
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    opportunityScore?: IntFieldUpdateOperationsInput | number
    timelineMonths?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    courtFileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executorName?: NullableStringFieldUpdateOperationsInput | string | null
    executorContact?: NullableStringFieldUpdateOperationsInput | string | null
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    municipalOffice?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAlerts?: UserAlertUpdateManyWithoutAlertNestedInput
    courtCase?: CourtCaseUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    source?: EnumDataSourceFieldUpdateOperationsInput | $Enums.DataSource
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    opportunityScore?: IntFieldUpdateOperationsInput | number
    timelineMonths?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    courtFileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    probateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executorName?: NullableStringFieldUpdateOperationsInput | string | null
    executorContact?: NullableStringFieldUpdateOperationsInput | string | null
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    municipalOffice?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAlerts?: UserAlertUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type AlertCreateManyInput = {
    id?: string
    title: string
    description: string
    address: string
    city: string
    province?: string
    postalCode?: string | null
    alertType: $Enums.AlertType
    source: $Enums.DataSource
    status?: $Enums.AlertStatus
    priority?: $Enums.Priority
    opportunityScore?: number
    timelineMonths?: number | null
    propertyType?: string | null
    estimatedValue?: number | null
    lotSize?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    courtFileNumber?: string | null
    courtDate?: Date | string | null
    courtCaseId?: string | null
    probateNumber?: string | null
    executorName?: string | null
    executorContact?: string | null
    applicationNumber?: string | null
    municipalOffice?: string | null
    applicationDate?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    discoveredAt?: Date | string
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    source?: EnumDataSourceFieldUpdateOperationsInput | $Enums.DataSource
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    opportunityScore?: IntFieldUpdateOperationsInput | number
    timelineMonths?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    courtFileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executorName?: NullableStringFieldUpdateOperationsInput | string | null
    executorContact?: NullableStringFieldUpdateOperationsInput | string | null
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    municipalOffice?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    source?: EnumDataSourceFieldUpdateOperationsInput | $Enums.DataSource
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    opportunityScore?: IntFieldUpdateOperationsInput | number
    timelineMonths?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    courtFileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    probateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executorName?: NullableStringFieldUpdateOperationsInput | string | null
    executorContact?: NullableStringFieldUpdateOperationsInput | string | null
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    municipalOffice?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertCreateInput = {
    id?: string
    isNotified?: boolean
    notifiedAt?: Date | string | null
    isViewed?: boolean
    viewedAt?: Date | string | null
    isBookmarked?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserAlertsInput
    alert: AlertCreateNestedOneWithoutUserAlertsInput
  }

  export type UserAlertUncheckedCreateInput = {
    id?: string
    userId: string
    alertId: string
    isNotified?: boolean
    notifiedAt?: Date | string | null
    isViewed?: boolean
    viewedAt?: Date | string | null
    isBookmarked?: boolean
    createdAt?: Date | string
  }

  export type UserAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBookmarked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserAlertsNestedInput
    alert?: AlertUpdateOneRequiredWithoutUserAlertsNestedInput
  }

  export type UserAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    isNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBookmarked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertCreateManyInput = {
    id?: string
    userId: string
    alertId: string
    isNotified?: boolean
    notifiedAt?: Date | string | null
    isViewed?: boolean
    viewedAt?: Date | string | null
    isBookmarked?: boolean
    createdAt?: Date | string
  }

  export type UserAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBookmarked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    isNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBookmarked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertPreferenceCreateInput = {
    id?: string
    cities?: AlertPreferenceCreatecitiesInput | string[]
    maxDistanceKm?: number
    propertyTypes?: AlertPreferenceCreatepropertyTypesInput | string[]
    minValue?: number | null
    maxValue?: number | null
    minBedrooms?: number | null
    maxBedrooms?: number | null
    alertTypes?: AlertPreferenceCreatealertTypesInput | $Enums.AlertType[]
    minPriority?: $Enums.Priority
    minOpportunityScore?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    maxAlertsPerDay?: number
    quietHoursStart?: string | null
    quietHoursEnd?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAlertPreferencesInput
  }

  export type AlertPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    cities?: AlertPreferenceCreatecitiesInput | string[]
    maxDistanceKm?: number
    propertyTypes?: AlertPreferenceCreatepropertyTypesInput | string[]
    minValue?: number | null
    maxValue?: number | null
    minBedrooms?: number | null
    maxBedrooms?: number | null
    alertTypes?: AlertPreferenceCreatealertTypesInput | $Enums.AlertType[]
    minPriority?: $Enums.Priority
    minOpportunityScore?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    maxAlertsPerDay?: number
    quietHoursStart?: string | null
    quietHoursEnd?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cities?: AlertPreferenceUpdatecitiesInput | string[]
    maxDistanceKm?: IntFieldUpdateOperationsInput | number
    propertyTypes?: AlertPreferenceUpdatepropertyTypesInput | string[]
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    alertTypes?: AlertPreferenceUpdatealertTypesInput | $Enums.AlertType[]
    minPriority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    minOpportunityScore?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxAlertsPerDay?: IntFieldUpdateOperationsInput | number
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAlertPreferencesNestedInput
  }

  export type AlertPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cities?: AlertPreferenceUpdatecitiesInput | string[]
    maxDistanceKm?: IntFieldUpdateOperationsInput | number
    propertyTypes?: AlertPreferenceUpdatepropertyTypesInput | string[]
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    alertTypes?: AlertPreferenceUpdatealertTypesInput | $Enums.AlertType[]
    minPriority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    minOpportunityScore?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxAlertsPerDay?: IntFieldUpdateOperationsInput | number
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertPreferenceCreateManyInput = {
    id?: string
    userId: string
    cities?: AlertPreferenceCreatecitiesInput | string[]
    maxDistanceKm?: number
    propertyTypes?: AlertPreferenceCreatepropertyTypesInput | string[]
    minValue?: number | null
    maxValue?: number | null
    minBedrooms?: number | null
    maxBedrooms?: number | null
    alertTypes?: AlertPreferenceCreatealertTypesInput | $Enums.AlertType[]
    minPriority?: $Enums.Priority
    minOpportunityScore?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    maxAlertsPerDay?: number
    quietHoursStart?: string | null
    quietHoursEnd?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cities?: AlertPreferenceUpdatecitiesInput | string[]
    maxDistanceKm?: IntFieldUpdateOperationsInput | number
    propertyTypes?: AlertPreferenceUpdatepropertyTypesInput | string[]
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    alertTypes?: AlertPreferenceUpdatealertTypesInput | $Enums.AlertType[]
    minPriority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    minOpportunityScore?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxAlertsPerDay?: IntFieldUpdateOperationsInput | number
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cities?: AlertPreferenceUpdatecitiesInput | string[]
    maxDistanceKm?: IntFieldUpdateOperationsInput | number
    propertyTypes?: AlertPreferenceUpdatepropertyTypesInput | string[]
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    alertTypes?: AlertPreferenceUpdatealertTypesInput | $Enums.AlertType[]
    minPriority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    minOpportunityScore?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxAlertsPerDay?: IntFieldUpdateOperationsInput | number
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedPropertyCreateInput = {
    id?: string
    alertId: string
    notes?: string | null
    tags?: SavedPropertyCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSavedPropertiesInput
  }

  export type SavedPropertyUncheckedCreateInput = {
    id?: string
    userId: string
    alertId: string
    notes?: string | null
    tags?: SavedPropertyCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedPropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SavedPropertyUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedPropertiesNestedInput
  }

  export type SavedPropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SavedPropertyUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedPropertyCreateManyInput = {
    id?: string
    userId: string
    alertId: string
    notes?: string | null
    tags?: SavedPropertyCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedPropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SavedPropertyUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedPropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SavedPropertyUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateInput = {
    id?: string
    action: $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EarlyAdopterTokenCreateInput = {
    id?: string
    token?: string
    email: string
    firstName: string
    lastName: string
    phone: string
    company: string
    location: string
    teamSize: string
    monthlyDeals: string
    primaryFocus: string
    currentChallenges?: EarlyAdopterTokenCreatecurrentChallengesInput | string[]
    techComfort: string
    isUsed?: boolean
    usedAt?: Date | string | null
    userId?: string | null
    discountPercent?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EarlyAdopterTokenUncheckedCreateInput = {
    id?: string
    token?: string
    email: string
    firstName: string
    lastName: string
    phone: string
    company: string
    location: string
    teamSize: string
    monthlyDeals: string
    primaryFocus: string
    currentChallenges?: EarlyAdopterTokenCreatecurrentChallengesInput | string[]
    techComfort: string
    isUsed?: boolean
    usedAt?: Date | string | null
    userId?: string | null
    discountPercent?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EarlyAdopterTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    monthlyDeals?: StringFieldUpdateOperationsInput | string
    primaryFocus?: StringFieldUpdateOperationsInput | string
    currentChallenges?: EarlyAdopterTokenUpdatecurrentChallengesInput | string[]
    techComfort?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EarlyAdopterTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    monthlyDeals?: StringFieldUpdateOperationsInput | string
    primaryFocus?: StringFieldUpdateOperationsInput | string
    currentChallenges?: EarlyAdopterTokenUpdatecurrentChallengesInput | string[]
    techComfort?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EarlyAdopterTokenCreateManyInput = {
    id?: string
    token?: string
    email: string
    firstName: string
    lastName: string
    phone: string
    company: string
    location: string
    teamSize: string
    monthlyDeals: string
    primaryFocus: string
    currentChallenges?: EarlyAdopterTokenCreatecurrentChallengesInput | string[]
    techComfort: string
    isUsed?: boolean
    usedAt?: Date | string | null
    userId?: string | null
    discountPercent?: number
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EarlyAdopterTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    monthlyDeals?: StringFieldUpdateOperationsInput | string
    primaryFocus?: StringFieldUpdateOperationsInput | string
    currentChallenges?: EarlyAdopterTokenUpdatecurrentChallengesInput | string[]
    techComfort?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EarlyAdopterTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    monthlyDeals?: StringFieldUpdateOperationsInput | string
    primaryFocus?: StringFieldUpdateOperationsInput | string
    currentChallenges?: EarlyAdopterTokenUpdatecurrentChallengesInput | string[]
    techComfort?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: IntFieldUpdateOperationsInput | number
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtCaseCreateInput = {
    id?: string
    guid: string
    title: string
    neutralCitation?: string | null
    court: $Enums.CourtType
    publishDate: Date | string
    caseUrl: string
    summary?: string | null
    fullText?: string | null
    addresses?: CourtCaseCreateaddressesInput | string[]
    municipalities?: CourtCaseCreatemunicipalitiesInput | string[]
    parties?: CourtCaseCreatepartiesInput | string[]
    statutes?: CourtCaseCreatestatutesInput | string[]
    caseTypes?: CourtCaseCreatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: $Enums.RiskLevel
    isProcessed?: boolean
    nerProcessed?: boolean
    classified?: boolean
    source: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertCreateNestedManyWithoutCourtCaseInput
    processingQueue?: CaseProcessingQueueCreateNestedManyWithoutCaseInput
  }

  export type CourtCaseUncheckedCreateInput = {
    id?: string
    guid: string
    title: string
    neutralCitation?: string | null
    court: $Enums.CourtType
    publishDate: Date | string
    caseUrl: string
    summary?: string | null
    fullText?: string | null
    addresses?: CourtCaseCreateaddressesInput | string[]
    municipalities?: CourtCaseCreatemunicipalitiesInput | string[]
    parties?: CourtCaseCreatepartiesInput | string[]
    statutes?: CourtCaseCreatestatutesInput | string[]
    caseTypes?: CourtCaseCreatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: $Enums.RiskLevel
    isProcessed?: boolean
    nerProcessed?: boolean
    classified?: boolean
    source: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutCourtCaseInput
    processingQueue?: CaseProcessingQueueUncheckedCreateNestedManyWithoutCaseInput
  }

  export type CourtCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    neutralCitation?: NullableStringFieldUpdateOperationsInput | string | null
    court?: EnumCourtTypeFieldUpdateOperationsInput | $Enums.CourtType
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    caseUrl?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    fullText?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CourtCaseUpdateaddressesInput | string[]
    municipalities?: CourtCaseUpdatemunicipalitiesInput | string[]
    parties?: CourtCaseUpdatepartiesInput | string[]
    statutes?: CourtCaseUpdatestatutesInput | string[]
    caseTypes?: CourtCaseUpdatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    nerProcessed?: BoolFieldUpdateOperationsInput | boolean
    classified?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUpdateManyWithoutCourtCaseNestedInput
    processingQueue?: CaseProcessingQueueUpdateManyWithoutCaseNestedInput
  }

  export type CourtCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    neutralCitation?: NullableStringFieldUpdateOperationsInput | string | null
    court?: EnumCourtTypeFieldUpdateOperationsInput | $Enums.CourtType
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    caseUrl?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    fullText?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CourtCaseUpdateaddressesInput | string[]
    municipalities?: CourtCaseUpdatemunicipalitiesInput | string[]
    parties?: CourtCaseUpdatepartiesInput | string[]
    statutes?: CourtCaseUpdatestatutesInput | string[]
    caseTypes?: CourtCaseUpdatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    nerProcessed?: BoolFieldUpdateOperationsInput | boolean
    classified?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutCourtCaseNestedInput
    processingQueue?: CaseProcessingQueueUncheckedUpdateManyWithoutCaseNestedInput
  }

  export type CourtCaseCreateManyInput = {
    id?: string
    guid: string
    title: string
    neutralCitation?: string | null
    court: $Enums.CourtType
    publishDate: Date | string
    caseUrl: string
    summary?: string | null
    fullText?: string | null
    addresses?: CourtCaseCreateaddressesInput | string[]
    municipalities?: CourtCaseCreatemunicipalitiesInput | string[]
    parties?: CourtCaseCreatepartiesInput | string[]
    statutes?: CourtCaseCreatestatutesInput | string[]
    caseTypes?: CourtCaseCreatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: $Enums.RiskLevel
    isProcessed?: boolean
    nerProcessed?: boolean
    classified?: boolean
    source: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourtCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    guid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    neutralCitation?: NullableStringFieldUpdateOperationsInput | string | null
    court?: EnumCourtTypeFieldUpdateOperationsInput | $Enums.CourtType
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    caseUrl?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    fullText?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CourtCaseUpdateaddressesInput | string[]
    municipalities?: CourtCaseUpdatemunicipalitiesInput | string[]
    parties?: CourtCaseUpdatepartiesInput | string[]
    statutes?: CourtCaseUpdatestatutesInput | string[]
    caseTypes?: CourtCaseUpdatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    nerProcessed?: BoolFieldUpdateOperationsInput | boolean
    classified?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    neutralCitation?: NullableStringFieldUpdateOperationsInput | string | null
    court?: EnumCourtTypeFieldUpdateOperationsInput | $Enums.CourtType
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    caseUrl?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    fullText?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CourtCaseUpdateaddressesInput | string[]
    municipalities?: CourtCaseUpdatemunicipalitiesInput | string[]
    parties?: CourtCaseUpdatepartiesInput | string[]
    statutes?: CourtCaseUpdatestatutesInput | string[]
    caseTypes?: CourtCaseUpdatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    nerProcessed?: BoolFieldUpdateOperationsInput | boolean
    classified?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseProcessingQueueCreateInput = {
    id?: string
    processType: $Enums.ProcessingType
    status?: $Enums.ProcessingStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    error?: string | null
    scheduledAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    case: CourtCaseCreateNestedOneWithoutProcessingQueueInput
  }

  export type CaseProcessingQueueUncheckedCreateInput = {
    id?: string
    caseId: string
    processType: $Enums.ProcessingType
    status?: $Enums.ProcessingStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    error?: string | null
    scheduledAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type CaseProcessingQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    processType?: EnumProcessingTypeFieldUpdateOperationsInput | $Enums.ProcessingType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    case?: CourtCaseUpdateOneRequiredWithoutProcessingQueueNestedInput
  }

  export type CaseProcessingQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    processType?: EnumProcessingTypeFieldUpdateOperationsInput | $Enums.ProcessingType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CaseProcessingQueueCreateManyInput = {
    id?: string
    caseId: string
    processType: $Enums.ProcessingType
    status?: $Enums.ProcessingStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    error?: string | null
    scheduledAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type CaseProcessingQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    processType?: EnumProcessingTypeFieldUpdateOperationsInput | $Enums.ProcessingType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CaseProcessingQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    processType?: EnumProcessingTypeFieldUpdateOperationsInput | $Enums.ProcessingType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportTicketCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SupportTicketStatus
    priority?: $Enums.SupportTicketPriority
    category?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    user: UserCreateNestedOneWithoutSupportTicketsInput
    messages?: SupportTicketMessageCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description: string
    status?: $Enums.SupportTicketStatus
    priority?: $Enums.SupportTicketPriority
    category?: string | null
    assignedToId?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: SupportTicketMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicketStatusFieldUpdateOperationsInput | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFieldUpdateOperationsInput | $Enums.SupportTicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    user?: UserUpdateOneRequiredWithoutSupportTicketsNestedInput
    messages?: SupportTicketMessageUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicketStatusFieldUpdateOperationsInput | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFieldUpdateOperationsInput | $Enums.SupportTicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SupportTicketMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketCreateManyInput = {
    id?: string
    userId: string
    title: string
    description: string
    status?: $Enums.SupportTicketStatus
    priority?: $Enums.SupportTicketPriority
    category?: string | null
    assignedToId?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicketStatusFieldUpdateOperationsInput | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFieldUpdateOperationsInput | $Enums.SupportTicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicketStatusFieldUpdateOperationsInput | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFieldUpdateOperationsInput | $Enums.SupportTicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketMessageCreateInput = {
    id?: string
    message: string
    isFromAdmin?: boolean
    attachments?: SupportTicketMessageCreateattachmentsInput | string[]
    createdAt?: Date | string
    ticket: SupportTicketCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutTicketMessagesInput
  }

  export type SupportTicketMessageUncheckedCreateInput = {
    id?: string
    ticketId: string
    userId: string
    message: string
    isFromAdmin?: boolean
    attachments?: SupportTicketMessageCreateattachmentsInput | string[]
    createdAt?: Date | string
  }

  export type SupportTicketMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: SupportTicketMessageUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutTicketMessagesNestedInput
  }

  export type SupportTicketMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: SupportTicketMessageUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketMessageCreateManyInput = {
    id?: string
    ticketId: string
    userId: string
    message: string
    isFromAdmin?: boolean
    attachments?: SupportTicketMessageCreateattachmentsInput | string[]
    createdAt?: Date | string
  }

  export type SupportTicketMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: SupportTicketMessageUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: SupportTicketMessageUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionCreateInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    admin: UserCreateNestedOneWithoutAdminActionsInput
  }

  export type AdminActionUncheckedCreateInput = {
    id?: string
    adminId: string
    action: string
    targetType: string
    targetId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutAdminActionsNestedInput
  }

  export type AdminActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionCreateManyInput = {
    id?: string
    adminId: string
    action: string
    targetType: string
    targetId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AlertPreferenceListRelationFilter = {
    every?: AlertPreferenceWhereInput
    some?: AlertPreferenceWhereInput
    none?: AlertPreferenceWhereInput
  }

  export type UserAlertListRelationFilter = {
    every?: UserAlertWhereInput
    some?: UserAlertWhereInput
    none?: UserAlertWhereInput
  }

  export type SavedPropertyListRelationFilter = {
    every?: SavedPropertyWhereInput
    some?: SavedPropertyWhereInput
    none?: SavedPropertyWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type SupportTicketMessageListRelationFilter = {
    every?: SupportTicketMessageWhereInput
    some?: SupportTicketMessageWhereInput
    none?: SupportTicketMessageWhereInput
  }

  export type AdminActionListRelationFilter = {
    every?: AdminActionWhereInput
    some?: AdminActionWhereInput
    none?: AdminActionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AlertPreferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedPropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    subscriptionTier?: SortOrder
    stripeCustomerId?: SortOrder
    subscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    company?: SortOrder
    location?: SortOrder
    teamSize?: SortOrder
    monthlyDeals?: SortOrder
    primaryFocus?: SortOrder
    techComfort?: SortOrder
    currentChallenges?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    subscriptionTier?: SortOrder
    stripeCustomerId?: SortOrder
    subscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    company?: SortOrder
    location?: SortOrder
    teamSize?: SortOrder
    monthlyDeals?: SortOrder
    primaryFocus?: SortOrder
    techComfort?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    subscriptionTier?: SortOrder
    stripeCustomerId?: SortOrder
    subscriptionId?: SortOrder
    subscriptionStatus?: SortOrder
    company?: SortOrder
    location?: SortOrder
    teamSize?: SortOrder
    monthlyDeals?: SortOrder
    primaryFocus?: SortOrder
    techComfort?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type EnumDataSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.DataSource | EnumDataSourceFieldRefInput<$PrismaModel>
    in?: $Enums.DataSource[] | ListEnumDataSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataSource[] | ListEnumDataSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumDataSourceFilter<$PrismaModel> | $Enums.DataSource
  }

  export type EnumAlertStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusFilter<$PrismaModel> | $Enums.AlertStatus
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CourtCaseNullableScalarRelationFilter = {
    is?: CourtCaseWhereInput | null
    isNot?: CourtCaseWhereInput | null
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    alertType?: SortOrder
    source?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    opportunityScore?: SortOrder
    timelineMonths?: SortOrder
    propertyType?: SortOrder
    estimatedValue?: SortOrder
    lotSize?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    courtFileNumber?: SortOrder
    courtDate?: SortOrder
    courtCaseId?: SortOrder
    probateNumber?: SortOrder
    executorName?: SortOrder
    executorContact?: SortOrder
    applicationNumber?: SortOrder
    municipalOffice?: SortOrder
    applicationDate?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discoveredAt?: SortOrder
  }

  export type AlertAvgOrderByAggregateInput = {
    opportunityScore?: SortOrder
    timelineMonths?: SortOrder
    estimatedValue?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    alertType?: SortOrder
    source?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    opportunityScore?: SortOrder
    timelineMonths?: SortOrder
    propertyType?: SortOrder
    estimatedValue?: SortOrder
    lotSize?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    courtFileNumber?: SortOrder
    courtDate?: SortOrder
    courtCaseId?: SortOrder
    probateNumber?: SortOrder
    executorName?: SortOrder
    executorContact?: SortOrder
    applicationNumber?: SortOrder
    municipalOffice?: SortOrder
    applicationDate?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discoveredAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    postalCode?: SortOrder
    alertType?: SortOrder
    source?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    opportunityScore?: SortOrder
    timelineMonths?: SortOrder
    propertyType?: SortOrder
    estimatedValue?: SortOrder
    lotSize?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    courtFileNumber?: SortOrder
    courtDate?: SortOrder
    courtCaseId?: SortOrder
    probateNumber?: SortOrder
    executorName?: SortOrder
    executorContact?: SortOrder
    applicationNumber?: SortOrder
    municipalOffice?: SortOrder
    applicationDate?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discoveredAt?: SortOrder
  }

  export type AlertSumOrderByAggregateInput = {
    opportunityScore?: SortOrder
    timelineMonths?: SortOrder
    estimatedValue?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type EnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type EnumDataSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataSource | EnumDataSourceFieldRefInput<$PrismaModel>
    in?: $Enums.DataSource[] | ListEnumDataSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataSource[] | ListEnumDataSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumDataSourceWithAggregatesFilter<$PrismaModel> | $Enums.DataSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataSourceFilter<$PrismaModel>
    _max?: NestedEnumDataSourceFilter<$PrismaModel>
  }

  export type EnumAlertStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertStatusFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AlertScalarRelationFilter = {
    is?: AlertWhereInput
    isNot?: AlertWhereInput
  }

  export type UserAlertUserIdAlertIdCompoundUniqueInput = {
    userId: string
    alertId: string
  }

  export type UserAlertCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    alertId?: SortOrder
    isNotified?: SortOrder
    notifiedAt?: SortOrder
    isViewed?: SortOrder
    viewedAt?: SortOrder
    isBookmarked?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    alertId?: SortOrder
    isNotified?: SortOrder
    notifiedAt?: SortOrder
    isViewed?: SortOrder
    viewedAt?: SortOrder
    isBookmarked?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAlertMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    alertId?: SortOrder
    isNotified?: SortOrder
    notifiedAt?: SortOrder
    isViewed?: SortOrder
    viewedAt?: SortOrder
    isBookmarked?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAlertTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AlertPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cities?: SortOrder
    maxDistanceKm?: SortOrder
    propertyTypes?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    minBedrooms?: SortOrder
    maxBedrooms?: SortOrder
    alertTypes?: SortOrder
    minPriority?: SortOrder
    minOpportunityScore?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    maxAlertsPerDay?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertPreferenceAvgOrderByAggregateInput = {
    maxDistanceKm?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    minBedrooms?: SortOrder
    maxBedrooms?: SortOrder
    minOpportunityScore?: SortOrder
    maxAlertsPerDay?: SortOrder
  }

  export type AlertPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    maxDistanceKm?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    minBedrooms?: SortOrder
    maxBedrooms?: SortOrder
    minPriority?: SortOrder
    minOpportunityScore?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    maxAlertsPerDay?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    maxDistanceKm?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    minBedrooms?: SortOrder
    maxBedrooms?: SortOrder
    minPriority?: SortOrder
    minOpportunityScore?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    pushNotifications?: SortOrder
    maxAlertsPerDay?: SortOrder
    quietHoursStart?: SortOrder
    quietHoursEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertPreferenceSumOrderByAggregateInput = {
    maxDistanceKm?: SortOrder
    minValue?: SortOrder
    maxValue?: SortOrder
    minBedrooms?: SortOrder
    maxBedrooms?: SortOrder
    minOpportunityScore?: SortOrder
    maxAlertsPerDay?: SortOrder
  }

  export type SavedPropertyUserIdAlertIdCompoundUniqueInput = {
    userId: string
    alertId: string
  }

  export type SavedPropertyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    alertId?: SortOrder
    notes?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedPropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    alertId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SavedPropertyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    alertId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EarlyAdopterTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    location?: SortOrder
    teamSize?: SortOrder
    monthlyDeals?: SortOrder
    primaryFocus?: SortOrder
    currentChallenges?: SortOrder
    techComfort?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrder
    userId?: SortOrder
    discountPercent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EarlyAdopterTokenAvgOrderByAggregateInput = {
    discountPercent?: SortOrder
  }

  export type EarlyAdopterTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    location?: SortOrder
    teamSize?: SortOrder
    monthlyDeals?: SortOrder
    primaryFocus?: SortOrder
    techComfort?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrder
    userId?: SortOrder
    discountPercent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EarlyAdopterTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    location?: SortOrder
    teamSize?: SortOrder
    monthlyDeals?: SortOrder
    primaryFocus?: SortOrder
    techComfort?: SortOrder
    isUsed?: SortOrder
    usedAt?: SortOrder
    userId?: SortOrder
    discountPercent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EarlyAdopterTokenSumOrderByAggregateInput = {
    discountPercent?: SortOrder
  }

  export type EnumCourtTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourtType | EnumCourtTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourtType[] | ListEnumCourtTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourtType[] | ListEnumCourtTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourtTypeFilter<$PrismaModel> | $Enums.CourtType
  }

  export type EnumRealEstateCaseTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.RealEstateCaseType[] | ListEnumRealEstateCaseTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.RealEstateCaseType | EnumRealEstateCaseTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.RealEstateCaseType[] | ListEnumRealEstateCaseTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.RealEstateCaseType[] | ListEnumRealEstateCaseTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type CaseProcessingQueueListRelationFilter = {
    every?: CaseProcessingQueueWhereInput
    some?: CaseProcessingQueueWhereInput
    none?: CaseProcessingQueueWhereInput
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaseProcessingQueueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourtCaseCountOrderByAggregateInput = {
    id?: SortOrder
    guid?: SortOrder
    title?: SortOrder
    neutralCitation?: SortOrder
    court?: SortOrder
    publishDate?: SortOrder
    caseUrl?: SortOrder
    summary?: SortOrder
    fullText?: SortOrder
    addresses?: SortOrder
    municipalities?: SortOrder
    parties?: SortOrder
    statutes?: SortOrder
    caseTypes?: SortOrder
    riskLevel?: SortOrder
    isProcessed?: SortOrder
    nerProcessed?: SortOrder
    classified?: SortOrder
    source?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourtCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    guid?: SortOrder
    title?: SortOrder
    neutralCitation?: SortOrder
    court?: SortOrder
    publishDate?: SortOrder
    caseUrl?: SortOrder
    summary?: SortOrder
    fullText?: SortOrder
    riskLevel?: SortOrder
    isProcessed?: SortOrder
    nerProcessed?: SortOrder
    classified?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourtCaseMinOrderByAggregateInput = {
    id?: SortOrder
    guid?: SortOrder
    title?: SortOrder
    neutralCitation?: SortOrder
    court?: SortOrder
    publishDate?: SortOrder
    caseUrl?: SortOrder
    summary?: SortOrder
    fullText?: SortOrder
    riskLevel?: SortOrder
    isProcessed?: SortOrder
    nerProcessed?: SortOrder
    classified?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCourtTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourtType | EnumCourtTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourtType[] | ListEnumCourtTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourtType[] | ListEnumCourtTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourtTypeWithAggregatesFilter<$PrismaModel> | $Enums.CourtType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourtTypeFilter<$PrismaModel>
    _max?: NestedEnumCourtTypeFilter<$PrismaModel>
  }

  export type EnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }

  export type EnumProcessingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingType | EnumProcessingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingType[] | ListEnumProcessingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingType[] | ListEnumProcessingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingTypeFilter<$PrismaModel> | $Enums.ProcessingType
  }

  export type EnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }

  export type CourtCaseScalarRelationFilter = {
    is?: CourtCaseWhereInput
    isNot?: CourtCaseWhereInput
  }

  export type CaseProcessingQueueCountOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    processType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    error?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CaseProcessingQueueAvgOrderByAggregateInput = {
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type CaseProcessingQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    processType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    error?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CaseProcessingQueueMinOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    processType?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
    error?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type CaseProcessingQueueSumOrderByAggregateInput = {
    priority?: SortOrder
    attempts?: SortOrder
    maxAttempts?: SortOrder
  }

  export type EnumProcessingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingType | EnumProcessingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingType[] | ListEnumProcessingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingType[] | ListEnumProcessingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingTypeFilter<$PrismaModel>
    _max?: NestedEnumProcessingTypeFilter<$PrismaModel>
  }

  export type EnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }

  export type EnumSupportTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportTicketStatus | EnumSupportTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportTicketStatus[] | ListEnumSupportTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportTicketStatus[] | ListEnumSupportTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportTicketStatusFilter<$PrismaModel> | $Enums.SupportTicketStatus
  }

  export type EnumSupportTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportTicketPriority | EnumSupportTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.SupportTicketPriority[] | ListEnumSupportTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportTicketPriority[] | ListEnumSupportTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportTicketPriorityFilter<$PrismaModel> | $Enums.SupportTicketPriority
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    assignedToId?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    assignedToId?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    assignedToId?: SortOrder
    resolution?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSupportTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportTicketStatus | EnumSupportTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportTicketStatus[] | ListEnumSupportTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportTicketStatus[] | ListEnumSupportTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.SupportTicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupportTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumSupportTicketStatusFilter<$PrismaModel>
  }

  export type EnumSupportTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportTicketPriority | EnumSupportTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.SupportTicketPriority[] | ListEnumSupportTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportTicketPriority[] | ListEnumSupportTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.SupportTicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupportTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumSupportTicketPriorityFilter<$PrismaModel>
  }

  export type SupportTicketScalarRelationFilter = {
    is?: SupportTicketWhereInput
    isNot?: SupportTicketWhereInput
  }

  export type SupportTicketMessageCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isFromAdmin?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
  }

  export type SupportTicketMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isFromAdmin?: SortOrder
    createdAt?: SortOrder
  }

  export type SupportTicketMessageMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isFromAdmin?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminActionCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminActionMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminActionMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreatecurrentChallengesInput = {
    set: string[]
  }

  export type AlertPreferenceCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertPreferenceCreateWithoutUserInput, AlertPreferenceUncheckedCreateWithoutUserInput> | AlertPreferenceCreateWithoutUserInput[] | AlertPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertPreferenceCreateOrConnectWithoutUserInput | AlertPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: AlertPreferenceCreateManyUserInputEnvelope
    connect?: AlertPreferenceWhereUniqueInput | AlertPreferenceWhereUniqueInput[]
  }

  export type UserAlertCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAlertCreateWithoutUserInput, UserAlertUncheckedCreateWithoutUserInput> | UserAlertCreateWithoutUserInput[] | UserAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutUserInput | UserAlertCreateOrConnectWithoutUserInput[]
    createMany?: UserAlertCreateManyUserInputEnvelope
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
  }

  export type SavedPropertyCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedPropertyCreateWithoutUserInput, SavedPropertyUncheckedCreateWithoutUserInput> | SavedPropertyCreateWithoutUserInput[] | SavedPropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedPropertyCreateOrConnectWithoutUserInput | SavedPropertyCreateOrConnectWithoutUserInput[]
    createMany?: SavedPropertyCreateManyUserInputEnvelope
    connect?: SavedPropertyWhereUniqueInput | SavedPropertyWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportTicketMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketMessageCreateWithoutUserInput, SupportTicketMessageUncheckedCreateWithoutUserInput> | SupportTicketMessageCreateWithoutUserInput[] | SupportTicketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketMessageCreateOrConnectWithoutUserInput | SupportTicketMessageCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketMessageCreateManyUserInputEnvelope
    connect?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
  }

  export type AdminActionCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminActionCreateWithoutAdminInput, AdminActionUncheckedCreateWithoutAdminInput> | AdminActionCreateWithoutAdminInput[] | AdminActionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutAdminInput | AdminActionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminActionCreateManyAdminInputEnvelope
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
  }

  export type AlertPreferenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertPreferenceCreateWithoutUserInput, AlertPreferenceUncheckedCreateWithoutUserInput> | AlertPreferenceCreateWithoutUserInput[] | AlertPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertPreferenceCreateOrConnectWithoutUserInput | AlertPreferenceCreateOrConnectWithoutUserInput[]
    createMany?: AlertPreferenceCreateManyUserInputEnvelope
    connect?: AlertPreferenceWhereUniqueInput | AlertPreferenceWhereUniqueInput[]
  }

  export type UserAlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAlertCreateWithoutUserInput, UserAlertUncheckedCreateWithoutUserInput> | UserAlertCreateWithoutUserInput[] | UserAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutUserInput | UserAlertCreateOrConnectWithoutUserInput[]
    createMany?: UserAlertCreateManyUserInputEnvelope
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
  }

  export type SavedPropertyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedPropertyCreateWithoutUserInput, SavedPropertyUncheckedCreateWithoutUserInput> | SavedPropertyCreateWithoutUserInput[] | SavedPropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedPropertyCreateOrConnectWithoutUserInput | SavedPropertyCreateOrConnectWithoutUserInput[]
    createMany?: SavedPropertyCreateManyUserInputEnvelope
    connect?: SavedPropertyWhereUniqueInput | SavedPropertyWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type SupportTicketMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketMessageCreateWithoutUserInput, SupportTicketMessageUncheckedCreateWithoutUserInput> | SupportTicketMessageCreateWithoutUserInput[] | SupportTicketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketMessageCreateOrConnectWithoutUserInput | SupportTicketMessageCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketMessageCreateManyUserInputEnvelope
    connect?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
  }

  export type AdminActionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminActionCreateWithoutAdminInput, AdminActionUncheckedCreateWithoutAdminInput> | AdminActionCreateWithoutAdminInput[] | AdminActionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutAdminInput | AdminActionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminActionCreateManyAdminInputEnvelope
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type UserUpdatecurrentChallengesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AlertPreferenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertPreferenceCreateWithoutUserInput, AlertPreferenceUncheckedCreateWithoutUserInput> | AlertPreferenceCreateWithoutUserInput[] | AlertPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertPreferenceCreateOrConnectWithoutUserInput | AlertPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: AlertPreferenceUpsertWithWhereUniqueWithoutUserInput | AlertPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertPreferenceCreateManyUserInputEnvelope
    set?: AlertPreferenceWhereUniqueInput | AlertPreferenceWhereUniqueInput[]
    disconnect?: AlertPreferenceWhereUniqueInput | AlertPreferenceWhereUniqueInput[]
    delete?: AlertPreferenceWhereUniqueInput | AlertPreferenceWhereUniqueInput[]
    connect?: AlertPreferenceWhereUniqueInput | AlertPreferenceWhereUniqueInput[]
    update?: AlertPreferenceUpdateWithWhereUniqueWithoutUserInput | AlertPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertPreferenceUpdateManyWithWhereWithoutUserInput | AlertPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertPreferenceScalarWhereInput | AlertPreferenceScalarWhereInput[]
  }

  export type UserAlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAlertCreateWithoutUserInput, UserAlertUncheckedCreateWithoutUserInput> | UserAlertCreateWithoutUserInput[] | UserAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutUserInput | UserAlertCreateOrConnectWithoutUserInput[]
    upsert?: UserAlertUpsertWithWhereUniqueWithoutUserInput | UserAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAlertCreateManyUserInputEnvelope
    set?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    disconnect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    delete?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    update?: UserAlertUpdateWithWhereUniqueWithoutUserInput | UserAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAlertUpdateManyWithWhereWithoutUserInput | UserAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAlertScalarWhereInput | UserAlertScalarWhereInput[]
  }

  export type SavedPropertyUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedPropertyCreateWithoutUserInput, SavedPropertyUncheckedCreateWithoutUserInput> | SavedPropertyCreateWithoutUserInput[] | SavedPropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedPropertyCreateOrConnectWithoutUserInput | SavedPropertyCreateOrConnectWithoutUserInput[]
    upsert?: SavedPropertyUpsertWithWhereUniqueWithoutUserInput | SavedPropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedPropertyCreateManyUserInputEnvelope
    set?: SavedPropertyWhereUniqueInput | SavedPropertyWhereUniqueInput[]
    disconnect?: SavedPropertyWhereUniqueInput | SavedPropertyWhereUniqueInput[]
    delete?: SavedPropertyWhereUniqueInput | SavedPropertyWhereUniqueInput[]
    connect?: SavedPropertyWhereUniqueInput | SavedPropertyWhereUniqueInput[]
    update?: SavedPropertyUpdateWithWhereUniqueWithoutUserInput | SavedPropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedPropertyUpdateManyWithWhereWithoutUserInput | SavedPropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedPropertyScalarWhereInput | SavedPropertyScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput | SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput | SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutAssignedToInput | SupportTicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportTicketMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketMessageCreateWithoutUserInput, SupportTicketMessageUncheckedCreateWithoutUserInput> | SupportTicketMessageCreateWithoutUserInput[] | SupportTicketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketMessageCreateOrConnectWithoutUserInput | SupportTicketMessageCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketMessageUpsertWithWhereUniqueWithoutUserInput | SupportTicketMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketMessageCreateManyUserInputEnvelope
    set?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    disconnect?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    delete?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    connect?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    update?: SupportTicketMessageUpdateWithWhereUniqueWithoutUserInput | SupportTicketMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketMessageUpdateManyWithWhereWithoutUserInput | SupportTicketMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketMessageScalarWhereInput | SupportTicketMessageScalarWhereInput[]
  }

  export type AdminActionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminActionCreateWithoutAdminInput, AdminActionUncheckedCreateWithoutAdminInput> | AdminActionCreateWithoutAdminInput[] | AdminActionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutAdminInput | AdminActionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminActionUpsertWithWhereUniqueWithoutAdminInput | AdminActionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminActionCreateManyAdminInputEnvelope
    set?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    disconnect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    delete?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    update?: AdminActionUpdateWithWhereUniqueWithoutAdminInput | AdminActionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminActionUpdateManyWithWhereWithoutAdminInput | AdminActionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminActionScalarWhereInput | AdminActionScalarWhereInput[]
  }

  export type AlertPreferenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertPreferenceCreateWithoutUserInput, AlertPreferenceUncheckedCreateWithoutUserInput> | AlertPreferenceCreateWithoutUserInput[] | AlertPreferenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertPreferenceCreateOrConnectWithoutUserInput | AlertPreferenceCreateOrConnectWithoutUserInput[]
    upsert?: AlertPreferenceUpsertWithWhereUniqueWithoutUserInput | AlertPreferenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertPreferenceCreateManyUserInputEnvelope
    set?: AlertPreferenceWhereUniqueInput | AlertPreferenceWhereUniqueInput[]
    disconnect?: AlertPreferenceWhereUniqueInput | AlertPreferenceWhereUniqueInput[]
    delete?: AlertPreferenceWhereUniqueInput | AlertPreferenceWhereUniqueInput[]
    connect?: AlertPreferenceWhereUniqueInput | AlertPreferenceWhereUniqueInput[]
    update?: AlertPreferenceUpdateWithWhereUniqueWithoutUserInput | AlertPreferenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertPreferenceUpdateManyWithWhereWithoutUserInput | AlertPreferenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertPreferenceScalarWhereInput | AlertPreferenceScalarWhereInput[]
  }

  export type UserAlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAlertCreateWithoutUserInput, UserAlertUncheckedCreateWithoutUserInput> | UserAlertCreateWithoutUserInput[] | UserAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutUserInput | UserAlertCreateOrConnectWithoutUserInput[]
    upsert?: UserAlertUpsertWithWhereUniqueWithoutUserInput | UserAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAlertCreateManyUserInputEnvelope
    set?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    disconnect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    delete?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    update?: UserAlertUpdateWithWhereUniqueWithoutUserInput | UserAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAlertUpdateManyWithWhereWithoutUserInput | UserAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAlertScalarWhereInput | UserAlertScalarWhereInput[]
  }

  export type SavedPropertyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedPropertyCreateWithoutUserInput, SavedPropertyUncheckedCreateWithoutUserInput> | SavedPropertyCreateWithoutUserInput[] | SavedPropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedPropertyCreateOrConnectWithoutUserInput | SavedPropertyCreateOrConnectWithoutUserInput[]
    upsert?: SavedPropertyUpsertWithWhereUniqueWithoutUserInput | SavedPropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedPropertyCreateManyUserInputEnvelope
    set?: SavedPropertyWhereUniqueInput | SavedPropertyWhereUniqueInput[]
    disconnect?: SavedPropertyWhereUniqueInput | SavedPropertyWhereUniqueInput[]
    delete?: SavedPropertyWhereUniqueInput | SavedPropertyWhereUniqueInput[]
    connect?: SavedPropertyWhereUniqueInput | SavedPropertyWhereUniqueInput[]
    update?: SavedPropertyUpdateWithWhereUniqueWithoutUserInput | SavedPropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedPropertyUpdateManyWithWhereWithoutUserInput | SavedPropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedPropertyScalarWhereInput | SavedPropertyScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput | SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput | SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutAssignedToInput | SupportTicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type SupportTicketMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketMessageCreateWithoutUserInput, SupportTicketMessageUncheckedCreateWithoutUserInput> | SupportTicketMessageCreateWithoutUserInput[] | SupportTicketMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketMessageCreateOrConnectWithoutUserInput | SupportTicketMessageCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketMessageUpsertWithWhereUniqueWithoutUserInput | SupportTicketMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketMessageCreateManyUserInputEnvelope
    set?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    disconnect?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    delete?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    connect?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    update?: SupportTicketMessageUpdateWithWhereUniqueWithoutUserInput | SupportTicketMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketMessageUpdateManyWithWhereWithoutUserInput | SupportTicketMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketMessageScalarWhereInput | SupportTicketMessageScalarWhereInput[]
  }

  export type AdminActionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminActionCreateWithoutAdminInput, AdminActionUncheckedCreateWithoutAdminInput> | AdminActionCreateWithoutAdminInput[] | AdminActionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActionCreateOrConnectWithoutAdminInput | AdminActionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminActionUpsertWithWhereUniqueWithoutAdminInput | AdminActionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminActionCreateManyAdminInputEnvelope
    set?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    disconnect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    delete?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    connect?: AdminActionWhereUniqueInput | AdminActionWhereUniqueInput[]
    update?: AdminActionUpdateWithWhereUniqueWithoutAdminInput | AdminActionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminActionUpdateManyWithWhereWithoutAdminInput | AdminActionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminActionScalarWhereInput | AdminActionScalarWhereInput[]
  }

  export type UserAlertCreateNestedManyWithoutAlertInput = {
    create?: XOR<UserAlertCreateWithoutAlertInput, UserAlertUncheckedCreateWithoutAlertInput> | UserAlertCreateWithoutAlertInput[] | UserAlertUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutAlertInput | UserAlertCreateOrConnectWithoutAlertInput[]
    createMany?: UserAlertCreateManyAlertInputEnvelope
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
  }

  export type CourtCaseCreateNestedOneWithoutAlertsInput = {
    create?: XOR<CourtCaseCreateWithoutAlertsInput, CourtCaseUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: CourtCaseCreateOrConnectWithoutAlertsInput
    connect?: CourtCaseWhereUniqueInput
  }

  export type UserAlertUncheckedCreateNestedManyWithoutAlertInput = {
    create?: XOR<UserAlertCreateWithoutAlertInput, UserAlertUncheckedCreateWithoutAlertInput> | UserAlertCreateWithoutAlertInput[] | UserAlertUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutAlertInput | UserAlertCreateOrConnectWithoutAlertInput[]
    createMany?: UserAlertCreateManyAlertInputEnvelope
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
  }

  export type EnumAlertTypeFieldUpdateOperationsInput = {
    set?: $Enums.AlertType
  }

  export type EnumDataSourceFieldUpdateOperationsInput = {
    set?: $Enums.DataSource
  }

  export type EnumAlertStatusFieldUpdateOperationsInput = {
    set?: $Enums.AlertStatus
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserAlertUpdateManyWithoutAlertNestedInput = {
    create?: XOR<UserAlertCreateWithoutAlertInput, UserAlertUncheckedCreateWithoutAlertInput> | UserAlertCreateWithoutAlertInput[] | UserAlertUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutAlertInput | UserAlertCreateOrConnectWithoutAlertInput[]
    upsert?: UserAlertUpsertWithWhereUniqueWithoutAlertInput | UserAlertUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: UserAlertCreateManyAlertInputEnvelope
    set?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    disconnect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    delete?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    update?: UserAlertUpdateWithWhereUniqueWithoutAlertInput | UserAlertUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: UserAlertUpdateManyWithWhereWithoutAlertInput | UserAlertUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: UserAlertScalarWhereInput | UserAlertScalarWhereInput[]
  }

  export type CourtCaseUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<CourtCaseCreateWithoutAlertsInput, CourtCaseUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: CourtCaseCreateOrConnectWithoutAlertsInput
    upsert?: CourtCaseUpsertWithoutAlertsInput
    disconnect?: CourtCaseWhereInput | boolean
    delete?: CourtCaseWhereInput | boolean
    connect?: CourtCaseWhereUniqueInput
    update?: XOR<XOR<CourtCaseUpdateToOneWithWhereWithoutAlertsInput, CourtCaseUpdateWithoutAlertsInput>, CourtCaseUncheckedUpdateWithoutAlertsInput>
  }

  export type UserAlertUncheckedUpdateManyWithoutAlertNestedInput = {
    create?: XOR<UserAlertCreateWithoutAlertInput, UserAlertUncheckedCreateWithoutAlertInput> | UserAlertCreateWithoutAlertInput[] | UserAlertUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: UserAlertCreateOrConnectWithoutAlertInput | UserAlertCreateOrConnectWithoutAlertInput[]
    upsert?: UserAlertUpsertWithWhereUniqueWithoutAlertInput | UserAlertUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: UserAlertCreateManyAlertInputEnvelope
    set?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    disconnect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    delete?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    connect?: UserAlertWhereUniqueInput | UserAlertWhereUniqueInput[]
    update?: UserAlertUpdateWithWhereUniqueWithoutAlertInput | UserAlertUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: UserAlertUpdateManyWithWhereWithoutAlertInput | UserAlertUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: UserAlertScalarWhereInput | UserAlertScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserAlertsInput = {
    create?: XOR<UserCreateWithoutUserAlertsInput, UserUncheckedCreateWithoutUserAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type AlertCreateNestedOneWithoutUserAlertsInput = {
    create?: XOR<AlertCreateWithoutUserAlertsInput, AlertUncheckedCreateWithoutUserAlertsInput>
    connectOrCreate?: AlertCreateOrConnectWithoutUserAlertsInput
    connect?: AlertWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserAlertsNestedInput = {
    create?: XOR<UserCreateWithoutUserAlertsInput, UserUncheckedCreateWithoutUserAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAlertsInput
    upsert?: UserUpsertWithoutUserAlertsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserAlertsInput, UserUpdateWithoutUserAlertsInput>, UserUncheckedUpdateWithoutUserAlertsInput>
  }

  export type AlertUpdateOneRequiredWithoutUserAlertsNestedInput = {
    create?: XOR<AlertCreateWithoutUserAlertsInput, AlertUncheckedCreateWithoutUserAlertsInput>
    connectOrCreate?: AlertCreateOrConnectWithoutUserAlertsInput
    upsert?: AlertUpsertWithoutUserAlertsInput
    connect?: AlertWhereUniqueInput
    update?: XOR<XOR<AlertUpdateToOneWithWhereWithoutUserAlertsInput, AlertUpdateWithoutUserAlertsInput>, AlertUncheckedUpdateWithoutUserAlertsInput>
  }

  export type AlertPreferenceCreatecitiesInput = {
    set: string[]
  }

  export type AlertPreferenceCreatepropertyTypesInput = {
    set: string[]
  }

  export type AlertPreferenceCreatealertTypesInput = {
    set: $Enums.AlertType[]
  }

  export type UserCreateNestedOneWithoutAlertPreferencesInput = {
    create?: XOR<UserCreateWithoutAlertPreferencesInput, UserUncheckedCreateWithoutAlertPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type AlertPreferenceUpdatecitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AlertPreferenceUpdatepropertyTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AlertPreferenceUpdatealertTypesInput = {
    set?: $Enums.AlertType[]
    push?: $Enums.AlertType | $Enums.AlertType[]
  }

  export type UserUpdateOneRequiredWithoutAlertPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutAlertPreferencesInput, UserUncheckedCreateWithoutAlertPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertPreferencesInput
    upsert?: UserUpsertWithoutAlertPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlertPreferencesInput, UserUpdateWithoutAlertPreferencesInput>, UserUncheckedUpdateWithoutAlertPreferencesInput>
  }

  export type SavedPropertyCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSavedPropertiesInput = {
    create?: XOR<UserCreateWithoutSavedPropertiesInput, UserUncheckedCreateWithoutSavedPropertiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedPropertiesInput
    connect?: UserWhereUniqueInput
  }

  export type SavedPropertyUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSavedPropertiesNestedInput = {
    create?: XOR<UserCreateWithoutSavedPropertiesInput, UserUncheckedCreateWithoutSavedPropertiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedPropertiesInput
    upsert?: UserUpsertWithoutSavedPropertiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedPropertiesInput, UserUpdateWithoutSavedPropertiesInput>, UserUncheckedUpdateWithoutSavedPropertiesInput>
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type UserUpdateOneWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type EarlyAdopterTokenCreatecurrentChallengesInput = {
    set: string[]
  }

  export type EarlyAdopterTokenUpdatecurrentChallengesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourtCaseCreateaddressesInput = {
    set: string[]
  }

  export type CourtCaseCreatemunicipalitiesInput = {
    set: string[]
  }

  export type CourtCaseCreatepartiesInput = {
    set: string[]
  }

  export type CourtCaseCreatestatutesInput = {
    set: string[]
  }

  export type CourtCaseCreatecaseTypesInput = {
    set: $Enums.RealEstateCaseType[]
  }

  export type AlertCreateNestedManyWithoutCourtCaseInput = {
    create?: XOR<AlertCreateWithoutCourtCaseInput, AlertUncheckedCreateWithoutCourtCaseInput> | AlertCreateWithoutCourtCaseInput[] | AlertUncheckedCreateWithoutCourtCaseInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCourtCaseInput | AlertCreateOrConnectWithoutCourtCaseInput[]
    createMany?: AlertCreateManyCourtCaseInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type CaseProcessingQueueCreateNestedManyWithoutCaseInput = {
    create?: XOR<CaseProcessingQueueCreateWithoutCaseInput, CaseProcessingQueueUncheckedCreateWithoutCaseInput> | CaseProcessingQueueCreateWithoutCaseInput[] | CaseProcessingQueueUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseProcessingQueueCreateOrConnectWithoutCaseInput | CaseProcessingQueueCreateOrConnectWithoutCaseInput[]
    createMany?: CaseProcessingQueueCreateManyCaseInputEnvelope
    connect?: CaseProcessingQueueWhereUniqueInput | CaseProcessingQueueWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutCourtCaseInput = {
    create?: XOR<AlertCreateWithoutCourtCaseInput, AlertUncheckedCreateWithoutCourtCaseInput> | AlertCreateWithoutCourtCaseInput[] | AlertUncheckedCreateWithoutCourtCaseInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCourtCaseInput | AlertCreateOrConnectWithoutCourtCaseInput[]
    createMany?: AlertCreateManyCourtCaseInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type CaseProcessingQueueUncheckedCreateNestedManyWithoutCaseInput = {
    create?: XOR<CaseProcessingQueueCreateWithoutCaseInput, CaseProcessingQueueUncheckedCreateWithoutCaseInput> | CaseProcessingQueueCreateWithoutCaseInput[] | CaseProcessingQueueUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseProcessingQueueCreateOrConnectWithoutCaseInput | CaseProcessingQueueCreateOrConnectWithoutCaseInput[]
    createMany?: CaseProcessingQueueCreateManyCaseInputEnvelope
    connect?: CaseProcessingQueueWhereUniqueInput | CaseProcessingQueueWhereUniqueInput[]
  }

  export type EnumCourtTypeFieldUpdateOperationsInput = {
    set?: $Enums.CourtType
  }

  export type CourtCaseUpdateaddressesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourtCaseUpdatemunicipalitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourtCaseUpdatepartiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourtCaseUpdatestatutesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourtCaseUpdatecaseTypesInput = {
    set?: $Enums.RealEstateCaseType[]
    push?: $Enums.RealEstateCaseType | $Enums.RealEstateCaseType[]
  }

  export type EnumRiskLevelFieldUpdateOperationsInput = {
    set?: $Enums.RiskLevel
  }

  export type AlertUpdateManyWithoutCourtCaseNestedInput = {
    create?: XOR<AlertCreateWithoutCourtCaseInput, AlertUncheckedCreateWithoutCourtCaseInput> | AlertCreateWithoutCourtCaseInput[] | AlertUncheckedCreateWithoutCourtCaseInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCourtCaseInput | AlertCreateOrConnectWithoutCourtCaseInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutCourtCaseInput | AlertUpsertWithWhereUniqueWithoutCourtCaseInput[]
    createMany?: AlertCreateManyCourtCaseInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutCourtCaseInput | AlertUpdateWithWhereUniqueWithoutCourtCaseInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutCourtCaseInput | AlertUpdateManyWithWhereWithoutCourtCaseInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type CaseProcessingQueueUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CaseProcessingQueueCreateWithoutCaseInput, CaseProcessingQueueUncheckedCreateWithoutCaseInput> | CaseProcessingQueueCreateWithoutCaseInput[] | CaseProcessingQueueUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseProcessingQueueCreateOrConnectWithoutCaseInput | CaseProcessingQueueCreateOrConnectWithoutCaseInput[]
    upsert?: CaseProcessingQueueUpsertWithWhereUniqueWithoutCaseInput | CaseProcessingQueueUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CaseProcessingQueueCreateManyCaseInputEnvelope
    set?: CaseProcessingQueueWhereUniqueInput | CaseProcessingQueueWhereUniqueInput[]
    disconnect?: CaseProcessingQueueWhereUniqueInput | CaseProcessingQueueWhereUniqueInput[]
    delete?: CaseProcessingQueueWhereUniqueInput | CaseProcessingQueueWhereUniqueInput[]
    connect?: CaseProcessingQueueWhereUniqueInput | CaseProcessingQueueWhereUniqueInput[]
    update?: CaseProcessingQueueUpdateWithWhereUniqueWithoutCaseInput | CaseProcessingQueueUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CaseProcessingQueueUpdateManyWithWhereWithoutCaseInput | CaseProcessingQueueUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CaseProcessingQueueScalarWhereInput | CaseProcessingQueueScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutCourtCaseNestedInput = {
    create?: XOR<AlertCreateWithoutCourtCaseInput, AlertUncheckedCreateWithoutCourtCaseInput> | AlertCreateWithoutCourtCaseInput[] | AlertUncheckedCreateWithoutCourtCaseInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutCourtCaseInput | AlertCreateOrConnectWithoutCourtCaseInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutCourtCaseInput | AlertUpsertWithWhereUniqueWithoutCourtCaseInput[]
    createMany?: AlertCreateManyCourtCaseInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutCourtCaseInput | AlertUpdateWithWhereUniqueWithoutCourtCaseInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutCourtCaseInput | AlertUpdateManyWithWhereWithoutCourtCaseInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type CaseProcessingQueueUncheckedUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CaseProcessingQueueCreateWithoutCaseInput, CaseProcessingQueueUncheckedCreateWithoutCaseInput> | CaseProcessingQueueCreateWithoutCaseInput[] | CaseProcessingQueueUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseProcessingQueueCreateOrConnectWithoutCaseInput | CaseProcessingQueueCreateOrConnectWithoutCaseInput[]
    upsert?: CaseProcessingQueueUpsertWithWhereUniqueWithoutCaseInput | CaseProcessingQueueUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CaseProcessingQueueCreateManyCaseInputEnvelope
    set?: CaseProcessingQueueWhereUniqueInput | CaseProcessingQueueWhereUniqueInput[]
    disconnect?: CaseProcessingQueueWhereUniqueInput | CaseProcessingQueueWhereUniqueInput[]
    delete?: CaseProcessingQueueWhereUniqueInput | CaseProcessingQueueWhereUniqueInput[]
    connect?: CaseProcessingQueueWhereUniqueInput | CaseProcessingQueueWhereUniqueInput[]
    update?: CaseProcessingQueueUpdateWithWhereUniqueWithoutCaseInput | CaseProcessingQueueUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CaseProcessingQueueUpdateManyWithWhereWithoutCaseInput | CaseProcessingQueueUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CaseProcessingQueueScalarWhereInput | CaseProcessingQueueScalarWhereInput[]
  }

  export type CourtCaseCreateNestedOneWithoutProcessingQueueInput = {
    create?: XOR<CourtCaseCreateWithoutProcessingQueueInput, CourtCaseUncheckedCreateWithoutProcessingQueueInput>
    connectOrCreate?: CourtCaseCreateOrConnectWithoutProcessingQueueInput
    connect?: CourtCaseWhereUniqueInput
  }

  export type EnumProcessingTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProcessingType
  }

  export type EnumProcessingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcessingStatus
  }

  export type CourtCaseUpdateOneRequiredWithoutProcessingQueueNestedInput = {
    create?: XOR<CourtCaseCreateWithoutProcessingQueueInput, CourtCaseUncheckedCreateWithoutProcessingQueueInput>
    connectOrCreate?: CourtCaseCreateOrConnectWithoutProcessingQueueInput
    upsert?: CourtCaseUpsertWithoutProcessingQueueInput
    connect?: CourtCaseWhereUniqueInput
    update?: XOR<XOR<CourtCaseUpdateToOneWithWhereWithoutProcessingQueueInput, CourtCaseUpdateWithoutProcessingQueueInput>, CourtCaseUncheckedUpdateWithoutProcessingQueueInput>
  }

  export type UserCreateNestedOneWithoutAssignedTicketsInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupportTicketsInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type SupportTicketMessageCreateNestedManyWithoutTicketInput = {
    create?: XOR<SupportTicketMessageCreateWithoutTicketInput, SupportTicketMessageUncheckedCreateWithoutTicketInput> | SupportTicketMessageCreateWithoutTicketInput[] | SupportTicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SupportTicketMessageCreateOrConnectWithoutTicketInput | SupportTicketMessageCreateOrConnectWithoutTicketInput[]
    createMany?: SupportTicketMessageCreateManyTicketInputEnvelope
    connect?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
  }

  export type SupportTicketMessageUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<SupportTicketMessageCreateWithoutTicketInput, SupportTicketMessageUncheckedCreateWithoutTicketInput> | SupportTicketMessageCreateWithoutTicketInput[] | SupportTicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SupportTicketMessageCreateOrConnectWithoutTicketInput | SupportTicketMessageCreateOrConnectWithoutTicketInput[]
    createMany?: SupportTicketMessageCreateManyTicketInputEnvelope
    connect?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
  }

  export type EnumSupportTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.SupportTicketStatus
  }

  export type EnumSupportTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.SupportTicketPriority
  }

  export type UserUpdateOneWithoutAssignedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    upsert?: UserUpsertWithoutAssignedTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTicketsInput, UserUpdateWithoutAssignedTicketsInput>, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateOneRequiredWithoutSupportTicketsNestedInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    upsert?: UserUpsertWithoutSupportTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupportTicketsInput, UserUpdateWithoutSupportTicketsInput>, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type SupportTicketMessageUpdateManyWithoutTicketNestedInput = {
    create?: XOR<SupportTicketMessageCreateWithoutTicketInput, SupportTicketMessageUncheckedCreateWithoutTicketInput> | SupportTicketMessageCreateWithoutTicketInput[] | SupportTicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SupportTicketMessageCreateOrConnectWithoutTicketInput | SupportTicketMessageCreateOrConnectWithoutTicketInput[]
    upsert?: SupportTicketMessageUpsertWithWhereUniqueWithoutTicketInput | SupportTicketMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: SupportTicketMessageCreateManyTicketInputEnvelope
    set?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    disconnect?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    delete?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    connect?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    update?: SupportTicketMessageUpdateWithWhereUniqueWithoutTicketInput | SupportTicketMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: SupportTicketMessageUpdateManyWithWhereWithoutTicketInput | SupportTicketMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: SupportTicketMessageScalarWhereInput | SupportTicketMessageScalarWhereInput[]
  }

  export type SupportTicketMessageUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<SupportTicketMessageCreateWithoutTicketInput, SupportTicketMessageUncheckedCreateWithoutTicketInput> | SupportTicketMessageCreateWithoutTicketInput[] | SupportTicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: SupportTicketMessageCreateOrConnectWithoutTicketInput | SupportTicketMessageCreateOrConnectWithoutTicketInput[]
    upsert?: SupportTicketMessageUpsertWithWhereUniqueWithoutTicketInput | SupportTicketMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: SupportTicketMessageCreateManyTicketInputEnvelope
    set?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    disconnect?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    delete?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    connect?: SupportTicketMessageWhereUniqueInput | SupportTicketMessageWhereUniqueInput[]
    update?: SupportTicketMessageUpdateWithWhereUniqueWithoutTicketInput | SupportTicketMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: SupportTicketMessageUpdateManyWithWhereWithoutTicketInput | SupportTicketMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: SupportTicketMessageScalarWhereInput | SupportTicketMessageScalarWhereInput[]
  }

  export type SupportTicketMessageCreateattachmentsInput = {
    set: string[]
  }

  export type SupportTicketCreateNestedOneWithoutMessagesInput = {
    create?: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutMessagesInput
    connect?: SupportTicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketMessagesInput = {
    create?: XOR<UserCreateWithoutTicketMessagesInput, UserUncheckedCreateWithoutTicketMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type SupportTicketMessageUpdateattachmentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SupportTicketUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutMessagesInput
    upsert?: SupportTicketUpsertWithoutMessagesInput
    connect?: SupportTicketWhereUniqueInput
    update?: XOR<XOR<SupportTicketUpdateToOneWithWhereWithoutMessagesInput, SupportTicketUpdateWithoutMessagesInput>, SupportTicketUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutTicketMessagesNestedInput = {
    create?: XOR<UserCreateWithoutTicketMessagesInput, UserUncheckedCreateWithoutTicketMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketMessagesInput
    upsert?: UserUpsertWithoutTicketMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketMessagesInput, UserUpdateWithoutTicketMessagesInput>, UserUncheckedUpdateWithoutTicketMessagesInput>
  }

  export type UserCreateNestedOneWithoutAdminActionsInput = {
    create?: XOR<UserCreateWithoutAdminActionsInput, UserUncheckedCreateWithoutAdminActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminActionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminActionsNestedInput = {
    create?: XOR<UserCreateWithoutAdminActionsInput, UserUncheckedCreateWithoutAdminActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminActionsInput
    upsert?: UserUpsertWithoutAdminActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminActionsInput, UserUpdateWithoutAdminActionsInput>, UserUncheckedUpdateWithoutAdminActionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type NestedEnumDataSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.DataSource | EnumDataSourceFieldRefInput<$PrismaModel>
    in?: $Enums.DataSource[] | ListEnumDataSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataSource[] | ListEnumDataSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumDataSourceFilter<$PrismaModel> | $Enums.DataSource
  }

  export type NestedEnumAlertStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusFilter<$PrismaModel> | $Enums.AlertStatus
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type NestedEnumDataSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataSource | EnumDataSourceFieldRefInput<$PrismaModel>
    in?: $Enums.DataSource[] | ListEnumDataSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataSource[] | ListEnumDataSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumDataSourceWithAggregatesFilter<$PrismaModel> | $Enums.DataSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataSourceFilter<$PrismaModel>
    _max?: NestedEnumDataSourceFilter<$PrismaModel>
  }

  export type NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCourtTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourtType | EnumCourtTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourtType[] | ListEnumCourtTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourtType[] | ListEnumCourtTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourtTypeFilter<$PrismaModel> | $Enums.CourtType
  }

  export type NestedEnumRiskLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelFilter<$PrismaModel> | $Enums.RiskLevel
  }

  export type NestedEnumCourtTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourtType | EnumCourtTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourtType[] | ListEnumCourtTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourtType[] | ListEnumCourtTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourtTypeWithAggregatesFilter<$PrismaModel> | $Enums.CourtType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourtTypeFilter<$PrismaModel>
    _max?: NestedEnumCourtTypeFilter<$PrismaModel>
  }

  export type NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskLevel | EnumRiskLevelFieldRefInput<$PrismaModel>
    in?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskLevel[] | ListEnumRiskLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskLevelWithAggregatesFilter<$PrismaModel> | $Enums.RiskLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskLevelFilter<$PrismaModel>
    _max?: NestedEnumRiskLevelFilter<$PrismaModel>
  }

  export type NestedEnumProcessingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingType | EnumProcessingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingType[] | ListEnumProcessingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingType[] | ListEnumProcessingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingTypeFilter<$PrismaModel> | $Enums.ProcessingType
  }

  export type NestedEnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }

  export type NestedEnumProcessingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingType | EnumProcessingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingType[] | ListEnumProcessingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingType[] | ListEnumProcessingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingTypeFilter<$PrismaModel>
    _max?: NestedEnumProcessingTypeFilter<$PrismaModel>
  }

  export type NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }

  export type NestedEnumSupportTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportTicketStatus | EnumSupportTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportTicketStatus[] | ListEnumSupportTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportTicketStatus[] | ListEnumSupportTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportTicketStatusFilter<$PrismaModel> | $Enums.SupportTicketStatus
  }

  export type NestedEnumSupportTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportTicketPriority | EnumSupportTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.SupportTicketPriority[] | ListEnumSupportTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportTicketPriority[] | ListEnumSupportTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportTicketPriorityFilter<$PrismaModel> | $Enums.SupportTicketPriority
  }

  export type NestedEnumSupportTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportTicketStatus | EnumSupportTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportTicketStatus[] | ListEnumSupportTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportTicketStatus[] | ListEnumSupportTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.SupportTicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupportTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumSupportTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumSupportTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportTicketPriority | EnumSupportTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.SupportTicketPriority[] | ListEnumSupportTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportTicketPriority[] | ListEnumSupportTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.SupportTicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupportTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumSupportTicketPriorityFilter<$PrismaModel>
  }

  export type AlertPreferenceCreateWithoutUserInput = {
    id?: string
    cities?: AlertPreferenceCreatecitiesInput | string[]
    maxDistanceKm?: number
    propertyTypes?: AlertPreferenceCreatepropertyTypesInput | string[]
    minValue?: number | null
    maxValue?: number | null
    minBedrooms?: number | null
    maxBedrooms?: number | null
    alertTypes?: AlertPreferenceCreatealertTypesInput | $Enums.AlertType[]
    minPriority?: $Enums.Priority
    minOpportunityScore?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    maxAlertsPerDay?: number
    quietHoursStart?: string | null
    quietHoursEnd?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    cities?: AlertPreferenceCreatecitiesInput | string[]
    maxDistanceKm?: number
    propertyTypes?: AlertPreferenceCreatepropertyTypesInput | string[]
    minValue?: number | null
    maxValue?: number | null
    minBedrooms?: number | null
    maxBedrooms?: number | null
    alertTypes?: AlertPreferenceCreatealertTypesInput | $Enums.AlertType[]
    minPriority?: $Enums.Priority
    minOpportunityScore?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    maxAlertsPerDay?: number
    quietHoursStart?: string | null
    quietHoursEnd?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertPreferenceCreateOrConnectWithoutUserInput = {
    where: AlertPreferenceWhereUniqueInput
    create: XOR<AlertPreferenceCreateWithoutUserInput, AlertPreferenceUncheckedCreateWithoutUserInput>
  }

  export type AlertPreferenceCreateManyUserInputEnvelope = {
    data: AlertPreferenceCreateManyUserInput | AlertPreferenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAlertCreateWithoutUserInput = {
    id?: string
    isNotified?: boolean
    notifiedAt?: Date | string | null
    isViewed?: boolean
    viewedAt?: Date | string | null
    isBookmarked?: boolean
    createdAt?: Date | string
    alert: AlertCreateNestedOneWithoutUserAlertsInput
  }

  export type UserAlertUncheckedCreateWithoutUserInput = {
    id?: string
    alertId: string
    isNotified?: boolean
    notifiedAt?: Date | string | null
    isViewed?: boolean
    viewedAt?: Date | string | null
    isBookmarked?: boolean
    createdAt?: Date | string
  }

  export type UserAlertCreateOrConnectWithoutUserInput = {
    where: UserAlertWhereUniqueInput
    create: XOR<UserAlertCreateWithoutUserInput, UserAlertUncheckedCreateWithoutUserInput>
  }

  export type UserAlertCreateManyUserInputEnvelope = {
    data: UserAlertCreateManyUserInput | UserAlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SavedPropertyCreateWithoutUserInput = {
    id?: string
    alertId: string
    notes?: string | null
    tags?: SavedPropertyCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedPropertyUncheckedCreateWithoutUserInput = {
    id?: string
    alertId: string
    notes?: string | null
    tags?: SavedPropertyCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedPropertyCreateOrConnectWithoutUserInput = {
    where: SavedPropertyWhereUniqueInput
    create: XOR<SavedPropertyCreateWithoutUserInput, SavedPropertyUncheckedCreateWithoutUserInput>
  }

  export type SavedPropertyCreateManyUserInputEnvelope = {
    data: SavedPropertyCreateManyUserInput | SavedPropertyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutUserInput = {
    id?: string
    action: $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SupportTicketStatus
    priority?: $Enums.SupportTicketPriority
    category?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    messages?: SupportTicketMessageCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SupportTicketStatus
    priority?: $Enums.SupportTicketPriority
    category?: string | null
    assignedToId?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: SupportTicketMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketCreateManyUserInputEnvelope = {
    data: SupportTicketCreateManyUserInput | SupportTicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SupportTicketStatus
    priority?: $Enums.SupportTicketPriority
    category?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSupportTicketsInput
    messages?: SupportTicketMessageCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutAssignedToInput = {
    id?: string
    userId: string
    title: string
    description: string
    status?: $Enums.SupportTicketStatus
    priority?: $Enums.SupportTicketPriority
    category?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: SupportTicketMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutAssignedToInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput>
  }

  export type SupportTicketCreateManyAssignedToInputEnvelope = {
    data: SupportTicketCreateManyAssignedToInput | SupportTicketCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketMessageCreateWithoutUserInput = {
    id?: string
    message: string
    isFromAdmin?: boolean
    attachments?: SupportTicketMessageCreateattachmentsInput | string[]
    createdAt?: Date | string
    ticket: SupportTicketCreateNestedOneWithoutMessagesInput
  }

  export type SupportTicketMessageUncheckedCreateWithoutUserInput = {
    id?: string
    ticketId: string
    message: string
    isFromAdmin?: boolean
    attachments?: SupportTicketMessageCreateattachmentsInput | string[]
    createdAt?: Date | string
  }

  export type SupportTicketMessageCreateOrConnectWithoutUserInput = {
    where: SupportTicketMessageWhereUniqueInput
    create: XOR<SupportTicketMessageCreateWithoutUserInput, SupportTicketMessageUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketMessageCreateManyUserInputEnvelope = {
    data: SupportTicketMessageCreateManyUserInput | SupportTicketMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminActionCreateWithoutAdminInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminActionUncheckedCreateWithoutAdminInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminActionCreateOrConnectWithoutAdminInput = {
    where: AdminActionWhereUniqueInput
    create: XOR<AdminActionCreateWithoutAdminInput, AdminActionUncheckedCreateWithoutAdminInput>
  }

  export type AdminActionCreateManyAdminInputEnvelope = {
    data: AdminActionCreateManyAdminInput | AdminActionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AlertPreferenceUpsertWithWhereUniqueWithoutUserInput = {
    where: AlertPreferenceWhereUniqueInput
    update: XOR<AlertPreferenceUpdateWithoutUserInput, AlertPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<AlertPreferenceCreateWithoutUserInput, AlertPreferenceUncheckedCreateWithoutUserInput>
  }

  export type AlertPreferenceUpdateWithWhereUniqueWithoutUserInput = {
    where: AlertPreferenceWhereUniqueInput
    data: XOR<AlertPreferenceUpdateWithoutUserInput, AlertPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type AlertPreferenceUpdateManyWithWhereWithoutUserInput = {
    where: AlertPreferenceScalarWhereInput
    data: XOR<AlertPreferenceUpdateManyMutationInput, AlertPreferenceUncheckedUpdateManyWithoutUserInput>
  }

  export type AlertPreferenceScalarWhereInput = {
    AND?: AlertPreferenceScalarWhereInput | AlertPreferenceScalarWhereInput[]
    OR?: AlertPreferenceScalarWhereInput[]
    NOT?: AlertPreferenceScalarWhereInput | AlertPreferenceScalarWhereInput[]
    id?: StringFilter<"AlertPreference"> | string
    userId?: StringFilter<"AlertPreference"> | string
    cities?: StringNullableListFilter<"AlertPreference">
    maxDistanceKm?: IntFilter<"AlertPreference"> | number
    propertyTypes?: StringNullableListFilter<"AlertPreference">
    minValue?: IntNullableFilter<"AlertPreference"> | number | null
    maxValue?: IntNullableFilter<"AlertPreference"> | number | null
    minBedrooms?: IntNullableFilter<"AlertPreference"> | number | null
    maxBedrooms?: IntNullableFilter<"AlertPreference"> | number | null
    alertTypes?: EnumAlertTypeNullableListFilter<"AlertPreference">
    minPriority?: EnumPriorityFilter<"AlertPreference"> | $Enums.Priority
    minOpportunityScore?: IntFilter<"AlertPreference"> | number
    emailNotifications?: BoolFilter<"AlertPreference"> | boolean
    smsNotifications?: BoolFilter<"AlertPreference"> | boolean
    pushNotifications?: BoolFilter<"AlertPreference"> | boolean
    maxAlertsPerDay?: IntFilter<"AlertPreference"> | number
    quietHoursStart?: StringNullableFilter<"AlertPreference"> | string | null
    quietHoursEnd?: StringNullableFilter<"AlertPreference"> | string | null
    createdAt?: DateTimeFilter<"AlertPreference"> | Date | string
    updatedAt?: DateTimeFilter<"AlertPreference"> | Date | string
  }

  export type UserAlertUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAlertWhereUniqueInput
    update: XOR<UserAlertUpdateWithoutUserInput, UserAlertUncheckedUpdateWithoutUserInput>
    create: XOR<UserAlertCreateWithoutUserInput, UserAlertUncheckedCreateWithoutUserInput>
  }

  export type UserAlertUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAlertWhereUniqueInput
    data: XOR<UserAlertUpdateWithoutUserInput, UserAlertUncheckedUpdateWithoutUserInput>
  }

  export type UserAlertUpdateManyWithWhereWithoutUserInput = {
    where: UserAlertScalarWhereInput
    data: XOR<UserAlertUpdateManyMutationInput, UserAlertUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAlertScalarWhereInput = {
    AND?: UserAlertScalarWhereInput | UserAlertScalarWhereInput[]
    OR?: UserAlertScalarWhereInput[]
    NOT?: UserAlertScalarWhereInput | UserAlertScalarWhereInput[]
    id?: StringFilter<"UserAlert"> | string
    userId?: StringFilter<"UserAlert"> | string
    alertId?: StringFilter<"UserAlert"> | string
    isNotified?: BoolFilter<"UserAlert"> | boolean
    notifiedAt?: DateTimeNullableFilter<"UserAlert"> | Date | string | null
    isViewed?: BoolFilter<"UserAlert"> | boolean
    viewedAt?: DateTimeNullableFilter<"UserAlert"> | Date | string | null
    isBookmarked?: BoolFilter<"UserAlert"> | boolean
    createdAt?: DateTimeFilter<"UserAlert"> | Date | string
  }

  export type SavedPropertyUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedPropertyWhereUniqueInput
    update: XOR<SavedPropertyUpdateWithoutUserInput, SavedPropertyUncheckedUpdateWithoutUserInput>
    create: XOR<SavedPropertyCreateWithoutUserInput, SavedPropertyUncheckedCreateWithoutUserInput>
  }

  export type SavedPropertyUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedPropertyWhereUniqueInput
    data: XOR<SavedPropertyUpdateWithoutUserInput, SavedPropertyUncheckedUpdateWithoutUserInput>
  }

  export type SavedPropertyUpdateManyWithWhereWithoutUserInput = {
    where: SavedPropertyScalarWhereInput
    data: XOR<SavedPropertyUpdateManyMutationInput, SavedPropertyUncheckedUpdateManyWithoutUserInput>
  }

  export type SavedPropertyScalarWhereInput = {
    AND?: SavedPropertyScalarWhereInput | SavedPropertyScalarWhereInput[]
    OR?: SavedPropertyScalarWhereInput[]
    NOT?: SavedPropertyScalarWhereInput | SavedPropertyScalarWhereInput[]
    id?: StringFilter<"SavedProperty"> | string
    userId?: StringFilter<"SavedProperty"> | string
    alertId?: StringFilter<"SavedProperty"> | string
    notes?: StringNullableFilter<"SavedProperty"> | string | null
    tags?: StringNullableListFilter<"SavedProperty">
    createdAt?: DateTimeFilter<"SavedProperty"> | Date | string
    updatedAt?: DateTimeFilter<"SavedProperty"> | Date | string
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringNullableFilter<"ActivityLog"> | string | null
    action?: EnumActivityTypeFilter<"ActivityLog"> | $Enums.ActivityType
    details?: JsonNullableFilter<"ActivityLog">
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutUserInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutUserInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    userId?: StringFilter<"SupportTicket"> | string
    title?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    status?: EnumSupportTicketStatusFilter<"SupportTicket"> | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFilter<"SupportTicket"> | $Enums.SupportTicketPriority
    category?: StringNullableFilter<"SupportTicket"> | string | null
    assignedToId?: StringNullableFilter<"SupportTicket"> | string | null
    resolution?: StringNullableFilter<"SupportTicket"> | string | null
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    resolvedBy?: StringNullableFilter<"SupportTicket"> | string | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutAssignedToInput, SupportTicketUncheckedUpdateWithoutAssignedToInput>
    create: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutAssignedToInput, SupportTicketUncheckedUpdateWithoutAssignedToInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutAssignedToInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type SupportTicketMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: SupportTicketMessageWhereUniqueInput
    update: XOR<SupportTicketMessageUpdateWithoutUserInput, SupportTicketMessageUncheckedUpdateWithoutUserInput>
    create: XOR<SupportTicketMessageCreateWithoutUserInput, SupportTicketMessageUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: SupportTicketMessageWhereUniqueInput
    data: XOR<SupportTicketMessageUpdateWithoutUserInput, SupportTicketMessageUncheckedUpdateWithoutUserInput>
  }

  export type SupportTicketMessageUpdateManyWithWhereWithoutUserInput = {
    where: SupportTicketMessageScalarWhereInput
    data: XOR<SupportTicketMessageUpdateManyMutationInput, SupportTicketMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type SupportTicketMessageScalarWhereInput = {
    AND?: SupportTicketMessageScalarWhereInput | SupportTicketMessageScalarWhereInput[]
    OR?: SupportTicketMessageScalarWhereInput[]
    NOT?: SupportTicketMessageScalarWhereInput | SupportTicketMessageScalarWhereInput[]
    id?: StringFilter<"SupportTicketMessage"> | string
    ticketId?: StringFilter<"SupportTicketMessage"> | string
    userId?: StringFilter<"SupportTicketMessage"> | string
    message?: StringFilter<"SupportTicketMessage"> | string
    isFromAdmin?: BoolFilter<"SupportTicketMessage"> | boolean
    attachments?: StringNullableListFilter<"SupportTicketMessage">
    createdAt?: DateTimeFilter<"SupportTicketMessage"> | Date | string
  }

  export type AdminActionUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminActionWhereUniqueInput
    update: XOR<AdminActionUpdateWithoutAdminInput, AdminActionUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminActionCreateWithoutAdminInput, AdminActionUncheckedCreateWithoutAdminInput>
  }

  export type AdminActionUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminActionWhereUniqueInput
    data: XOR<AdminActionUpdateWithoutAdminInput, AdminActionUncheckedUpdateWithoutAdminInput>
  }

  export type AdminActionUpdateManyWithWhereWithoutAdminInput = {
    where: AdminActionScalarWhereInput
    data: XOR<AdminActionUpdateManyMutationInput, AdminActionUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminActionScalarWhereInput = {
    AND?: AdminActionScalarWhereInput | AdminActionScalarWhereInput[]
    OR?: AdminActionScalarWhereInput[]
    NOT?: AdminActionScalarWhereInput | AdminActionScalarWhereInput[]
    id?: StringFilter<"AdminAction"> | string
    adminId?: StringFilter<"AdminAction"> | string
    action?: StringFilter<"AdminAction"> | string
    targetType?: StringFilter<"AdminAction"> | string
    targetId?: StringNullableFilter<"AdminAction"> | string | null
    description?: StringFilter<"AdminAction"> | string
    metadata?: JsonNullableFilter<"AdminAction">
    createdAt?: DateTimeFilter<"AdminAction"> | Date | string
  }

  export type UserAlertCreateWithoutAlertInput = {
    id?: string
    isNotified?: boolean
    notifiedAt?: Date | string | null
    isViewed?: boolean
    viewedAt?: Date | string | null
    isBookmarked?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserAlertsInput
  }

  export type UserAlertUncheckedCreateWithoutAlertInput = {
    id?: string
    userId: string
    isNotified?: boolean
    notifiedAt?: Date | string | null
    isViewed?: boolean
    viewedAt?: Date | string | null
    isBookmarked?: boolean
    createdAt?: Date | string
  }

  export type UserAlertCreateOrConnectWithoutAlertInput = {
    where: UserAlertWhereUniqueInput
    create: XOR<UserAlertCreateWithoutAlertInput, UserAlertUncheckedCreateWithoutAlertInput>
  }

  export type UserAlertCreateManyAlertInputEnvelope = {
    data: UserAlertCreateManyAlertInput | UserAlertCreateManyAlertInput[]
    skipDuplicates?: boolean
  }

  export type CourtCaseCreateWithoutAlertsInput = {
    id?: string
    guid: string
    title: string
    neutralCitation?: string | null
    court: $Enums.CourtType
    publishDate: Date | string
    caseUrl: string
    summary?: string | null
    fullText?: string | null
    addresses?: CourtCaseCreateaddressesInput | string[]
    municipalities?: CourtCaseCreatemunicipalitiesInput | string[]
    parties?: CourtCaseCreatepartiesInput | string[]
    statutes?: CourtCaseCreatestatutesInput | string[]
    caseTypes?: CourtCaseCreatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: $Enums.RiskLevel
    isProcessed?: boolean
    nerProcessed?: boolean
    classified?: boolean
    source: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    processingQueue?: CaseProcessingQueueCreateNestedManyWithoutCaseInput
  }

  export type CourtCaseUncheckedCreateWithoutAlertsInput = {
    id?: string
    guid: string
    title: string
    neutralCitation?: string | null
    court: $Enums.CourtType
    publishDate: Date | string
    caseUrl: string
    summary?: string | null
    fullText?: string | null
    addresses?: CourtCaseCreateaddressesInput | string[]
    municipalities?: CourtCaseCreatemunicipalitiesInput | string[]
    parties?: CourtCaseCreatepartiesInput | string[]
    statutes?: CourtCaseCreatestatutesInput | string[]
    caseTypes?: CourtCaseCreatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: $Enums.RiskLevel
    isProcessed?: boolean
    nerProcessed?: boolean
    classified?: boolean
    source: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    processingQueue?: CaseProcessingQueueUncheckedCreateNestedManyWithoutCaseInput
  }

  export type CourtCaseCreateOrConnectWithoutAlertsInput = {
    where: CourtCaseWhereUniqueInput
    create: XOR<CourtCaseCreateWithoutAlertsInput, CourtCaseUncheckedCreateWithoutAlertsInput>
  }

  export type UserAlertUpsertWithWhereUniqueWithoutAlertInput = {
    where: UserAlertWhereUniqueInput
    update: XOR<UserAlertUpdateWithoutAlertInput, UserAlertUncheckedUpdateWithoutAlertInput>
    create: XOR<UserAlertCreateWithoutAlertInput, UserAlertUncheckedCreateWithoutAlertInput>
  }

  export type UserAlertUpdateWithWhereUniqueWithoutAlertInput = {
    where: UserAlertWhereUniqueInput
    data: XOR<UserAlertUpdateWithoutAlertInput, UserAlertUncheckedUpdateWithoutAlertInput>
  }

  export type UserAlertUpdateManyWithWhereWithoutAlertInput = {
    where: UserAlertScalarWhereInput
    data: XOR<UserAlertUpdateManyMutationInput, UserAlertUncheckedUpdateManyWithoutAlertInput>
  }

  export type CourtCaseUpsertWithoutAlertsInput = {
    update: XOR<CourtCaseUpdateWithoutAlertsInput, CourtCaseUncheckedUpdateWithoutAlertsInput>
    create: XOR<CourtCaseCreateWithoutAlertsInput, CourtCaseUncheckedCreateWithoutAlertsInput>
    where?: CourtCaseWhereInput
  }

  export type CourtCaseUpdateToOneWithWhereWithoutAlertsInput = {
    where?: CourtCaseWhereInput
    data: XOR<CourtCaseUpdateWithoutAlertsInput, CourtCaseUncheckedUpdateWithoutAlertsInput>
  }

  export type CourtCaseUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    guid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    neutralCitation?: NullableStringFieldUpdateOperationsInput | string | null
    court?: EnumCourtTypeFieldUpdateOperationsInput | $Enums.CourtType
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    caseUrl?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    fullText?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CourtCaseUpdateaddressesInput | string[]
    municipalities?: CourtCaseUpdatemunicipalitiesInput | string[]
    parties?: CourtCaseUpdatepartiesInput | string[]
    statutes?: CourtCaseUpdatestatutesInput | string[]
    caseTypes?: CourtCaseUpdatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    nerProcessed?: BoolFieldUpdateOperationsInput | boolean
    classified?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingQueue?: CaseProcessingQueueUpdateManyWithoutCaseNestedInput
  }

  export type CourtCaseUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    guid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    neutralCitation?: NullableStringFieldUpdateOperationsInput | string | null
    court?: EnumCourtTypeFieldUpdateOperationsInput | $Enums.CourtType
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    caseUrl?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    fullText?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CourtCaseUpdateaddressesInput | string[]
    municipalities?: CourtCaseUpdatemunicipalitiesInput | string[]
    parties?: CourtCaseUpdatepartiesInput | string[]
    statutes?: CourtCaseUpdatestatutesInput | string[]
    caseTypes?: CourtCaseUpdatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    nerProcessed?: BoolFieldUpdateOperationsInput | boolean
    classified?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processingQueue?: CaseProcessingQueueUncheckedUpdateManyWithoutCaseNestedInput
  }

  export type UserCreateWithoutUserAlertsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutAdminInput
  }

  export type UserUncheckedCreateWithoutUserAlertsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceUncheckedCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UserCreateOrConnectWithoutUserAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserAlertsInput, UserUncheckedCreateWithoutUserAlertsInput>
  }

  export type AlertCreateWithoutUserAlertsInput = {
    id?: string
    title: string
    description: string
    address: string
    city: string
    province?: string
    postalCode?: string | null
    alertType: $Enums.AlertType
    source: $Enums.DataSource
    status?: $Enums.AlertStatus
    priority?: $Enums.Priority
    opportunityScore?: number
    timelineMonths?: number | null
    propertyType?: string | null
    estimatedValue?: number | null
    lotSize?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    courtFileNumber?: string | null
    courtDate?: Date | string | null
    probateNumber?: string | null
    executorName?: string | null
    executorContact?: string | null
    applicationNumber?: string | null
    municipalOffice?: string | null
    applicationDate?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    discoveredAt?: Date | string
    courtCase?: CourtCaseCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutUserAlertsInput = {
    id?: string
    title: string
    description: string
    address: string
    city: string
    province?: string
    postalCode?: string | null
    alertType: $Enums.AlertType
    source: $Enums.DataSource
    status?: $Enums.AlertStatus
    priority?: $Enums.Priority
    opportunityScore?: number
    timelineMonths?: number | null
    propertyType?: string | null
    estimatedValue?: number | null
    lotSize?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    courtFileNumber?: string | null
    courtDate?: Date | string | null
    courtCaseId?: string | null
    probateNumber?: string | null
    executorName?: string | null
    executorContact?: string | null
    applicationNumber?: string | null
    municipalOffice?: string | null
    applicationDate?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    discoveredAt?: Date | string
  }

  export type AlertCreateOrConnectWithoutUserAlertsInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutUserAlertsInput, AlertUncheckedCreateWithoutUserAlertsInput>
  }

  export type UserUpsertWithoutUserAlertsInput = {
    update: XOR<UserUpdateWithoutUserAlertsInput, UserUncheckedUpdateWithoutUserAlertsInput>
    create: XOR<UserCreateWithoutUserAlertsInput, UserUncheckedCreateWithoutUserAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserAlertsInput, UserUncheckedUpdateWithoutUserAlertsInput>
  }

  export type UserUpdateWithoutUserAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutAdminNestedInput
  }

  export type UserUncheckedUpdateWithoutUserAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUncheckedUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AlertUpsertWithoutUserAlertsInput = {
    update: XOR<AlertUpdateWithoutUserAlertsInput, AlertUncheckedUpdateWithoutUserAlertsInput>
    create: XOR<AlertCreateWithoutUserAlertsInput, AlertUncheckedCreateWithoutUserAlertsInput>
    where?: AlertWhereInput
  }

  export type AlertUpdateToOneWithWhereWithoutUserAlertsInput = {
    where?: AlertWhereInput
    data: XOR<AlertUpdateWithoutUserAlertsInput, AlertUncheckedUpdateWithoutUserAlertsInput>
  }

  export type AlertUpdateWithoutUserAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    source?: EnumDataSourceFieldUpdateOperationsInput | $Enums.DataSource
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    opportunityScore?: IntFieldUpdateOperationsInput | number
    timelineMonths?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    courtFileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executorName?: NullableStringFieldUpdateOperationsInput | string | null
    executorContact?: NullableStringFieldUpdateOperationsInput | string | null
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    municipalOffice?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courtCase?: CourtCaseUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutUserAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    source?: EnumDataSourceFieldUpdateOperationsInput | $Enums.DataSource
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    opportunityScore?: IntFieldUpdateOperationsInput | number
    timelineMonths?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    courtFileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    probateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executorName?: NullableStringFieldUpdateOperationsInput | string | null
    executorContact?: NullableStringFieldUpdateOperationsInput | string | null
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    municipalOffice?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAlertPreferencesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    userAlerts?: UserAlertCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutAdminInput
  }

  export type UserUncheckedCreateWithoutAlertPreferencesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    userAlerts?: UserAlertUncheckedCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UserCreateOrConnectWithoutAlertPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertPreferencesInput, UserUncheckedCreateWithoutAlertPreferencesInput>
  }

  export type UserUpsertWithoutAlertPreferencesInput = {
    update: XOR<UserUpdateWithoutAlertPreferencesInput, UserUncheckedUpdateWithoutAlertPreferencesInput>
    create: XOR<UserCreateWithoutAlertPreferencesInput, UserUncheckedCreateWithoutAlertPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlertPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlertPreferencesInput, UserUncheckedUpdateWithoutAlertPreferencesInput>
  }

  export type UserUpdateWithoutAlertPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAlerts?: UserAlertUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutAdminNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAlerts?: UserAlertUncheckedUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type UserCreateWithoutSavedPropertiesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutAdminInput
  }

  export type UserUncheckedCreateWithoutSavedPropertiesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceUncheckedCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UserCreateOrConnectWithoutSavedPropertiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedPropertiesInput, UserUncheckedCreateWithoutSavedPropertiesInput>
  }

  export type UserUpsertWithoutSavedPropertiesInput = {
    update: XOR<UserUpdateWithoutSavedPropertiesInput, UserUncheckedUpdateWithoutSavedPropertiesInput>
    create: XOR<UserCreateWithoutSavedPropertiesInput, UserUncheckedCreateWithoutSavedPropertiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedPropertiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedPropertiesInput, UserUncheckedUpdateWithoutSavedPropertiesInput>
  }

  export type UserUpdateWithoutSavedPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutAdminNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUncheckedUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutAdminInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceUncheckedCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertUncheckedCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutAdminNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUncheckedUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUncheckedUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AlertCreateWithoutCourtCaseInput = {
    id?: string
    title: string
    description: string
    address: string
    city: string
    province?: string
    postalCode?: string | null
    alertType: $Enums.AlertType
    source: $Enums.DataSource
    status?: $Enums.AlertStatus
    priority?: $Enums.Priority
    opportunityScore?: number
    timelineMonths?: number | null
    propertyType?: string | null
    estimatedValue?: number | null
    lotSize?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    courtFileNumber?: string | null
    courtDate?: Date | string | null
    probateNumber?: string | null
    executorName?: string | null
    executorContact?: string | null
    applicationNumber?: string | null
    municipalOffice?: string | null
    applicationDate?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    discoveredAt?: Date | string
    userAlerts?: UserAlertCreateNestedManyWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutCourtCaseInput = {
    id?: string
    title: string
    description: string
    address: string
    city: string
    province?: string
    postalCode?: string | null
    alertType: $Enums.AlertType
    source: $Enums.DataSource
    status?: $Enums.AlertStatus
    priority?: $Enums.Priority
    opportunityScore?: number
    timelineMonths?: number | null
    propertyType?: string | null
    estimatedValue?: number | null
    lotSize?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    courtFileNumber?: string | null
    courtDate?: Date | string | null
    probateNumber?: string | null
    executorName?: string | null
    executorContact?: string | null
    applicationNumber?: string | null
    municipalOffice?: string | null
    applicationDate?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    discoveredAt?: Date | string
    userAlerts?: UserAlertUncheckedCreateNestedManyWithoutAlertInput
  }

  export type AlertCreateOrConnectWithoutCourtCaseInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutCourtCaseInput, AlertUncheckedCreateWithoutCourtCaseInput>
  }

  export type AlertCreateManyCourtCaseInputEnvelope = {
    data: AlertCreateManyCourtCaseInput | AlertCreateManyCourtCaseInput[]
    skipDuplicates?: boolean
  }

  export type CaseProcessingQueueCreateWithoutCaseInput = {
    id?: string
    processType: $Enums.ProcessingType
    status?: $Enums.ProcessingStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    error?: string | null
    scheduledAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type CaseProcessingQueueUncheckedCreateWithoutCaseInput = {
    id?: string
    processType: $Enums.ProcessingType
    status?: $Enums.ProcessingStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    error?: string | null
    scheduledAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type CaseProcessingQueueCreateOrConnectWithoutCaseInput = {
    where: CaseProcessingQueueWhereUniqueInput
    create: XOR<CaseProcessingQueueCreateWithoutCaseInput, CaseProcessingQueueUncheckedCreateWithoutCaseInput>
  }

  export type CaseProcessingQueueCreateManyCaseInputEnvelope = {
    data: CaseProcessingQueueCreateManyCaseInput | CaseProcessingQueueCreateManyCaseInput[]
    skipDuplicates?: boolean
  }

  export type AlertUpsertWithWhereUniqueWithoutCourtCaseInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutCourtCaseInput, AlertUncheckedUpdateWithoutCourtCaseInput>
    create: XOR<AlertCreateWithoutCourtCaseInput, AlertUncheckedCreateWithoutCourtCaseInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutCourtCaseInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutCourtCaseInput, AlertUncheckedUpdateWithoutCourtCaseInput>
  }

  export type AlertUpdateManyWithWhereWithoutCourtCaseInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutCourtCaseInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    title?: StringFilter<"Alert"> | string
    description?: StringFilter<"Alert"> | string
    address?: StringFilter<"Alert"> | string
    city?: StringFilter<"Alert"> | string
    province?: StringFilter<"Alert"> | string
    postalCode?: StringNullableFilter<"Alert"> | string | null
    alertType?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    source?: EnumDataSourceFilter<"Alert"> | $Enums.DataSource
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    priority?: EnumPriorityFilter<"Alert"> | $Enums.Priority
    opportunityScore?: IntFilter<"Alert"> | number
    timelineMonths?: IntNullableFilter<"Alert"> | number | null
    propertyType?: StringNullableFilter<"Alert"> | string | null
    estimatedValue?: IntNullableFilter<"Alert"> | number | null
    lotSize?: StringNullableFilter<"Alert"> | string | null
    bedrooms?: IntNullableFilter<"Alert"> | number | null
    bathrooms?: FloatNullableFilter<"Alert"> | number | null
    courtFileNumber?: StringNullableFilter<"Alert"> | string | null
    courtDate?: DateTimeNullableFilter<"Alert"> | Date | string | null
    courtCaseId?: StringNullableFilter<"Alert"> | string | null
    probateNumber?: StringNullableFilter<"Alert"> | string | null
    executorName?: StringNullableFilter<"Alert"> | string | null
    executorContact?: StringNullableFilter<"Alert"> | string | null
    applicationNumber?: StringNullableFilter<"Alert"> | string | null
    municipalOffice?: StringNullableFilter<"Alert"> | string | null
    applicationDate?: DateTimeNullableFilter<"Alert"> | Date | string | null
    latitude?: FloatNullableFilter<"Alert"> | number | null
    longitude?: FloatNullableFilter<"Alert"> | number | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    discoveredAt?: DateTimeFilter<"Alert"> | Date | string
  }

  export type CaseProcessingQueueUpsertWithWhereUniqueWithoutCaseInput = {
    where: CaseProcessingQueueWhereUniqueInput
    update: XOR<CaseProcessingQueueUpdateWithoutCaseInput, CaseProcessingQueueUncheckedUpdateWithoutCaseInput>
    create: XOR<CaseProcessingQueueCreateWithoutCaseInput, CaseProcessingQueueUncheckedCreateWithoutCaseInput>
  }

  export type CaseProcessingQueueUpdateWithWhereUniqueWithoutCaseInput = {
    where: CaseProcessingQueueWhereUniqueInput
    data: XOR<CaseProcessingQueueUpdateWithoutCaseInput, CaseProcessingQueueUncheckedUpdateWithoutCaseInput>
  }

  export type CaseProcessingQueueUpdateManyWithWhereWithoutCaseInput = {
    where: CaseProcessingQueueScalarWhereInput
    data: XOR<CaseProcessingQueueUpdateManyMutationInput, CaseProcessingQueueUncheckedUpdateManyWithoutCaseInput>
  }

  export type CaseProcessingQueueScalarWhereInput = {
    AND?: CaseProcessingQueueScalarWhereInput | CaseProcessingQueueScalarWhereInput[]
    OR?: CaseProcessingQueueScalarWhereInput[]
    NOT?: CaseProcessingQueueScalarWhereInput | CaseProcessingQueueScalarWhereInput[]
    id?: StringFilter<"CaseProcessingQueue"> | string
    caseId?: StringFilter<"CaseProcessingQueue"> | string
    processType?: EnumProcessingTypeFilter<"CaseProcessingQueue"> | $Enums.ProcessingType
    status?: EnumProcessingStatusFilter<"CaseProcessingQueue"> | $Enums.ProcessingStatus
    priority?: IntFilter<"CaseProcessingQueue"> | number
    attempts?: IntFilter<"CaseProcessingQueue"> | number
    maxAttempts?: IntFilter<"CaseProcessingQueue"> | number
    error?: StringNullableFilter<"CaseProcessingQueue"> | string | null
    scheduledAt?: DateTimeFilter<"CaseProcessingQueue"> | Date | string
    startedAt?: DateTimeNullableFilter<"CaseProcessingQueue"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"CaseProcessingQueue"> | Date | string | null
  }

  export type CourtCaseCreateWithoutProcessingQueueInput = {
    id?: string
    guid: string
    title: string
    neutralCitation?: string | null
    court: $Enums.CourtType
    publishDate: Date | string
    caseUrl: string
    summary?: string | null
    fullText?: string | null
    addresses?: CourtCaseCreateaddressesInput | string[]
    municipalities?: CourtCaseCreatemunicipalitiesInput | string[]
    parties?: CourtCaseCreatepartiesInput | string[]
    statutes?: CourtCaseCreatestatutesInput | string[]
    caseTypes?: CourtCaseCreatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: $Enums.RiskLevel
    isProcessed?: boolean
    nerProcessed?: boolean
    classified?: boolean
    source: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertCreateNestedManyWithoutCourtCaseInput
  }

  export type CourtCaseUncheckedCreateWithoutProcessingQueueInput = {
    id?: string
    guid: string
    title: string
    neutralCitation?: string | null
    court: $Enums.CourtType
    publishDate: Date | string
    caseUrl: string
    summary?: string | null
    fullText?: string | null
    addresses?: CourtCaseCreateaddressesInput | string[]
    municipalities?: CourtCaseCreatemunicipalitiesInput | string[]
    parties?: CourtCaseCreatepartiesInput | string[]
    statutes?: CourtCaseCreatestatutesInput | string[]
    caseTypes?: CourtCaseCreatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: $Enums.RiskLevel
    isProcessed?: boolean
    nerProcessed?: boolean
    classified?: boolean
    source: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutCourtCaseInput
  }

  export type CourtCaseCreateOrConnectWithoutProcessingQueueInput = {
    where: CourtCaseWhereUniqueInput
    create: XOR<CourtCaseCreateWithoutProcessingQueueInput, CourtCaseUncheckedCreateWithoutProcessingQueueInput>
  }

  export type CourtCaseUpsertWithoutProcessingQueueInput = {
    update: XOR<CourtCaseUpdateWithoutProcessingQueueInput, CourtCaseUncheckedUpdateWithoutProcessingQueueInput>
    create: XOR<CourtCaseCreateWithoutProcessingQueueInput, CourtCaseUncheckedCreateWithoutProcessingQueueInput>
    where?: CourtCaseWhereInput
  }

  export type CourtCaseUpdateToOneWithWhereWithoutProcessingQueueInput = {
    where?: CourtCaseWhereInput
    data: XOR<CourtCaseUpdateWithoutProcessingQueueInput, CourtCaseUncheckedUpdateWithoutProcessingQueueInput>
  }

  export type CourtCaseUpdateWithoutProcessingQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    guid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    neutralCitation?: NullableStringFieldUpdateOperationsInput | string | null
    court?: EnumCourtTypeFieldUpdateOperationsInput | $Enums.CourtType
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    caseUrl?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    fullText?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CourtCaseUpdateaddressesInput | string[]
    municipalities?: CourtCaseUpdatemunicipalitiesInput | string[]
    parties?: CourtCaseUpdatepartiesInput | string[]
    statutes?: CourtCaseUpdatestatutesInput | string[]
    caseTypes?: CourtCaseUpdatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    nerProcessed?: BoolFieldUpdateOperationsInput | boolean
    classified?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUpdateManyWithoutCourtCaseNestedInput
  }

  export type CourtCaseUncheckedUpdateWithoutProcessingQueueInput = {
    id?: StringFieldUpdateOperationsInput | string
    guid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    neutralCitation?: NullableStringFieldUpdateOperationsInput | string | null
    court?: EnumCourtTypeFieldUpdateOperationsInput | $Enums.CourtType
    publishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    caseUrl?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    fullText?: NullableStringFieldUpdateOperationsInput | string | null
    addresses?: CourtCaseUpdateaddressesInput | string[]
    municipalities?: CourtCaseUpdatemunicipalitiesInput | string[]
    parties?: CourtCaseUpdatepartiesInput | string[]
    statutes?: CourtCaseUpdatestatutesInput | string[]
    caseTypes?: CourtCaseUpdatecaseTypesInput | $Enums.RealEstateCaseType[]
    riskLevel?: EnumRiskLevelFieldUpdateOperationsInput | $Enums.RiskLevel
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    nerProcessed?: BoolFieldUpdateOperationsInput | boolean
    classified?: BoolFieldUpdateOperationsInput | boolean
    source?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutCourtCaseNestedInput
  }

  export type UserCreateWithoutAssignedTicketsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    ticketMessages?: SupportTicketMessageCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutAdminInput
  }

  export type UserUncheckedCreateWithoutAssignedTicketsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceUncheckedCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertUncheckedCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketMessages?: SupportTicketMessageUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UserCreateOrConnectWithoutAssignedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
  }

  export type UserCreateWithoutSupportTicketsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageCreateNestedManyWithoutUserInput
    adminActions?: AdminActionCreateNestedManyWithoutAdminInput
  }

  export type UserUncheckedCreateWithoutSupportTicketsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceUncheckedCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertUncheckedCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageUncheckedCreateNestedManyWithoutUserInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UserCreateOrConnectWithoutSupportTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
  }

  export type SupportTicketMessageCreateWithoutTicketInput = {
    id?: string
    message: string
    isFromAdmin?: boolean
    attachments?: SupportTicketMessageCreateattachmentsInput | string[]
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTicketMessagesInput
  }

  export type SupportTicketMessageUncheckedCreateWithoutTicketInput = {
    id?: string
    userId: string
    message: string
    isFromAdmin?: boolean
    attachments?: SupportTicketMessageCreateattachmentsInput | string[]
    createdAt?: Date | string
  }

  export type SupportTicketMessageCreateOrConnectWithoutTicketInput = {
    where: SupportTicketMessageWhereUniqueInput
    create: XOR<SupportTicketMessageCreateWithoutTicketInput, SupportTicketMessageUncheckedCreateWithoutTicketInput>
  }

  export type SupportTicketMessageCreateManyTicketInputEnvelope = {
    data: SupportTicketMessageCreateManyTicketInput | SupportTicketMessageCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAssignedTicketsInput = {
    update: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketMessages?: SupportTicketMessageUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutAdminNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUncheckedUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUncheckedUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketMessages?: SupportTicketMessageUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type UserUpsertWithoutSupportTicketsInput = {
    update: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupportTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type UserUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUpdateManyWithoutAdminNestedInput
  }

  export type UserUncheckedUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUncheckedUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUncheckedUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUncheckedUpdateManyWithoutUserNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type SupportTicketMessageUpsertWithWhereUniqueWithoutTicketInput = {
    where: SupportTicketMessageWhereUniqueInput
    update: XOR<SupportTicketMessageUpdateWithoutTicketInput, SupportTicketMessageUncheckedUpdateWithoutTicketInput>
    create: XOR<SupportTicketMessageCreateWithoutTicketInput, SupportTicketMessageUncheckedCreateWithoutTicketInput>
  }

  export type SupportTicketMessageUpdateWithWhereUniqueWithoutTicketInput = {
    where: SupportTicketMessageWhereUniqueInput
    data: XOR<SupportTicketMessageUpdateWithoutTicketInput, SupportTicketMessageUncheckedUpdateWithoutTicketInput>
  }

  export type SupportTicketMessageUpdateManyWithWhereWithoutTicketInput = {
    where: SupportTicketMessageScalarWhereInput
    data: XOR<SupportTicketMessageUpdateManyMutationInput, SupportTicketMessageUncheckedUpdateManyWithoutTicketInput>
  }

  export type SupportTicketCreateWithoutMessagesInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SupportTicketStatus
    priority?: $Enums.SupportTicketPriority
    category?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    user: UserCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    title: string
    description: string
    status?: $Enums.SupportTicketStatus
    priority?: $Enums.SupportTicketPriority
    category?: string | null
    assignedToId?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateOrConnectWithoutMessagesInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutTicketMessagesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    adminActions?: AdminActionCreateNestedManyWithoutAdminInput
  }

  export type UserUncheckedCreateWithoutTicketMessagesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceUncheckedCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertUncheckedCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    adminActions?: AdminActionUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UserCreateOrConnectWithoutTicketMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketMessagesInput, UserUncheckedCreateWithoutTicketMessagesInput>
  }

  export type SupportTicketUpsertWithoutMessagesInput = {
    update: XOR<SupportTicketUpdateWithoutMessagesInput, SupportTicketUncheckedUpdateWithoutMessagesInput>
    create: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
    where?: SupportTicketWhereInput
  }

  export type SupportTicketUpdateToOneWithWhereWithoutMessagesInput = {
    where?: SupportTicketWhereInput
    data: XOR<SupportTicketUpdateWithoutMessagesInput, SupportTicketUncheckedUpdateWithoutMessagesInput>
  }

  export type SupportTicketUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicketStatusFieldUpdateOperationsInput | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFieldUpdateOperationsInput | $Enums.SupportTicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    user?: UserUpdateOneRequiredWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicketStatusFieldUpdateOperationsInput | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFieldUpdateOperationsInput | $Enums.SupportTicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTicketMessagesInput = {
    update: XOR<UserUpdateWithoutTicketMessagesInput, UserUncheckedUpdateWithoutTicketMessagesInput>
    create: XOR<UserCreateWithoutTicketMessagesInput, UserUncheckedCreateWithoutTicketMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketMessagesInput, UserUncheckedUpdateWithoutTicketMessagesInput>
  }

  export type UserUpdateWithoutTicketMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    adminActions?: AdminActionUpdateManyWithoutAdminNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUncheckedUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUncheckedUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    adminActions?: AdminActionUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type UserCreateWithoutAdminActionsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminActionsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    phone?: string | null
    isActive?: boolean
    role?: $Enums.UserRole
    subscriptionTier?: $Enums.SubscriptionTier
    stripeCustomerId?: string | null
    subscriptionId?: string | null
    subscriptionStatus?: string | null
    company?: string | null
    location?: string | null
    teamSize?: string | null
    monthlyDeals?: string | null
    primaryFocus?: string | null
    techComfort?: string | null
    currentChallenges?: UserCreatecurrentChallengesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    alertPreferences?: AlertPreferenceUncheckedCreateNestedManyWithoutUserInput
    userAlerts?: UserAlertUncheckedCreateNestedManyWithoutUserInput
    savedProperties?: SavedPropertyUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    ticketMessages?: SupportTicketMessageUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminActionsInput, UserUncheckedCreateWithoutAdminActionsInput>
  }

  export type UserUpsertWithoutAdminActionsInput = {
    update: XOR<UserUpdateWithoutAdminActionsInput, UserUncheckedUpdateWithoutAdminActionsInput>
    create: XOR<UserCreateWithoutAdminActionsInput, UserUncheckedCreateWithoutAdminActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminActionsInput, UserUncheckedUpdateWithoutAdminActionsInput>
  }

  export type UserUpdateWithoutAdminActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamSize?: NullableStringFieldUpdateOperationsInput | string | null
    monthlyDeals?: NullableStringFieldUpdateOperationsInput | string | null
    primaryFocus?: NullableStringFieldUpdateOperationsInput | string | null
    techComfort?: NullableStringFieldUpdateOperationsInput | string | null
    currentChallenges?: UserUpdatecurrentChallengesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alertPreferences?: AlertPreferenceUncheckedUpdateManyWithoutUserNestedInput
    userAlerts?: UserAlertUncheckedUpdateManyWithoutUserNestedInput
    savedProperties?: SavedPropertyUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    ticketMessages?: SupportTicketMessageUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AlertPreferenceCreateManyUserInput = {
    id?: string
    cities?: AlertPreferenceCreatecitiesInput | string[]
    maxDistanceKm?: number
    propertyTypes?: AlertPreferenceCreatepropertyTypesInput | string[]
    minValue?: number | null
    maxValue?: number | null
    minBedrooms?: number | null
    maxBedrooms?: number | null
    alertTypes?: AlertPreferenceCreatealertTypesInput | $Enums.AlertType[]
    minPriority?: $Enums.Priority
    minOpportunityScore?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    pushNotifications?: boolean
    maxAlertsPerDay?: number
    quietHoursStart?: string | null
    quietHoursEnd?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAlertCreateManyUserInput = {
    id?: string
    alertId: string
    isNotified?: boolean
    notifiedAt?: Date | string | null
    isViewed?: boolean
    viewedAt?: Date | string | null
    isBookmarked?: boolean
    createdAt?: Date | string
  }

  export type SavedPropertyCreateManyUserInput = {
    id?: string
    alertId: string
    notes?: string | null
    tags?: SavedPropertyCreatetagsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityLogCreateManyUserInput = {
    id?: string
    action: $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SupportTicketCreateManyUserInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.SupportTicketStatus
    priority?: $Enums.SupportTicketPriority
    category?: string | null
    assignedToId?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateManyAssignedToInput = {
    id?: string
    userId: string
    title: string
    description: string
    status?: $Enums.SupportTicketStatus
    priority?: $Enums.SupportTicketPriority
    category?: string | null
    resolution?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketMessageCreateManyUserInput = {
    id?: string
    ticketId: string
    message: string
    isFromAdmin?: boolean
    attachments?: SupportTicketMessageCreateattachmentsInput | string[]
    createdAt?: Date | string
  }

  export type AdminActionCreateManyAdminInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AlertPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cities?: AlertPreferenceUpdatecitiesInput | string[]
    maxDistanceKm?: IntFieldUpdateOperationsInput | number
    propertyTypes?: AlertPreferenceUpdatepropertyTypesInput | string[]
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    alertTypes?: AlertPreferenceUpdatealertTypesInput | $Enums.AlertType[]
    minPriority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    minOpportunityScore?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxAlertsPerDay?: IntFieldUpdateOperationsInput | number
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cities?: AlertPreferenceUpdatecitiesInput | string[]
    maxDistanceKm?: IntFieldUpdateOperationsInput | number
    propertyTypes?: AlertPreferenceUpdatepropertyTypesInput | string[]
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    alertTypes?: AlertPreferenceUpdatealertTypesInput | $Enums.AlertType[]
    minPriority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    minOpportunityScore?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxAlertsPerDay?: IntFieldUpdateOperationsInput | number
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertPreferenceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cities?: AlertPreferenceUpdatecitiesInput | string[]
    maxDistanceKm?: IntFieldUpdateOperationsInput | number
    propertyTypes?: AlertPreferenceUpdatepropertyTypesInput | string[]
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    maxBedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    alertTypes?: AlertPreferenceUpdatealertTypesInput | $Enums.AlertType[]
    minPriority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    minOpportunityScore?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    maxAlertsPerDay?: IntFieldUpdateOperationsInput | number
    quietHoursStart?: NullableStringFieldUpdateOperationsInput | string | null
    quietHoursEnd?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBookmarked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alert?: AlertUpdateOneRequiredWithoutUserAlertsNestedInput
  }

  export type UserAlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    isNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBookmarked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    isNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBookmarked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedPropertyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SavedPropertyUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedPropertyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SavedPropertyUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedPropertyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: SavedPropertyUpdatetagsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicketStatusFieldUpdateOperationsInput | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFieldUpdateOperationsInput | $Enums.SupportTicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    messages?: SupportTicketMessageUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicketStatusFieldUpdateOperationsInput | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFieldUpdateOperationsInput | $Enums.SupportTicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SupportTicketMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicketStatusFieldUpdateOperationsInput | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFieldUpdateOperationsInput | $Enums.SupportTicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicketStatusFieldUpdateOperationsInput | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFieldUpdateOperationsInput | $Enums.SupportTicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSupportTicketsNestedInput
    messages?: SupportTicketMessageUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicketStatusFieldUpdateOperationsInput | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFieldUpdateOperationsInput | $Enums.SupportTicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SupportTicketMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportTicketStatusFieldUpdateOperationsInput | $Enums.SupportTicketStatus
    priority?: EnumSupportTicketPriorityFieldUpdateOperationsInput | $Enums.SupportTicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: SupportTicketMessageUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type SupportTicketMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: SupportTicketMessageUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: SupportTicketMessageUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertCreateManyAlertInput = {
    id?: string
    userId: string
    isNotified?: boolean
    notifiedAt?: Date | string | null
    isViewed?: boolean
    viewedAt?: Date | string | null
    isBookmarked?: boolean
    createdAt?: Date | string
  }

  export type UserAlertUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    isNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBookmarked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserAlertsNestedInput
  }

  export type UserAlertUncheckedUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBookmarked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAlertUncheckedUpdateManyWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isNotified?: BoolFieldUpdateOperationsInput | boolean
    notifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isViewed?: BoolFieldUpdateOperationsInput | boolean
    viewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBookmarked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyCourtCaseInput = {
    id?: string
    title: string
    description: string
    address: string
    city: string
    province?: string
    postalCode?: string | null
    alertType: $Enums.AlertType
    source: $Enums.DataSource
    status?: $Enums.AlertStatus
    priority?: $Enums.Priority
    opportunityScore?: number
    timelineMonths?: number | null
    propertyType?: string | null
    estimatedValue?: number | null
    lotSize?: string | null
    bedrooms?: number | null
    bathrooms?: number | null
    courtFileNumber?: string | null
    courtDate?: Date | string | null
    probateNumber?: string | null
    executorName?: string | null
    executorContact?: string | null
    applicationNumber?: string | null
    municipalOffice?: string | null
    applicationDate?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    discoveredAt?: Date | string
  }

  export type CaseProcessingQueueCreateManyCaseInput = {
    id?: string
    processType: $Enums.ProcessingType
    status?: $Enums.ProcessingStatus
    priority?: number
    attempts?: number
    maxAttempts?: number
    error?: string | null
    scheduledAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type AlertUpdateWithoutCourtCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    source?: EnumDataSourceFieldUpdateOperationsInput | $Enums.DataSource
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    opportunityScore?: IntFieldUpdateOperationsInput | number
    timelineMonths?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    courtFileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executorName?: NullableStringFieldUpdateOperationsInput | string | null
    executorContact?: NullableStringFieldUpdateOperationsInput | string | null
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    municipalOffice?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAlerts?: UserAlertUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutCourtCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    source?: EnumDataSourceFieldUpdateOperationsInput | $Enums.DataSource
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    opportunityScore?: IntFieldUpdateOperationsInput | number
    timelineMonths?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    courtFileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executorName?: NullableStringFieldUpdateOperationsInput | string | null
    executorContact?: NullableStringFieldUpdateOperationsInput | string | null
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    municipalOffice?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAlerts?: UserAlertUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateManyWithoutCourtCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    alertType?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    source?: EnumDataSourceFieldUpdateOperationsInput | $Enums.DataSource
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    opportunityScore?: IntFieldUpdateOperationsInput | number
    timelineMonths?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedValue?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableStringFieldUpdateOperationsInput | string | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    courtFileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    probateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    executorName?: NullableStringFieldUpdateOperationsInput | string | null
    executorContact?: NullableStringFieldUpdateOperationsInput | string | null
    applicationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    municipalOffice?: NullableStringFieldUpdateOperationsInput | string | null
    applicationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discoveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseProcessingQueueUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    processType?: EnumProcessingTypeFieldUpdateOperationsInput | $Enums.ProcessingType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CaseProcessingQueueUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    processType?: EnumProcessingTypeFieldUpdateOperationsInput | $Enums.ProcessingType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CaseProcessingQueueUncheckedUpdateManyWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    processType?: EnumProcessingTypeFieldUpdateOperationsInput | $Enums.ProcessingType
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    priority?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportTicketMessageCreateManyTicketInput = {
    id?: string
    userId: string
    message: string
    isFromAdmin?: boolean
    attachments?: SupportTicketMessageCreateattachmentsInput | string[]
    createdAt?: Date | string
  }

  export type SupportTicketMessageUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: SupportTicketMessageUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTicketMessagesNestedInput
  }

  export type SupportTicketMessageUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: SupportTicketMessageUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketMessageUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isFromAdmin?: BoolFieldUpdateOperationsInput | boolean
    attachments?: SupportTicketMessageUpdateattachmentsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}